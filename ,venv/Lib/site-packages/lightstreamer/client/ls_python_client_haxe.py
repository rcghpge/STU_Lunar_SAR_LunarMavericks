# Generated by Haxe 4.3.4
# coding: utf-8
import sys

import math as python_lib_Math
import math as Math
import inspect as python_lib_Inspect
from .ls_python_client_api import ItemUpdate as com_lightstreamer_client_ItemUpdate
from .ls_python_client_api import SubscriptionListener as com_lightstreamer_client_SubscriptionListener
import asyncio as com_lightstreamer_internal_Asyncio
from .com_lightstreamer_net import CookieHelper as com_lightstreamer_internal_CookieHelper
from .com_lightstreamer_net import HttpClientPy as com_lightstreamer_internal_HttpClientPy
import logging as com_lightstreamer_internal_Logging
import sys as python_lib_Sys
from threading import Thread as python_lib_threading_Thread
from .com_lightstreamer_net import WsClientPy as com_lightstreamer_internal_WsClientPy
import jsonpatch as com_lightstreamer_internal_patch_JsonPatcher
from .ls_python_client_api import Logger as com_lightstreamer_log_Logger
from .ls_python_client_api import LoggerProvider as com_lightstreamer_log_LoggerProvider
from threading import RLock as python_lib_threading_RLock
import threading as python_lib_Threading
import functools as python_lib_Functools
import json as python_lib_Json
import random as python_lib_Random
import re as python_lib_Re
import time as python_lib_Time
import timeit as python_lib_Timeit
import traceback as python_lib_Traceback
from datetime import datetime as python_lib_datetime_Datetime
from io import StringIO as python_lib_io_StringIO
from threading import Semaphore as python_lib_threading_Semaphore
import urllib.parse as python_lib_urllib_Parse


class _hx_AnonObject:
    _hx_disable_getattr = False
    def __init__(self, fields):
        self.__dict__ = fields
    def __repr__(self):
        return repr(self.__dict__)
    def __contains__(self, item):
        return item in self.__dict__
    def __getitem__(self, item):
        return self.__dict__[item]
    def __getattr__(self, name):
        if (self._hx_disable_getattr):
            raise AttributeError('field does not exist')
        else:
            return None
    def _hx_hasattr(self,field):
        self._hx_disable_getattr = True
        try:
            getattr(self, field)
            self._hx_disable_getattr = False
            return True
        except AttributeError:
            self._hx_disable_getattr = False
            return False



class Enum:
    _hx_class_name = "Enum"
    _hx_is_interface = "False"
    __slots__ = ("tag", "index", "params")
    _hx_fields = ["tag", "index", "params"]
    _hx_methods = ["__str__"]

    def __init__(self,tag,index,params):
        self.tag = tag
        self.index = index
        self.params = params

    def __str__(self):
        if (self.params is None):
            return self.tag
        else:
            return self.tag + '(' + (', '.join(str(v) for v in self.params)) + ')'

Enum._hx_class = Enum


class Class: pass


class EReg:
    _hx_class_name = "EReg"
    _hx_is_interface = "False"
    __slots__ = ("pattern", "matchObj", "_hx_global")
    _hx_fields = ["pattern", "matchObj", "global"]

    def __init__(self,r,opt):
        self.matchObj = None
        self._hx_global = False
        options = 0
        _g = 0
        _g1 = len(opt)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            c = (-1 if ((i >= len(opt))) else ord(opt[i]))
            if (c == 109):
                options = (options | python_lib_Re.M)
            if (c == 105):
                options = (options | python_lib_Re.I)
            if (c == 115):
                options = (options | python_lib_Re.S)
            if (c == 117):
                options = (options | python_lib_Re.U)
            if (c == 103):
                self._hx_global = True
        self.pattern = python_lib_Re.compile(r,options)

EReg._hx_class = EReg


class IntIterator:
    _hx_class_name = "IntIterator"
    _hx_is_interface = "False"
    __slots__ = ("min", "max")
    _hx_fields = ["min", "max"]
    _hx_methods = ["hasNext", "next"]

    def __init__(self,_hx_min,_hx_max):
        self.min = _hx_min
        self.max = _hx_max

    def hasNext(self):
        return (self.min < self.max)

    def next(self):
        def _hx_local_3():
            def _hx_local_2():
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.min
                _hx_local_0.min = (_hx_local_1 + 1)
                return _hx_local_1
            return _hx_local_2()
        return _hx_local_3()

IntIterator._hx_class = IntIterator


class Lambda:
    _hx_class_name = "Lambda"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["has", "exists", "count", "empty", "find"]

    @staticmethod
    def has(it,elt):
        x = HxOverrides.iterator(it)
        while x.hasNext():
            if HxOverrides.eq(x.next(),elt):
                return True
        return False

    @staticmethod
    def exists(it,f):
        x = HxOverrides.iterator(it)
        while x.hasNext():
            if f(x.next()):
                return True
        return False

    @staticmethod
    def count(it,pred = None):
        n = 0
        if (pred is None):
            _ = HxOverrides.iterator(it)
            while _.hasNext():
                _.next()
                n = (n + 1)
        else:
            x = HxOverrides.iterator(it)
            while x.hasNext():
                if pred(x.next()):
                    n = (n + 1)
        return n

    @staticmethod
    def empty(it):
        return (not HxOverrides.iterator(it).hasNext())

    @staticmethod
    def find(it,f):
        v = HxOverrides.iterator(it)
        while v.hasNext():
            v1 = v.next()
            if f(v1):
                return v1
        return None
Lambda._hx_class = Lambda


class Reflect:
    _hx_class_name = "Reflect"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["field"]

    @staticmethod
    def field(o,field):
        return python_Boot.field(o,field)
Reflect._hx_class = Reflect


class Std:
    _hx_class_name = "Std"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["downcast", "is", "isOfType", "string", "parseInt", "shortenPossibleNumber", "parseFloat"]

    @staticmethod
    def downcast(value,c):
        try:
            tmp = None
            if (not isinstance(value,c)):
                if c._hx_is_interface:
                    cls = c
                    loop = None
                    def _hx_local_1(intf):
                        f = (intf._hx_interfaces if (hasattr(intf,"_hx_interfaces")) else [])
                        if (f is not None):
                            _g = 0
                            while (_g < len(f)):
                                i = (f[_g] if _g >= 0 and _g < len(f) else None)
                                _g = (_g + 1)
                                if (i == cls):
                                    return True
                                elif loop(i):
                                    return True
                            return False
                        else:
                            return False
                    loop = _hx_local_1
                    currentClass = value.__class__
                    result = False
                    while (currentClass is not None):
                        if loop(currentClass):
                            result = True
                            break
                        currentClass = python_Boot.getSuperClass(currentClass)
                    tmp = result
                else:
                    tmp = False
            else:
                tmp = True
            if tmp:
                return value
            else:
                return None
        except BaseException as _g:
            None
            return None

    @staticmethod
    def _hx_is(v,t):
        return Std.isOfType(v,t)

    @staticmethod
    def isOfType(v,t):
        if ((v is None) and ((t is None))):
            return False
        if (t is None):
            return False
        if ((type(t) == type) and (t == Dynamic)):
            return (v is not None)
        isBool = isinstance(v,bool)
        if (((type(t) == type) and (t == Bool)) and isBool):
            return True
        if ((((not isBool) and (not ((type(t) == type) and (t == Bool)))) and ((type(t) == type) and (t == Int))) and isinstance(v,int)):
            return True
        vIsFloat = isinstance(v,float)
        tmp = None
        tmp1 = None
        if (((not isBool) and vIsFloat) and ((type(t) == type) and (t == Int))):
            f = v
            tmp1 = (((f != Math.POSITIVE_INFINITY) and ((f != Math.NEGATIVE_INFINITY))) and (not python_lib_Math.isnan(f)))
        else:
            tmp1 = False
        if tmp1:
            tmp1 = None
            try:
                tmp1 = int(v)
            except BaseException as _g:
                None
                tmp1 = None
            tmp = (v == tmp1)
        else:
            tmp = False
        if ((tmp and ((v <= 2147483647))) and ((v >= -2147483648))):
            return True
        if (((not isBool) and ((type(t) == type) and (t == Float))) and isinstance(v,(float, int))):
            return True
        if ((type(t) == type) and (t == str)):
            return isinstance(v,str)
        isEnumType = ((type(t) == type) and (t == Enum))
        if ((isEnumType and python_lib_Inspect.isclass(v)) and hasattr(v,"_hx_constructs")):
            return True
        if isEnumType:
            return False
        isClassType = ((type(t) == type) and (t == Class))
        if ((((isClassType and (not isinstance(v,Enum))) and python_lib_Inspect.isclass(v)) and hasattr(v,"_hx_class_name")) and (not hasattr(v,"_hx_constructs"))):
            return True
        if isClassType:
            return False
        tmp = None
        try:
            tmp = isinstance(v,t)
        except BaseException as _g:
            None
            tmp = False
        if tmp:
            return True
        if python_lib_Inspect.isclass(t):
            cls = t
            loop = None
            def _hx_local_1(intf):
                f = (intf._hx_interfaces if (hasattr(intf,"_hx_interfaces")) else [])
                if (f is not None):
                    _g = 0
                    while (_g < len(f)):
                        i = (f[_g] if _g >= 0 and _g < len(f) else None)
                        _g = (_g + 1)
                        if (i == cls):
                            return True
                        else:
                            l = loop(i)
                            if l:
                                return True
                    return False
                else:
                    return False
            loop = _hx_local_1
            currentClass = v.__class__
            result = False
            while (currentClass is not None):
                if loop(currentClass):
                    result = True
                    break
                currentClass = python_Boot.getSuperClass(currentClass)
            return result
        else:
            return False

    @staticmethod
    def string(s):
        return python_Boot.toString1(s,"")

    @staticmethod
    def parseInt(x):
        if (x is None):
            return None
        _hx_len = len(x)
        index = 0
        while (index < _hx_len):
            if (not (x[index] in " \n\r\t\x0B\x0C")):
                break
            index = (index + 1)
        isNegative = None
        if (index < _hx_len):
            sign = x[index]
            if ((sign == "-") or ((sign == "+"))):
                index = (index + 1)
            isNegative = (sign == "-")
        else:
            isNegative = False
        isHexadecimal = None
        if ((index + 1) < _hx_len):
            cur = x[index]
            next = x[(index + 1)]
            isHexadecimal = ((cur == "0") and (((next == "x") or ((next == "X")))))
        else:
            isHexadecimal = False
        if isHexadecimal:
            index = (index + 2)
        cur = index
        if isHexadecimal:
            while (cur < _hx_len):
                if (not (x[cur] in "0123456789abcdefABCDEF")):
                    break
                cur = (cur + 1)
        else:
            while (cur < _hx_len):
                if (not (x[cur] in "0123456789")):
                    break
                cur = (cur + 1)
        firstInvalidIndex = cur
        if (index == firstInvalidIndex):
            return None
        result = int(HxString.substring(x,index,firstInvalidIndex),(16 if isHexadecimal else 10))
        if isNegative:
            return -result
        else:
            return result

    @staticmethod
    def shortenPossibleNumber(x):
        r = ""
        _g = 0
        _g1 = len(x)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            c = ("" if (((i < 0) or ((i >= len(x))))) else x[i])
            _g2 = HxString.charCodeAt(c,0)
            if (_g2 is None):
                break
            elif (((((((((((_g2 == 57) or ((_g2 == 56))) or ((_g2 == 55))) or ((_g2 == 54))) or ((_g2 == 53))) or ((_g2 == 52))) or ((_g2 == 51))) or ((_g2 == 50))) or ((_g2 == 49))) or ((_g2 == 48))) or ((_g2 == 46))):
                r = (("null" if r is None else r) + ("null" if c is None else c))
            else:
                break
        return r

    @staticmethod
    def parseFloat(x):
        while True:
            try:
                return float(x)
            except BaseException as _g:
                None
                if (x is not None):
                    r1 = Std.shortenPossibleNumber(x)
                    if (r1 != x):
                        x = r1
                        continue
                return Math.NaN
Std._hx_class = Std


class Float: pass


class Int: pass


class Bool: pass


class Dynamic: pass


class StringBuf:
    _hx_class_name = "StringBuf"
    _hx_is_interface = "False"
    __slots__ = ("b",)
    _hx_fields = ["b"]

    def __init__(self):
        self.b = python_lib_io_StringIO()

StringBuf._hx_class = StringBuf


class Sys:
    _hx_class_name = "Sys"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["systemName"]

    @staticmethod
    def systemName():
        _g = python_lib_Sys.platform
        if _g.startswith("linux"):
            return "Linux"
        else:
            _hx_local_0 = len(_g)
            if (_hx_local_0 == 5):
                if (_g == "win32"):
                    return "Windows"
                else:
                    raise haxe_Exception.thrown("not supported platform")
            elif (_hx_local_0 == 6):
                if (_g == "cygwin"):
                    return "Windows"
                elif (_g == "darwin"):
                    return "Mac"
                else:
                    raise haxe_Exception.thrown("not supported platform")
            else:
                raise haxe_Exception.thrown("not supported platform")
Sys._hx_class = Sys


class Type:
    _hx_class_name = "Type"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["enumEq"]

    @staticmethod
    def enumEq(a,b):
        if HxOverrides.eq(a,b):
            return True
        try:
            if ((b is None) and (not HxOverrides.eq(a,b))):
                return False
            if (a.tag != b.tag):
                return False
            p1 = a.params
            p2 = b.params
            if (len(p1) != len(p2)):
                return False
            _g = 0
            _g1 = len(p1)
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                if (not Type.enumEq(p1[i],p2[i])):
                    return False
            if (a._hx_class != b._hx_class):
                return False
        except BaseException as _g:
            None
            return False
        return True
Type._hx_class = Type


class LSConnectionDetails:
    _hx_class_name = "LSConnectionDetails"
    _hx_is_interface = "False"
    __slots__ = ("serverAddress", "adapterSet", "user", "password", "sessionId", "serverInstanceAddress", "serverSocketName", "clientIp", "client", "lock")
    _hx_fields = ["serverAddress", "adapterSet", "user", "password", "sessionId", "serverInstanceAddress", "serverSocketName", "clientIp", "client", "lock"]
    _hx_methods = ["getServerAddress", "setServerAddress", "getAdapterSet", "setAdapterSet", "getUser", "setUser", "setPassword", "getSessionId", "setSessionId", "getServerInstanceAddress", "setServerInstanceAddress", "getServerSocketName", "setServerSocketName", "getClientIp", "setClientIp", "toString"]

    def __init__(self,client):
        self.clientIp = None
        self.serverSocketName = None
        self.serverInstanceAddress = None
        self.sessionId = None
        self.password = None
        self.user = None
        self.adapterSet = None
        self.serverAddress = com_lightstreamer_client__ConnectionDetails_ConnectionDetails_Fields_.DEFAULT_SERVER
        self.client = client
        self.lock = client.lock

    def getServerAddress(self):
        _gthis = self
        def _hx_local_1():
            def _hx_local_0():
                return _gthis.serverAddress
            return self.lock.synchronized(_hx_local_0)
        return _hx_local_1()

    def setServerAddress(self,serverAddress):
        _gthis = self
        def _hx_local_0():
            newValue = com_lightstreamer_internal__Types_ServerAddress_Impl_.fromString(serverAddress)
            if (newValue == _gthis.serverAddress):
                return
            if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.actionLogger.isInfoEnabled():
                com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.actionLogger.info(("serverAddress changed: " + Std.string(newValue)))
            oldValue = _gthis.serverAddress
            _gthis.serverAddress = newValue
            _gthis.client.eventDispatcher.onPropertyChange("serverAddress")
            if (oldValue != newValue):
                _gthis.client.machine.evtServerAddressChanged()
        self.lock.synchronized(_hx_local_0)

    def getAdapterSet(self):
        _gthis = self
        def _hx_local_1():
            def _hx_local_0():
                return _gthis.adapterSet
            return self.lock.synchronized(_hx_local_0)
        return _hx_local_1()

    def setAdapterSet(self,adapterSet):
        _gthis = self
        def _hx_local_0():
            if (adapterSet == _gthis.adapterSet):
                return
            if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.actionLogger.isInfoEnabled():
                com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.actionLogger.info(("adapterSet changed: " + ("null" if adapterSet is None else adapterSet)))
            _gthis.adapterSet = adapterSet
            _gthis.client.eventDispatcher.onPropertyChange("adapterSet")
        self.lock.synchronized(_hx_local_0)

    def getUser(self):
        _gthis = self
        def _hx_local_1():
            def _hx_local_0():
                return _gthis.user
            return self.lock.synchronized(_hx_local_0)
        return _hx_local_1()

    def setUser(self,user):
        _gthis = self
        def _hx_local_0():
            if (user == _gthis.user):
                return
            if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.actionLogger.isInfoEnabled():
                com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.actionLogger.info(("user changed: " + ("null" if user is None else user)))
            _gthis.user = user
            _gthis.client.eventDispatcher.onPropertyChange("user")
        self.lock.synchronized(_hx_local_0)

    def setPassword(self,password):
        _gthis = self
        def _hx_local_0():
            if (password == _gthis.password):
                return
            if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.actionLogger.isInfoEnabled():
                com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.actionLogger.info("password changed")
            _gthis.password = password
            _gthis.client.eventDispatcher.onPropertyChange("password")
        self.lock.synchronized(_hx_local_0)

    def getSessionId(self):
        _gthis = self
        def _hx_local_1():
            def _hx_local_0():
                return _gthis.sessionId
            return self.lock.synchronized(_hx_local_0)
        return _hx_local_1()

    def setSessionId(self,sessionId):
        if (sessionId == self.sessionId):
            return
        self.sessionId = sessionId
        self.client.eventDispatcher.onPropertyChange("sessionId")

    def getServerInstanceAddress(self):
        _gthis = self
        def _hx_local_1():
            def _hx_local_0():
                return _gthis.serverInstanceAddress
            return self.lock.synchronized(_hx_local_0)
        return _hx_local_1()

    def setServerInstanceAddress(self,serverInstanceAddress):
        if (serverInstanceAddress == self.serverInstanceAddress):
            return
        self.serverInstanceAddress = serverInstanceAddress
        self.client.eventDispatcher.onPropertyChange("serverInstanceAddress")

    def getServerSocketName(self):
        _gthis = self
        def _hx_local_1():
            def _hx_local_0():
                return _gthis.serverSocketName
            return self.lock.synchronized(_hx_local_0)
        return _hx_local_1()

    def setServerSocketName(self,serverSocketName):
        if (serverSocketName == self.serverSocketName):
            return
        self.serverSocketName = serverSocketName
        self.client.eventDispatcher.onPropertyChange("serverSocketName")

    def getClientIp(self):
        _gthis = self
        def _hx_local_1():
            def _hx_local_0():
                return _gthis.clientIp
            return self.lock.synchronized(_hx_local_0)
        return _hx_local_1()

    def setClientIp(self,clientIp):
        if (clientIp == self.clientIp):
            return
        self.clientIp = clientIp
        self.client.eventDispatcher.onPropertyChange("clientIp")

    def toString(self):
        _gthis = self
        def _hx_local_1():
            def _hx_local_0():
                _hx_map = com_lightstreamer_internal__InfoMap_InfoMap_Impl_._new()
                com_lightstreamer_internal__InfoMap_InfoMap_Impl_.set(_hx_map,"serverAddress",_gthis.serverAddress)
                com_lightstreamer_internal__InfoMap_InfoMap_Impl_.set(_hx_map,"adapterSet",_gthis.adapterSet)
                com_lightstreamer_internal__InfoMap_InfoMap_Impl_.set(_hx_map,"user",_gthis.user)
                com_lightstreamer_internal__InfoMap_InfoMap_Impl_.set(_hx_map,"sessionId",_gthis.sessionId)
                com_lightstreamer_internal__InfoMap_InfoMap_Impl_.set(_hx_map,"serverInstanceAddress",_gthis.serverInstanceAddress)
                com_lightstreamer_internal__InfoMap_InfoMap_Impl_.set(_hx_map,"serverSocketName",_gthis.serverSocketName)
                com_lightstreamer_internal__InfoMap_InfoMap_Impl_.set(_hx_map,"clientIp",_gthis.clientIp)
                com_lightstreamer_internal__InfoMap_InfoMap_Impl_.set(_hx_map,"libVersion",((HxOverrides.stringOrNull(LSLightstreamerClient.LIB_NAME) + " ") + HxOverrides.stringOrNull(LSLightstreamerClient.LIB_VERSION)))
                return _hx_map.toString()
            return self.lock.synchronized(_hx_local_0)
        return _hx_local_1()

LSConnectionDetails._hx_class = LSConnectionDetails


class com_lightstreamer_client__ConnectionDetails_ConnectionDetails_Fields_:
    _hx_class_name = "com.lightstreamer.client._ConnectionDetails.ConnectionDetails_Fields_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["DEFAULT_SERVER"]
com_lightstreamer_client__ConnectionDetails_ConnectionDetails_Fields_._hx_class = com_lightstreamer_client__ConnectionDetails_ConnectionDetails_Fields_


class LSConnectionOptions:
    _hx_class_name = "LSConnectionOptions"
    _hx_is_interface = "False"
    __slots__ = ("contentLength", "firstRetryMaxDelay", "forcedTransport", "httpExtraHeaders", "idleTimeout", "keepaliveInterval", "requestedMaxBandwidth", "realMaxBandwidth", "pollingInterval", "reconnectTimeout", "retryDelay", "reverseHeartbeatInterval", "sessionRecoveryTimeout", "stalledTimeout", "httpExtraHeadersOnSessionCreationOnly", "serverInstanceAddressIgnored", "slowingEnabled", "client", "lock", "proxy")
    _hx_fields = ["contentLength", "firstRetryMaxDelay", "forcedTransport", "httpExtraHeaders", "idleTimeout", "keepaliveInterval", "requestedMaxBandwidth", "realMaxBandwidth", "pollingInterval", "reconnectTimeout", "retryDelay", "reverseHeartbeatInterval", "sessionRecoveryTimeout", "stalledTimeout", "httpExtraHeadersOnSessionCreationOnly", "serverInstanceAddressIgnored", "slowingEnabled", "client", "lock", "proxy"]
    _hx_methods = ["getContentLength", "setContentLength", "getFirstRetryMaxDelay", "setFirstRetryMaxDelay", "getForcedTransport", "setForcedTransport", "getHttpExtraHeaders", "setHttpExtraHeaders", "mapEq", "getIdleTimeout", "setIdleTimeout", "getKeepaliveInterval", "setKeepaliveInterval", "getRequestedMaxBandwidth", "setRequestedMaxBandwidth", "getRealMaxBandwidth", "setRealMaxBandwidth", "getPollingInterval", "setPollingInterval", "getReconnectTimeout", "setReconnectTimeout", "getRetryDelay", "setRetryDelay", "getReverseHeartbeatInterval", "setReverseHeartbeatInterval", "getSessionRecoveryTimeout", "setSessionRecoveryTimeout", "getStalledTimeout", "setStalledTimeout", "isHttpExtraHeadersOnSessionCreationOnly", "setHttpExtraHeadersOnSessionCreationOnly", "isServerInstanceAddressIgnored", "setServerInstanceAddressIgnored", "isSlowingEnabled", "setSlowingEnabled", "setProxy", "getProxy", "toString"]

    def __init__(self,client):
        self.proxy = None
        self.slowingEnabled = False
        self.serverInstanceAddressIgnored = False
        self.httpExtraHeadersOnSessionCreationOnly = False
        self.stalledTimeout = 2000
        self.sessionRecoveryTimeout = 15000
        self.reverseHeartbeatInterval = 0
        self.retryDelay = 4000
        self.reconnectTimeout = 3000
        self.pollingInterval = 0
        self.realMaxBandwidth = None
        self.requestedMaxBandwidth = com_lightstreamer_internal_RequestedMaxBandwidth.BWUnlimited
        self.keepaliveInterval = 0
        self.idleTimeout = 19000
        self.httpExtraHeaders = None
        self.forcedTransport = None
        self.firstRetryMaxDelay = 100
        self.contentLength = 50000000
        self.client = client
        self.lock = client.lock

    def getContentLength(self):
        _gthis = self
        def _hx_local_1():
            def _hx_local_0():
                return _gthis.contentLength
            return self.lock.synchronized(_hx_local_0)
        return _hx_local_1()

    def setContentLength(self,contentLength):
        _gthis = self
        def _hx_local_0():
            newValue = com_lightstreamer_internal__Types_ContentLength_Impl_.fromIntGt0(contentLength)
            if (newValue == _gthis.contentLength):
                return
            if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.actionLogger.isInfoEnabled():
                com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.actionLogger.info(("contentLength changed: " + Std.string(newValue)))
            _gthis.contentLength = newValue
            _gthis.client.eventDispatcher.onPropertyChange("contentLength")
        self.lock.synchronized(_hx_local_0)

    def getFirstRetryMaxDelay(self):
        _gthis = self
        def _hx_local_1():
            def _hx_local_0():
                return _gthis.firstRetryMaxDelay
            return self.lock.synchronized(_hx_local_0)
        return _hx_local_1()

    def setFirstRetryMaxDelay(self,firstRetryMaxDelay):
        _gthis = self
        def _hx_local_0():
            newValue = com_lightstreamer_internal__Types_Millis_Impl_.fromIntGt0(firstRetryMaxDelay)
            if (newValue == _gthis.firstRetryMaxDelay):
                return
            if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.actionLogger.isInfoEnabled():
                com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.actionLogger.info(("firstRetryMaxDelay changed: " + Std.string(newValue)))
            _gthis.firstRetryMaxDelay = newValue
            _gthis.client.eventDispatcher.onPropertyChange("firstRetryMaxDelay")
        self.lock.synchronized(_hx_local_0)

    def getForcedTransport(self):
        _gthis = self
        def _hx_local_1():
            def _hx_local_0():
                return _gthis.forcedTransport
            return self.lock.synchronized(_hx_local_0)
        return _hx_local_1()

    def setForcedTransport(self,forcedTransport):
        _gthis = self
        def _hx_local_0():
            newValue = com_lightstreamer_internal__Types_TransportSelection_Impl_.fromString(forcedTransport)
            if (newValue == _gthis.forcedTransport):
                return
            if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.actionLogger.isInfoEnabled():
                com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.actionLogger.info(("forcedTransport changed: " + Std.string(newValue)))
            _gthis.forcedTransport = newValue
            _gthis.client.eventDispatcher.onPropertyChange("forcedTransport")
            _gthis.client.machine.evtExtSetForcedTransport()
        self.lock.synchronized(_hx_local_0)

    def getHttpExtraHeaders(self):
        _gthis = self
        def _hx_local_1():
            def _hx_local_0():
                if (_gthis.httpExtraHeaders is None):
                    return None
                else:
                    return com_lightstreamer_internal__NativeTypes_NativeStringMap_Impl_._new(_gthis.httpExtraHeaders)
            return self.lock.synchronized(_hx_local_0)
        return _hx_local_1()

    def setHttpExtraHeaders(self,httpExtraHeaders):
        _gthis = self
        def _hx_local_0():
            newValue = (com_lightstreamer_internal__NativeTypes_NativeStringMap_Impl_.toHaxe(httpExtraHeaders) if ((httpExtraHeaders is not None)) else None)
            if _gthis.mapEq(newValue,_gthis.httpExtraHeaders):
                return
            if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.actionLogger.isInfoEnabled():
                com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.actionLogger.info(("httpExtraHeaders changed: " + HxOverrides.stringOrNull((("null" if ((newValue is None)) else newValue.toString())))))
            _gthis.httpExtraHeaders = newValue
            _gthis.client.eventDispatcher.onPropertyChange("httpExtraHeaders")
        self.lock.synchronized(_hx_local_0)

    def mapEq(self,m1,m2):
        if (m1 == m2):
            return True
        if ((m1 is None) or ((m2 is None))):
            return False
        if (Lambda.count(m1) != Lambda.count(m2)):
            return False
        _hx_map = m1
        _g_keys = _hx_map.keys()
        while _g_keys.hasNext():
            key = _g_keys.next()
            if (_hx_map.get(key) != m2.h.get(key,None)):
                return False
        return True

    def getIdleTimeout(self):
        _gthis = self
        def _hx_local_1():
            def _hx_local_0():
                return _gthis.idleTimeout
            return self.lock.synchronized(_hx_local_0)
        return _hx_local_1()

    def setIdleTimeout(self,idleTimeout):
        _gthis = self
        def _hx_local_0():
            newValue = com_lightstreamer_internal__Types_Millis_Impl_.fromIntGtEq0(idleTimeout)
            if (newValue == _gthis.idleTimeout):
                return
            if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.actionLogger.isInfoEnabled():
                com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.actionLogger.info(("idleTimeout changed: " + Std.string(newValue)))
            _gthis.idleTimeout = newValue
            _gthis.client.eventDispatcher.onPropertyChange("idleTimeout")
        self.lock.synchronized(_hx_local_0)

    def getKeepaliveInterval(self):
        _gthis = self
        def _hx_local_1():
            def _hx_local_0():
                return _gthis.keepaliveInterval
            return self.lock.synchronized(_hx_local_0)
        return _hx_local_1()

    def setKeepaliveInterval(self,keepaliveInterval):
        _gthis = self
        def _hx_local_0():
            newValue = com_lightstreamer_internal__Types_Millis_Impl_.fromIntGtEq0(keepaliveInterval)
            if (newValue == _gthis.keepaliveInterval):
                return
            if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.actionLogger.isInfoEnabled():
                com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.actionLogger.info(("keepaliveInterval changed: " + Std.string(newValue)))
            _gthis.keepaliveInterval = newValue
            _gthis.client.eventDispatcher.onPropertyChange("keepaliveInterval")
        self.lock.synchronized(_hx_local_0)

    def getRequestedMaxBandwidth(self):
        _gthis = self
        def _hx_local_1():
            def _hx_local_0():
                return com_lightstreamer_internal_RequestedMaxBandwidthTools.toString(_gthis.requestedMaxBandwidth)
            return self.lock.synchronized(_hx_local_0)
        return _hx_local_1()

    def setRequestedMaxBandwidth(self,maxBandwidth):
        _gthis = self
        def _hx_local_0():
            nonlocal maxBandwidth
            if (maxBandwidth is not None):
                maxBandwidth = Std.string(maxBandwidth)
            newValue = com_lightstreamer_internal_RequestedMaxBandwidthTools.fromString(maxBandwidth)
            if Type.enumEq(newValue,_gthis.requestedMaxBandwidth):
                return
            if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.actionLogger.isInfoEnabled():
                com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.actionLogger.info(("requestedMaxBandwidth changed: " + HxOverrides.stringOrNull(com_lightstreamer_internal_RequestedMaxBandwidthTools.toString(newValue))))
            _gthis.requestedMaxBandwidth = newValue
            _gthis.client.eventDispatcher.onPropertyChange("requestedMaxBandwidth")
            _gthis.client.machine.evtExtSetRequestedMaxBandwidth()
        self.lock.synchronized(_hx_local_0)

    def getRealMaxBandwidth(self):
        _gthis = self
        def _hx_local_1():
            def _hx_local_0():
                return com_lightstreamer_internal_RealMaxBandwidthTools.toString(_gthis.realMaxBandwidth)
            return self.lock.synchronized(_hx_local_0)
        return _hx_local_1()

    def setRealMaxBandwidth(self,newValue):
        if com_lightstreamer_internal_RealMaxBandwidthTools.eq(newValue,self.realMaxBandwidth):
            return
        self.realMaxBandwidth = newValue
        self.client.eventDispatcher.onPropertyChange("realMaxBandwidth")

    def getPollingInterval(self):
        _gthis = self
        def _hx_local_1():
            def _hx_local_0():
                return _gthis.pollingInterval
            return self.lock.synchronized(_hx_local_0)
        return _hx_local_1()

    def setPollingInterval(self,pollingInterval):
        _gthis = self
        def _hx_local_0():
            newValue = com_lightstreamer_internal__Types_Millis_Impl_.fromIntGtEq0(pollingInterval)
            if (newValue == _gthis.pollingInterval):
                return
            if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.actionLogger.isInfoEnabled():
                com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.actionLogger.info(("pollingInterval changed: " + Std.string(newValue)))
            _gthis.pollingInterval = newValue
            _gthis.client.eventDispatcher.onPropertyChange("pollingInterval")
        self.lock.synchronized(_hx_local_0)

    def getReconnectTimeout(self):
        _gthis = self
        def _hx_local_1():
            def _hx_local_0():
                return _gthis.reconnectTimeout
            return self.lock.synchronized(_hx_local_0)
        return _hx_local_1()

    def setReconnectTimeout(self,reconnectTimeout):
        _gthis = self
        def _hx_local_0():
            newValue = com_lightstreamer_internal__Types_Millis_Impl_.fromIntGt0(reconnectTimeout)
            if (newValue == _gthis.reconnectTimeout):
                return
            if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.actionLogger.isInfoEnabled():
                com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.actionLogger.info(("reconnectTimeout changed: " + Std.string(newValue)))
            _gthis.reconnectTimeout = newValue
            _gthis.client.eventDispatcher.onPropertyChange("reconnectTimeout")
        self.lock.synchronized(_hx_local_0)

    def getRetryDelay(self):
        _gthis = self
        def _hx_local_1():
            def _hx_local_0():
                return _gthis.retryDelay
            return self.lock.synchronized(_hx_local_0)
        return _hx_local_1()

    def setRetryDelay(self,retryDelay):
        _gthis = self
        def _hx_local_0():
            newValue = com_lightstreamer_internal__Types_Millis_Impl_.fromIntGt0(retryDelay)
            if (newValue == _gthis.retryDelay):
                return
            if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.actionLogger.isInfoEnabled():
                com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.actionLogger.info(("retryDelay changed: " + Std.string(newValue)))
            _gthis.retryDelay = newValue
            _gthis.client.eventDispatcher.onPropertyChange("retryDelay")
        self.lock.synchronized(_hx_local_0)

    def getReverseHeartbeatInterval(self):
        _gthis = self
        def _hx_local_1():
            def _hx_local_0():
                return _gthis.reverseHeartbeatInterval
            return self.lock.synchronized(_hx_local_0)
        return _hx_local_1()

    def setReverseHeartbeatInterval(self,reverseHeartbeatInterval):
        _gthis = self
        def _hx_local_0():
            newValue = com_lightstreamer_internal__Types_Millis_Impl_.fromIntGtEq0(reverseHeartbeatInterval)
            if (newValue == _gthis.reverseHeartbeatInterval):
                return
            if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.actionLogger.isInfoEnabled():
                com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.actionLogger.info(("reverseHeartbeatInterval changed: " + Std.string(newValue)))
            _gthis.reverseHeartbeatInterval = newValue
            _gthis.client.eventDispatcher.onPropertyChange("reverseHeartbeatInterval")
            _gthis.client.machine.evtExtSetReverseHeartbeatInterval()
        self.lock.synchronized(_hx_local_0)

    def getSessionRecoveryTimeout(self):
        _gthis = self
        def _hx_local_1():
            def _hx_local_0():
                return _gthis.sessionRecoveryTimeout
            return self.lock.synchronized(_hx_local_0)
        return _hx_local_1()

    def setSessionRecoveryTimeout(self,sessionRecoveryTimeout):
        _gthis = self
        def _hx_local_0():
            newValue = com_lightstreamer_internal__Types_Millis_Impl_.fromIntGtEq0(sessionRecoveryTimeout)
            if (newValue == _gthis.sessionRecoveryTimeout):
                return
            if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.actionLogger.isInfoEnabled():
                com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.actionLogger.info(("sessionRecoveryTimeout changed: " + Std.string(newValue)))
            _gthis.sessionRecoveryTimeout = newValue
            _gthis.client.eventDispatcher.onPropertyChange("sessionRecoveryTimeout")
        self.lock.synchronized(_hx_local_0)

    def getStalledTimeout(self):
        _gthis = self
        def _hx_local_1():
            def _hx_local_0():
                return _gthis.stalledTimeout
            return self.lock.synchronized(_hx_local_0)
        return _hx_local_1()

    def setStalledTimeout(self,stalledTimeout):
        _gthis = self
        def _hx_local_0():
            newValue = com_lightstreamer_internal__Types_Millis_Impl_.fromIntGt0(stalledTimeout)
            if (newValue == _gthis.stalledTimeout):
                return
            if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.actionLogger.isInfoEnabled():
                com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.actionLogger.info(("stalledTimeout changed: " + Std.string(newValue)))
            _gthis.stalledTimeout = newValue
            _gthis.client.eventDispatcher.onPropertyChange("stalledTimeout")
        self.lock.synchronized(_hx_local_0)

    def isHttpExtraHeadersOnSessionCreationOnly(self):
        _gthis = self
        def _hx_local_1():
            def _hx_local_0():
                return _gthis.httpExtraHeadersOnSessionCreationOnly
            return self.lock.synchronized(_hx_local_0)
        return _hx_local_1()

    def setHttpExtraHeadersOnSessionCreationOnly(self,httpExtraHeadersOnSessionCreationOnly):
        _gthis = self
        def _hx_local_0():
            if (httpExtraHeadersOnSessionCreationOnly == _gthis.httpExtraHeadersOnSessionCreationOnly):
                return
            if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.actionLogger.isInfoEnabled():
                com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.actionLogger.info(("httpExtraHeadersOnSessionCreationOnly changed: " + Std.string(httpExtraHeadersOnSessionCreationOnly)))
            _gthis.httpExtraHeadersOnSessionCreationOnly = httpExtraHeadersOnSessionCreationOnly
            _gthis.client.eventDispatcher.onPropertyChange("httpExtraHeadersOnSessionCreationOnly")
        self.lock.synchronized(_hx_local_0)

    def isServerInstanceAddressIgnored(self):
        _gthis = self
        def _hx_local_1():
            def _hx_local_0():
                return _gthis.serverInstanceAddressIgnored
            return self.lock.synchronized(_hx_local_0)
        return _hx_local_1()

    def setServerInstanceAddressIgnored(self,serverInstanceAddressIgnored):
        _gthis = self
        def _hx_local_0():
            if (serverInstanceAddressIgnored == _gthis.serverInstanceAddressIgnored):
                return
            if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.actionLogger.isInfoEnabled():
                com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.actionLogger.info(("serverInstanceAddressIgnored changed: " + Std.string(serverInstanceAddressIgnored)))
            _gthis.serverInstanceAddressIgnored = serverInstanceAddressIgnored
            _gthis.client.eventDispatcher.onPropertyChange("serverInstanceAddressIgnored")
        self.lock.synchronized(_hx_local_0)

    def isSlowingEnabled(self):
        _gthis = self
        def _hx_local_1():
            def _hx_local_0():
                return _gthis.slowingEnabled
            return self.lock.synchronized(_hx_local_0)
        return _hx_local_1()

    def setSlowingEnabled(self,slowingEnabled):
        _gthis = self
        def _hx_local_0():
            if (slowingEnabled == _gthis.slowingEnabled):
                return
            if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.actionLogger.isInfoEnabled():
                com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.actionLogger.info(("slowingEnabled changed: " + Std.string(slowingEnabled)))
            _gthis.slowingEnabled = slowingEnabled
            _gthis.client.eventDispatcher.onPropertyChange("slowingEnabled")
        self.lock.synchronized(_hx_local_0)

    def setProxy(self,proxy):
        _gthis = self
        def _hx_local_0():
            if LSProxy.eq(proxy,_gthis.proxy):
                return
            if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.actionLogger.isInfoEnabled():
                com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.actionLogger.info(("proxy changed: " + Std.string(proxy)))
            _gthis.proxy = proxy
            _gthis.client.eventDispatcher.onPropertyChange("proxy")
        self.lock.synchronized(_hx_local_0)

    def getProxy(self):
        _gthis = self
        def _hx_local_1():
            def _hx_local_0():
                return _gthis.proxy
            return self.lock.synchronized(_hx_local_0)
        return _hx_local_1()

    def toString(self):
        _gthis = self
        def _hx_local_1():
            def _hx_local_0():
                _hx_map = com_lightstreamer_internal__InfoMap_InfoMap_Impl_._new()
                com_lightstreamer_internal__InfoMap_InfoMap_Impl_.set(_hx_map,"forcedTransport",_gthis.forcedTransport)
                com_lightstreamer_internal__InfoMap_InfoMap_Impl_.set(_hx_map,"requestedMaxBandwidth",_gthis.requestedMaxBandwidth)
                com_lightstreamer_internal__InfoMap_InfoMap_Impl_.set(_hx_map,"realMaxBandwidth",_gthis.realMaxBandwidth)
                com_lightstreamer_internal__InfoMap_InfoMap_Impl_.set(_hx_map,"retryDelay",_gthis.retryDelay)
                com_lightstreamer_internal__InfoMap_InfoMap_Impl_.set(_hx_map,"firstRetryMaxDelay",_gthis.firstRetryMaxDelay)
                com_lightstreamer_internal__InfoMap_InfoMap_Impl_.set(_hx_map,"sessionRecoveryTimeout",_gthis.sessionRecoveryTimeout)
                com_lightstreamer_internal__InfoMap_InfoMap_Impl_.set(_hx_map,"reverseHeartbeatInterval",_gthis.reverseHeartbeatInterval)
                com_lightstreamer_internal__InfoMap_InfoMap_Impl_.set(_hx_map,"stalledTimeout",_gthis.stalledTimeout)
                com_lightstreamer_internal__InfoMap_InfoMap_Impl_.set(_hx_map,"reconnectTimeout",_gthis.reconnectTimeout)
                com_lightstreamer_internal__InfoMap_InfoMap_Impl_.set(_hx_map,"keepaliveInterval",_gthis.keepaliveInterval)
                com_lightstreamer_internal__InfoMap_InfoMap_Impl_.set(_hx_map,"pollingInterval",_gthis.pollingInterval)
                com_lightstreamer_internal__InfoMap_InfoMap_Impl_.set(_hx_map,"idleTimeout",_gthis.idleTimeout)
                com_lightstreamer_internal__InfoMap_InfoMap_Impl_.set(_hx_map,"contentLength",_gthis.contentLength)
                com_lightstreamer_internal__InfoMap_InfoMap_Impl_.set(_hx_map,"slowingEnabled",_gthis.slowingEnabled)
                com_lightstreamer_internal__InfoMap_InfoMap_Impl_.set(_hx_map,"serverInstanceAddressIgnored",_gthis.serverInstanceAddressIgnored)
                com_lightstreamer_internal__InfoMap_InfoMap_Impl_.set(_hx_map,"HTTPExtraHeadersOnSessionCreationOnly",_gthis.httpExtraHeadersOnSessionCreationOnly)
                com_lightstreamer_internal__InfoMap_InfoMap_Impl_.set(_hx_map,"HTTPExtraHeaders",_gthis.httpExtraHeaders)
                com_lightstreamer_internal__InfoMap_InfoMap_Impl_.set(_hx_map,"proxy",_gthis.proxy)
                return _hx_map.toString()
            return self.lock.synchronized(_hx_local_0)
        return _hx_local_1()

LSConnectionOptions._hx_class = LSConnectionOptions


class com_lightstreamer_internal_EventDispatcher:
    _hx_class_name = "com.lightstreamer.internal.EventDispatcher"
    _hx_is_interface = "False"
    __slots__ = ("listeners",)
    _hx_fields = ["listeners"]
    _hx_methods = ["addListener", "removeListener", "getListeners", "dispatchToAll", "dispatchToOne"]

    def __init__(self):
        self.listeners = list()

    def addListener(self,listener):
        if (not (listener in self.listeners)):
            self.listeners.append(listener)
            return True
        return False

    def removeListener(self,listener):
        return python_internal_ArrayImpl.remove(self.listeners,listener)

    def getListeners(self):
        return self.listeners

    def dispatchToAll(self,func):
        _g = 0
        _g1 = self.listeners
        while (_g < len(_g1)):
            def _hx_local_1():
                nonlocal _g
                _hx_local_0 = _g
                _g = (_g + 1)
                return _hx_local_0
            l = python_internal_ArrayImpl._get(_g1, _hx_local_1())
            self.dispatchToOne(l,func)

    def dispatchToOne(self,listener,func):
        def _hx_local_0():
            try:
                func(listener)
            except BaseException as _g:
                _g1 = haxe_Exception.caught(_g)
                if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.actionLogger.isErrorEnabled():
                    com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.actionLogger.error((("Uncaught exception" + "\n") + HxOverrides.stringOrNull(_g1.details())))
        com_lightstreamer_internal__Threads_Threads_Fields_.userThread.loop.call_soon_threadsafe(_hx_local_0)

com_lightstreamer_internal_EventDispatcher._hx_class = com_lightstreamer_internal_EventDispatcher


class com_lightstreamer_client_ClientEventDispatcher(com_lightstreamer_internal_EventDispatcher):
    _hx_class_name = "com.lightstreamer.client.ClientEventDispatcher"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["removeListenerAndFireOnListenEnd", "addListenerAndFireOnListenStart", "onServerError", "onStatusChange", "onPropertyChange"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = com_lightstreamer_internal_EventDispatcher


    def __init__(self):
        super().__init__()

    def removeListenerAndFireOnListenEnd(self,listener):
        if self.removeListener(listener):
            def _hx_local_0(l):
                if (l.onListenEnd is not None):
                    l.onListenEnd()
            self.dispatchToOne(listener,_hx_local_0)

    def addListenerAndFireOnListenStart(self,listener):
        if self.addListener(listener):
            def _hx_local_0(l):
                if (l.onListenStart is not None):
                    l.onListenStart()
            self.dispatchToOne(listener,_hx_local_0)

    def onServerError(self,errorCode,errorMessage):
        def _hx_local_0(listener):
            if (listener.onServerError is not None):
                listener.onServerError(errorCode,errorMessage)
        self.dispatchToAll(_hx_local_0)

    def onStatusChange(self,status):
        def _hx_local_0(listener):
            if (listener.onStatusChange is not None):
                listener.onStatusChange(status)
        self.dispatchToAll(_hx_local_0)

    def onPropertyChange(self,property):
        def _hx_local_0(listener):
            if (listener.onPropertyChange is not None):
                listener.onPropertyChange(property)
        self.dispatchToAll(_hx_local_0)

com_lightstreamer_client_ClientEventDispatcher._hx_class = com_lightstreamer_client_ClientEventDispatcher


class com_lightstreamer_internal__Constants_Constants_Fields_:
    _hx_class_name = "com.lightstreamer.internal._Constants.Constants_Fields_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["TLCP_VERSION", "FULL_TLCP_VERSION", "LS_LIB_VERSION", "LS_CID", "LS_LIB_NAME", "LS_CREATE_REALM"]
com_lightstreamer_internal__Constants_Constants_Fields_._hx_class = com_lightstreamer_internal__Constants_Constants_Fields_


class LSLightstreamerClient:
    _hx_class_name = "LSLightstreamerClient"
    _hx_is_interface = "False"
    __slots__ = ("connectionDetails", "connectionOptions", "eventDispatcher", "machine", "lock")
    _hx_fields = ["connectionDetails", "connectionOptions", "eventDispatcher", "machine", "lock"]
    _hx_methods = ["addListener", "removeListener", "getListeners", "connect", "disconnect", "getStatus", "sendMessage", "subscribe", "unsubscribe", "getSubscriptions", "getSubscriptionWrappers"]
    _hx_statics = ["LIB_NAME", "LIB_VERSION", "setLoggerProvider", "addCookies", "getCookies", "setTrustManagerFactory"]

    def __init__(self,serverAddress,adapterSet):
        self.machine = None
        self.connectionOptions = None
        self.connectionDetails = None
        self.lock = com_lightstreamer_internal_RLock()
        self.eventDispatcher = com_lightstreamer_client_ClientEventDispatcher()
        self.connectionDetails = LSConnectionDetails(self)
        self.connectionOptions = LSConnectionOptions(self)
        self.machine = com_lightstreamer_client_internal_ClientMachine(self,com_lightstreamer_internal_Factory(self))
        if (serverAddress is not None):
            self.connectionDetails.setServerAddress(serverAddress)
        if (adapterSet is not None):
            self.connectionDetails.setAdapterSet(adapterSet)

    def addListener(self,listener):
        _gthis = self
        def _hx_local_0():
            _gthis.eventDispatcher.addListenerAndFireOnListenStart(listener)
        self.lock.synchronized(_hx_local_0)

    def removeListener(self,listener):
        _gthis = self
        def _hx_local_0():
            _gthis.eventDispatcher.removeListenerAndFireOnListenEnd(listener)
        self.lock.synchronized(_hx_local_0)

    def getListeners(self):
        _gthis = self
        def _hx_local_1():
            def _hx_local_0():
                return list(_gthis.eventDispatcher.getListeners())
            return self.lock.synchronized(_hx_local_0)
        return _hx_local_1()

    def connect(self):
        _gthis = self
        def _hx_local_0():
            _gthis.machine.connect()
        self.lock.synchronized(_hx_local_0)

    def disconnect(self):
        _gthis = self
        def _hx_local_0():
            _gthis.machine.disconnect()
        self.lock.synchronized(_hx_local_0)

    def getStatus(self):
        _gthis = self
        def _hx_local_1():
            def _hx_local_0():
                return _gthis.machine.getStatus()
            return self.lock.synchronized(_hx_local_0)
        return _hx_local_1()

    def sendMessage(self,message,sequence = None,delayTimeout = None,listener = None,enqueueWhileDisconnected = None):
        if (delayTimeout is None):
            delayTimeout = -1
        if (enqueueWhileDisconnected is None):
            enqueueWhileDisconnected = False
        _gthis = self
        def _hx_local_0():
            _gthis.machine.sendMessage(message,sequence,(delayTimeout if ((delayTimeout is not None)) else -1),listener,((enqueueWhileDisconnected is not None) and enqueueWhileDisconnected))
        self.lock.synchronized(_hx_local_0)

    def subscribe(self,subscription):
        _gthis = self
        def _hx_local_0():
            _gthis.machine.subscribeExt(subscription)
        self.lock.synchronized(_hx_local_0)

    def unsubscribe(self,subscription):
        _gthis = self
        def _hx_local_0():
            _gthis.machine.unsubscribe(subscription)
        self.lock.synchronized(_hx_local_0)

    def getSubscriptions(self):
        _gthis = self
        def _hx_local_1():
            def _hx_local_0():
                return list(_gthis.machine.getSubscriptions())
            return self.lock.synchronized(_hx_local_0)
        return _hx_local_1()

    def getSubscriptionWrappers(self):
        _gthis = self
        def _hx_local_2():
            def _hx_local_1():
                _g = []
                _g1 = 0
                _g2 = _gthis.machine.getSubscriptions()
                while (_g1 < len(_g2)):
                    sub = (_g2[_g1] if _g1 >= 0 and _g1 < len(_g2) else None)
                    _g1 = (_g1 + 1)
                    if (sub.wrapper is not None):
                        x = sub.wrapper
                        _g.append(x)
                return list(_g)
            return self.lock.synchronized(_hx_local_1)
        return _hx_local_2()

    @staticmethod
    def setLoggerProvider(provider):
        com_lightstreamer_log_LogManager.setLoggerProvider(provider)

    @staticmethod
    def addCookies(uri,cookies):
        com_lightstreamer_internal_CookieHelper.getInstance().addCookies(uri,cookies)

    @staticmethod
    def getCookies(uri):
        return com_lightstreamer_internal_CookieHelper.getInstance().getCookies(uri)

    @staticmethod
    def setTrustManagerFactory(factory):
        com_lightstreamer_internal_Globals.instance.setTrustManagerFactory(factory)

LSLightstreamerClient._hx_class = LSLightstreamerClient


class com_lightstreamer_client__Proxy_ProxyType_Impl_:
    _hx_class_name = "com.lightstreamer.client._Proxy.ProxyType_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["HTTP", "SOCKS4", "SOCKS5", "fromString"]

    @staticmethod
    def fromString(s):
        _hx_local_0 = len(s)
        if (_hx_local_0 == 4):
            if (s == "HTTP"):
                return "HTTP"
            else:
                raise com_lightstreamer_internal_IllegalArgumentException("The given type is not valid. Use one of: HTTP, SOCKS4 or SOCKS5")
        elif (_hx_local_0 == 6):
            if (s == "SOCKS4"):
                return "SOCKS4"
            elif (s == "SOCKS5"):
                return "SOCKS5"
            else:
                raise com_lightstreamer_internal_IllegalArgumentException("The given type is not valid. Use one of: HTTP, SOCKS4 or SOCKS5")
        else:
            raise com_lightstreamer_internal_IllegalArgumentException("The given type is not valid. Use one of: HTTP, SOCKS4 or SOCKS5")
com_lightstreamer_client__Proxy_ProxyType_Impl_._hx_class = com_lightstreamer_client__Proxy_ProxyType_Impl_


class LSProxy:
    _hx_class_name = "LSProxy"
    _hx_is_interface = "False"
    __slots__ = ("type", "host", "port", "user", "password")
    _hx_fields = ["type", "host", "port", "user", "password"]
    _hx_methods = ["isEqualTo", "toString"]
    _hx_statics = ["eq"]

    def __init__(self,_hx_type,host,port,user,password):
        self.type = com_lightstreamer_client__Proxy_ProxyType_Impl_.fromString(_hx_type)
        self.host = host
        self.port = port
        self.user = user
        self.password = password

    def isEqualTo(self,proxy2):
        if (((((proxy2 is not None) and ((self.type == proxy2.type))) and ((self.host == proxy2.host))) and ((self.port == proxy2.port))) and ((self.user == proxy2.user))):
            return (self.password == proxy2.password)
        else:
            return False

    def toString(self):
        return (((((("" + Std.string(self.type)) + " ") + HxOverrides.stringOrNull((((HxOverrides.stringOrNull(self.user) + "@") if ((self.user is not None)) else "")))) + HxOverrides.stringOrNull(self.host)) + ":") + Std.string(self.port))

    @staticmethod
    def eq(a,b):
        if (a is None):
            if (b is None):
                return True
            else:
                return False
        elif (b is None):
            return False
        else:
            return a.isEqualTo(b)

LSProxy._hx_class = LSProxy

class com_lightstreamer_client__Subscription_SubscriptionState(Enum):
    __slots__ = ()
    _hx_class_name = "com.lightstreamer.client._Subscription.SubscriptionState"
    _hx_constructs = ["Inactive", "Active", "Subscribed"]
com_lightstreamer_client__Subscription_SubscriptionState.Inactive = com_lightstreamer_client__Subscription_SubscriptionState("Inactive", 0, ())
com_lightstreamer_client__Subscription_SubscriptionState.Active = com_lightstreamer_client__Subscription_SubscriptionState("Active", 1, ())
com_lightstreamer_client__Subscription_SubscriptionState.Subscribed = com_lightstreamer_client__Subscription_SubscriptionState("Subscribed", 2, ())
com_lightstreamer_client__Subscription_SubscriptionState._hx_class = com_lightstreamer_client__Subscription_SubscriptionState


class com_lightstreamer_client__Subscription_SubscriptionEventDispatcher(com_lightstreamer_internal_EventDispatcher):
    _hx_class_name = "com.lightstreamer.client._Subscription.SubscriptionEventDispatcher"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["onClearSnapshot", "onCommandSecondLevelItemLostUpdates", "onCommandSecondLevelSubscriptionError", "onEndOfSnapshot", "onItemLostUpdates", "onItemUpdate", "removeListenerAndFireOnListenEnd", "addListenerAndFireOnListenStart", "onSubscription", "onSubscriptionError", "onUnsubscription", "onRealMaxFrequency"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = com_lightstreamer_internal_EventDispatcher


    def __init__(self):
        super().__init__()

    def onClearSnapshot(self,itemName,itemPos):
        def _hx_local_0(listener):
            if (listener.onClearSnapshot is not None):
                listener.onClearSnapshot(itemName,itemPos)
        self.dispatchToAll(_hx_local_0)

    def onCommandSecondLevelItemLostUpdates(self,lostUpdates,key):
        def _hx_local_0(listener):
            if (listener.onCommandSecondLevelItemLostUpdates is not None):
                listener.onCommandSecondLevelItemLostUpdates(lostUpdates,key)
        self.dispatchToAll(_hx_local_0)

    def onCommandSecondLevelSubscriptionError(self,code,message,key):
        def _hx_local_0(listener):
            if (listener.onCommandSecondLevelSubscriptionError is not None):
                listener.onCommandSecondLevelSubscriptionError(code,message,key)
        self.dispatchToAll(_hx_local_0)

    def onEndOfSnapshot(self,itemName,itemPos):
        def _hx_local_0(listener):
            if (listener.onEndOfSnapshot is not None):
                listener.onEndOfSnapshot(itemName,itemPos)
        self.dispatchToAll(_hx_local_0)

    def onItemLostUpdates(self,itemName,itemPos,lostUpdates):
        def _hx_local_0(listener):
            if (listener.onItemLostUpdates is not None):
                listener.onItemLostUpdates(itemName,itemPos,lostUpdates)
        self.dispatchToAll(_hx_local_0)

    def onItemUpdate(self,update):
        def _hx_local_0(listener):
            if (listener.onItemUpdate is not None):
                listener.onItemUpdate(update)
        self.dispatchToAll(_hx_local_0)

    def removeListenerAndFireOnListenEnd(self,listener):
        if self.removeListener(listener):
            def _hx_local_0(l):
                if (l.onListenEnd is not None):
                    l.onListenEnd()
            self.dispatchToOne(listener,_hx_local_0)

    def addListenerAndFireOnListenStart(self,listener):
        if self.addListener(listener):
            def _hx_local_0(l):
                if (l.onListenStart is not None):
                    l.onListenStart()
            self.dispatchToOne(listener,_hx_local_0)

    def onSubscription(self):
        def _hx_local_0(listener):
            if (listener.onSubscription is not None):
                listener.onSubscription()
        self.dispatchToAll(_hx_local_0)

    def onSubscriptionError(self,code,message):
        def _hx_local_0(listener):
            if (listener.onSubscriptionError is not None):
                listener.onSubscriptionError(code,message)
        self.dispatchToAll(_hx_local_0)

    def onUnsubscription(self):
        def _hx_local_0(listener):
            if (listener.onUnsubscription is not None):
                listener.onUnsubscription()
        self.dispatchToAll(_hx_local_0)

    def onRealMaxFrequency(self,frequency):
        def _hx_local_0(listener):
            if (listener.onRealMaxFrequency is not None):
                listener.onRealMaxFrequency(frequency)
        self.dispatchToAll(_hx_local_0)

com_lightstreamer_client__Subscription_SubscriptionEventDispatcher._hx_class = com_lightstreamer_client__Subscription_SubscriptionEventDispatcher


class LSSubscription:
    _hx_class_name = "LSSubscription"
    _hx_is_interface = "False"
    __slots__ = ("eventDispatcher", "mode", "items", "fields", "group", "schema", "dataAdapter", "bufferSize", "snapshot", "requestedMaxFrequency", "selector", "dataAdapter2", "fields2", "schema2", "state", "subId", "cmdIdx", "keyIdx", "nItems", "nFields", "m_internal", "manager", "wrapper", "lock")
    _hx_fields = ["eventDispatcher", "mode", "items", "fields", "group", "schema", "dataAdapter", "bufferSize", "snapshot", "requestedMaxFrequency", "selector", "dataAdapter2", "fields2", "schema2", "state", "subId", "cmdIdx", "keyIdx", "nItems", "nFields", "m_internal", "manager", "wrapper", "lock"]
    _hx_methods = ["initSnapshot", "initItemsAndFields", "addListener", "removeListener", "getListeners", "isActive", "isSubscribed", "getDataAdapter", "setDataAdapter", "getMode", "getItems", "fetchItems", "setItems", "getItemGroup", "setItemGroup", "getFields", "fetchFields", "setFields", "getFieldSchema", "setFieldSchema", "getRequestedBufferSize", "setRequestedBufferSize", "getRequestedSnapshot", "setRequestedSnapshot", "getRequestedMaxFrequency", "setRequestedMaxFrequency", "getSelector", "setSelector", "getCommandPosition", "getKeyPosition", "getCommandSecondLevelDataAdapter", "setCommandSecondLevelDataAdapter", "getCommandSecondLevelFields", "setCommandSecondLevelFields", "getCommandSecondLevelFieldSchema", "setCommandSecondLevelFieldSchema", "getValue", "getCommandValue", "getValuePosPos", "getValuePosName", "getValueNamePos", "getValueNameName", "getCommandValuePosPos", "getCommandValuePosName", "getCommandValueNamePos", "getCommandValueNameName", "getItemPos", "getFieldPos", "checkActive", "checkCommand", "fetch_items", "fetch_fields", "fetch_fields2", "fetch_mode", "fetch_requestedBufferSize", "fetch_requestedSnapshot", "fetch_requestedMaxFrequency", "fetch_nItems", "fetch_subManager", "setActive", "setInactive", "setSubscribed", "setSubscribedCMD", "fetch_nFields", "isInternal", "setInternal", "getItemName", "relate", "unrelate", "hasSnapshot", "getItemNameOrPos", "fireOnSubscription", "fireOnUnsubscription", "fireOnSubscriptionError", "fireOnEndOfSnapshot", "fireOnClearSnapshot", "fireOnLostUpdates", "fireOnItemUpdate", "fireOnRealMaxFrequency", "fireOnSubscriptionError2Level", "fireOnLostUpdates2Level", "toString"]

    def __init__(self,mode,items,fields,wrapper = None):
        self.manager = None
        self.nFields = None
        self.nItems = None
        self.keyIdx = None
        self.cmdIdx = None
        self.subId = None
        self.schema2 = None
        self.fields2 = None
        self.dataAdapter2 = None
        self.selector = None
        self.requestedMaxFrequency = None
        self.snapshot = None
        self.bufferSize = None
        self.dataAdapter = None
        self.schema = None
        self.group = None
        self.fields = None
        self.items = None
        self.lock = com_lightstreamer_internal_RLock()
        self.m_internal = False
        self.state = com_lightstreamer_client__Subscription_SubscriptionState.Inactive
        self.eventDispatcher = com_lightstreamer_client__Subscription_SubscriptionEventDispatcher()
        self.wrapper = wrapper
        self.mode = com_lightstreamer_internal__Types_SubscriptionMode_Impl_.fromString(mode)
        self.initSnapshot()
        self.initItemsAndFields(items,fields)

    def initSnapshot(self):
        self.snapshot = (None if ((self.mode == "RAW")) else com_lightstreamer_internal_RequestedSnapshot.SnpYes)

    def initItemsAndFields(self,items,fields):
        if (items is not None):
            if (fields is None):
                raise com_lightstreamer_internal_IllegalArgumentException("Please specify a valid field list")
            self.items = com_lightstreamer_internal__Types_Items_Impl_.fromArray(list(items))
            self.fields = com_lightstreamer_internal__Types_Fields_Impl_.fromArray(list(fields))
            if ((self.mode == "COMMAND") and (not ("key" in self.fields))):
                raise com_lightstreamer_internal_IllegalArgumentException("Field 'key' is missing")
            if ((self.mode == "COMMAND") and (not ("command" in self.fields))):
                raise com_lightstreamer_internal_IllegalArgumentException("Field 'command' is missing")
        elif (fields is not None):
            raise com_lightstreamer_internal_IllegalArgumentException("Please specify a valid item or item list")

    def addListener(self,listener):
        _gthis = self
        def _hx_local_0():
            _gthis.eventDispatcher.addListenerAndFireOnListenStart(listener)
        self.lock.synchronized(_hx_local_0)

    def removeListener(self,listener):
        _gthis = self
        def _hx_local_0():
            _gthis.eventDispatcher.removeListenerAndFireOnListenEnd(listener)
        self.lock.synchronized(_hx_local_0)

    def getListeners(self):
        _gthis = self
        def _hx_local_1():
            def _hx_local_0():
                return list(_gthis.eventDispatcher.getListeners())
            return self.lock.synchronized(_hx_local_0)
        return _hx_local_1()

    def isActive(self):
        _gthis = self
        def _hx_local_1():
            def _hx_local_0():
                return (_gthis.state != com_lightstreamer_client__Subscription_SubscriptionState.Inactive)
            return self.lock.synchronized(_hx_local_0)
        return _hx_local_1()

    def isSubscribed(self):
        _gthis = self
        def _hx_local_1():
            def _hx_local_0():
                return (_gthis.state == com_lightstreamer_client__Subscription_SubscriptionState.Subscribed)
            return self.lock.synchronized(_hx_local_0)
        return _hx_local_1()

    def getDataAdapter(self):
        _gthis = self
        def _hx_local_1():
            def _hx_local_0():
                return _gthis.dataAdapter
            return self.lock.synchronized(_hx_local_0)
        return _hx_local_1()

    def setDataAdapter(self,dataAdapter):
        _gthis = self
        def _hx_local_2():
            _gthis.checkActive()
            def _hx_local_1():
                def _hx_local_0():
                    _gthis.dataAdapter = com_lightstreamer_internal__Types_Name_Impl_.fromString(dataAdapter)
                    return _gthis.dataAdapter
                return _hx_local_0()
            return _hx_local_1()
        self.lock.synchronized(_hx_local_2)

    def getMode(self):
        _gthis = self
        def _hx_local_1():
            def _hx_local_0():
                return _gthis.mode
            return self.lock.synchronized(_hx_local_0)
        return _hx_local_1()

    def getItems(self):
        _gthis = self
        def _hx_local_1():
            def _hx_local_0():
                if (_gthis.items is None):
                    return None
                else:
                    return list(_gthis.items)
            return self.lock.synchronized(_hx_local_0)
        return _hx_local_1()

    def fetchItems(self):
        _gthis = self
        def _hx_local_1():
            def _hx_local_0():
                return _gthis.items
            return self.lock.synchronized(_hx_local_0)
        return _hx_local_1()

    def setItems(self,items):
        _gthis = self
        def _hx_local_2():
            _gthis.checkActive()
            tmp = (None if ((items is None)) else list(items))
            _gthis.items = com_lightstreamer_internal__Types_Items_Impl_.fromArray(tmp)
            def _hx_local_1():
                def _hx_local_0():
                    _gthis.group = None
                    return _gthis.group
                return _hx_local_0()
            return _hx_local_1()
        self.lock.synchronized(_hx_local_2)

    def getItemGroup(self):
        _gthis = self
        def _hx_local_1():
            def _hx_local_0():
                return _gthis.group
            return self.lock.synchronized(_hx_local_0)
        return _hx_local_1()

    def setItemGroup(self,group):
        _gthis = self
        def _hx_local_2():
            _gthis.checkActive()
            _gthis.group = com_lightstreamer_internal__Types_Name_Impl_.fromString(group)
            def _hx_local_1():
                def _hx_local_0():
                    _gthis.items = None
                    return _gthis.items
                return _hx_local_0()
            return _hx_local_1()
        self.lock.synchronized(_hx_local_2)

    def getFields(self):
        _gthis = self
        def _hx_local_1():
            def _hx_local_0():
                if (_gthis.fields is None):
                    return None
                else:
                    return list(_gthis.fields)
            return self.lock.synchronized(_hx_local_0)
        return _hx_local_1()

    def fetchFields(self):
        _gthis = self
        def _hx_local_1():
            def _hx_local_0():
                return _gthis.fields
            return self.lock.synchronized(_hx_local_0)
        return _hx_local_1()

    def setFields(self,fields):
        _gthis = self
        def _hx_local_2():
            _gthis.checkActive()
            newValue = com_lightstreamer_internal__Types_Fields_Impl_.fromArray((None if ((fields is None)) else list(fields)))
            if ((_gthis.mode == "COMMAND") and ((newValue is not None))):
                if (not ("command" in newValue)):
                    raise com_lightstreamer_internal_IllegalArgumentException("Field 'command' is missing")
                if (not ("key" in newValue)):
                    raise com_lightstreamer_internal_IllegalArgumentException("Field 'key' is missing")
            _gthis.fields = newValue
            def _hx_local_1():
                def _hx_local_0():
                    _gthis.schema = None
                    return _gthis.schema
                return _hx_local_0()
            return _hx_local_1()
        self.lock.synchronized(_hx_local_2)

    def getFieldSchema(self):
        _gthis = self
        def _hx_local_1():
            def _hx_local_0():
                return _gthis.schema
            return self.lock.synchronized(_hx_local_0)
        return _hx_local_1()

    def setFieldSchema(self,schema):
        _gthis = self
        def _hx_local_2():
            _gthis.checkActive()
            _gthis.schema = com_lightstreamer_internal__Types_Name_Impl_.fromString(schema)
            def _hx_local_1():
                def _hx_local_0():
                    _gthis.fields = None
                    return _gthis.fields
                return _hx_local_0()
            return _hx_local_1()
        self.lock.synchronized(_hx_local_2)

    def getRequestedBufferSize(self):
        _gthis = self
        def _hx_local_1():
            def _hx_local_0():
                return com_lightstreamer_internal_RequestedBufferSizeTools.toString(_gthis.bufferSize)
            return self.lock.synchronized(_hx_local_0)
        return _hx_local_1()

    def setRequestedBufferSize(self,size):
        _gthis = self
        def _hx_local_2():
            nonlocal size
            if (size is not None):
                size = Std.string(size)
            _gthis.checkActive()
            def _hx_local_1():
                def _hx_local_0():
                    _gthis.bufferSize = com_lightstreamer_internal_RequestedBufferSizeTools.fromString(size)
                    return _gthis.bufferSize
                return _hx_local_0()
            return _hx_local_1()
        self.lock.synchronized(_hx_local_2)

    def getRequestedSnapshot(self):
        _gthis = self
        def _hx_local_1():
            def _hx_local_0():
                return com_lightstreamer_internal_RequestedSnapshotTools.toString(_gthis.snapshot)
            return self.lock.synchronized(_hx_local_0)
        return _hx_local_1()

    def setRequestedSnapshot(self,snapshot):
        _gthis = self
        def _hx_local_2():
            nonlocal snapshot
            if (snapshot is not None):
                snapshot = Std.string(snapshot)
            _gthis.checkActive()
            newValue = com_lightstreamer_internal_RequestedSnapshotTools.fromString(snapshot)
            _g = _gthis.mode
            if ((_g == "MERGE") or ((_g == "COMMAND"))):
                if ((newValue is not None) and ((False if ((newValue is None)) else (newValue.index == 2)))):
                    raise com_lightstreamer_internal_IllegalArgumentException("Snapshot length is not permitted if MERGE or COMMAND was specified as mode")
            elif (_g == "RAW"):
                if (newValue is not None):
                    raise com_lightstreamer_internal_IllegalArgumentException("Snapshot is not permitted if RAW was specified as mode")
            else:
                pass
            def _hx_local_1():
                def _hx_local_0():
                    _gthis.snapshot = newValue
                    return _gthis.snapshot
                return _hx_local_0()
            return _hx_local_1()
        self.lock.synchronized(_hx_local_2)

    def getRequestedMaxFrequency(self):
        _gthis = self
        def _hx_local_1():
            def _hx_local_0():
                return com_lightstreamer_internal_RequestedMaxFrequencyTools.toString(_gthis.requestedMaxFrequency)
            return self.lock.synchronized(_hx_local_0)
        return _hx_local_1()

    def setRequestedMaxFrequency(self,freq):
        _gthis = self
        if (freq is not None):
            freq = Std.string(freq)
        _manager = None
        def _hx_local_0():
            nonlocal _manager
            newValue = com_lightstreamer_internal_RequestedMaxFrequencyTools.fromString(freq)
            _g = _gthis.mode
            if (((_g == "MERGE") or ((_g == "DISTINCT"))) or ((_g == "COMMAND"))):
                pass
            else:
                raise com_lightstreamer_internal_IllegalArgumentException("The operation in only available on MERGE, DISTINCT and COMMAND Subscripitons")
            if (_gthis.isActive() and ((((newValue is None) or ((newValue == com_lightstreamer_internal_RequestedMaxFrequency.FreqUnfiltered))) or ((_gthis.requestedMaxFrequency == com_lightstreamer_internal_RequestedMaxFrequency.FreqUnfiltered))))):
                raise com_lightstreamer_internal_IllegalArgumentException("Cannot change the frequency from/to 'unfiltered' or to null while the Subscription is active")
            if (_gthis.subId is not None):
                if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.subscriptionLogger.isInfoEnabled():
                    com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.subscriptionLogger.info(((("Subscription " + Std.string(_gthis.subId)) + " requested max frequency changed: ") + ("null" if freq is None else freq)))
            _gthis.requestedMaxFrequency = newValue
            _manager = _gthis.manager
            return _manager
        self.lock.synchronized(_hx_local_0)
        if (_manager is not None):
            _manager.evtExtConfigure()

    def getSelector(self):
        _gthis = self
        def _hx_local_1():
            def _hx_local_0():
                return _gthis.selector
            return self.lock.synchronized(_hx_local_0)
        return _hx_local_1()

    def setSelector(self,selector):
        _gthis = self
        def _hx_local_2():
            _gthis.checkActive()
            def _hx_local_1():
                def _hx_local_0():
                    _gthis.selector = com_lightstreamer_internal__Types_Name_Impl_.fromString(selector)
                    return _gthis.selector
                return _hx_local_0()
            return _hx_local_1()
        self.lock.synchronized(_hx_local_2)

    def getCommandPosition(self):
        _gthis = self
        def _hx_local_1():
            def _hx_local_0():
                _gthis.checkCommand()
                if (_gthis.cmdIdx is None):
                    raise com_lightstreamer_internal_IllegalStateException("The position of the command field is currently unknown")
                return _gthis.cmdIdx
            return self.lock.synchronized(_hx_local_0)
        return _hx_local_1()

    def getKeyPosition(self):
        _gthis = self
        def _hx_local_1():
            def _hx_local_0():
                _gthis.checkCommand()
                if (_gthis.keyIdx is None):
                    raise com_lightstreamer_internal_IllegalStateException("The position of the key field is currently unknown")
                return _gthis.keyIdx
            return self.lock.synchronized(_hx_local_0)
        return _hx_local_1()

    def getCommandSecondLevelDataAdapter(self):
        _gthis = self
        def _hx_local_1():
            def _hx_local_0():
                return _gthis.dataAdapter2
            return self.lock.synchronized(_hx_local_0)
        return _hx_local_1()

    def setCommandSecondLevelDataAdapter(self,dataAdapter):
        _gthis = self
        def _hx_local_2():
            _gthis.checkActive()
            _gthis.checkCommand()
            def _hx_local_1():
                def _hx_local_0():
                    _gthis.dataAdapter2 = com_lightstreamer_internal__Types_Name_Impl_.fromString(dataAdapter)
                    return _gthis.dataAdapter2
                return _hx_local_0()
            return _hx_local_1()
        self.lock.synchronized(_hx_local_2)

    def getCommandSecondLevelFields(self):
        _gthis = self
        def _hx_local_1():
            def _hx_local_0():
                if (_gthis.fields2 is None):
                    return None
                else:
                    return list(_gthis.fields2)
            return self.lock.synchronized(_hx_local_0)
        return _hx_local_1()

    def setCommandSecondLevelFields(self,fields):
        _gthis = self
        def _hx_local_2():
            _gthis.checkActive()
            _gthis.checkCommand()
            newValue = com_lightstreamer_internal__Types_Fields_Impl_.fromArray((None if ((fields is None)) else list(fields)))
            _gthis.fields2 = newValue
            def _hx_local_1():
                def _hx_local_0():
                    _gthis.schema2 = None
                    return _gthis.schema2
                return _hx_local_0()
            return _hx_local_1()
        self.lock.synchronized(_hx_local_2)

    def getCommandSecondLevelFieldSchema(self):
        _gthis = self
        def _hx_local_1():
            def _hx_local_0():
                return _gthis.schema2
            return self.lock.synchronized(_hx_local_0)
        return _hx_local_1()

    def setCommandSecondLevelFieldSchema(self,schema):
        _gthis = self
        def _hx_local_2():
            _gthis.checkActive()
            _gthis.checkCommand()
            _gthis.schema2 = com_lightstreamer_internal__Types_Name_Impl_.fromString(schema)
            def _hx_local_1():
                def _hx_local_0():
                    _gthis.fields2 = None
                    return _gthis.fields2
                return _hx_local_0()
            return _hx_local_1()
        self.lock.synchronized(_hx_local_2)

    def getValue(self,itemNameOrPos,fieldNameOrPos):
        isItemPos = Std.isOfType(itemNameOrPos,Int)
        isItemName = Std.isOfType(itemNameOrPos,str)
        isFieldPos = Std.isOfType(fieldNameOrPos,Int)
        isFieldName = Std.isOfType(fieldNameOrPos,str)
        if (isItemPos and isFieldPos):
            return self.getValuePosPos(itemNameOrPos,fieldNameOrPos)
        elif (isItemPos and isFieldName):
            return self.getValuePosName(itemNameOrPos,fieldNameOrPos)
        elif (isItemName and isFieldPos):
            return self.getValueNamePos(itemNameOrPos,fieldNameOrPos)
        elif (isItemName and isFieldName):
            return self.getValueNameName(itemNameOrPos,fieldNameOrPos)
        else:
            raise com_lightstreamer_internal_IllegalArgumentException("Invalid argument type")

    def getCommandValue(self,itemNameOrPos,keyValue,fieldNameOrPos):
        isItemPos = Std.isOfType(itemNameOrPos,Int)
        isItemName = Std.isOfType(itemNameOrPos,str)
        isFieldPos = Std.isOfType(fieldNameOrPos,Int)
        isFieldName = Std.isOfType(fieldNameOrPos,str)
        if (isItemPos and isFieldPos):
            return self.getCommandValuePosPos(itemNameOrPos,keyValue,fieldNameOrPos)
        elif (isItemPos and isFieldName):
            return self.getCommandValuePosName(itemNameOrPos,keyValue,fieldNameOrPos)
        elif (isItemName and isFieldPos):
            return self.getCommandValueNamePos(itemNameOrPos,keyValue,fieldNameOrPos)
        elif (isItemName and isFieldName):
            return self.getCommandValueNameName(itemNameOrPos,keyValue,fieldNameOrPos)
        else:
            raise com_lightstreamer_internal_IllegalArgumentException("Invalid argument type")

    def getValuePosPos(self,itemPos,fieldPos):
        _gthis = self
        if ((itemPos < 1) or ((fieldPos < 1))):
            raise com_lightstreamer_internal_IllegalArgumentException("The specified position is out of bounds")
        _manager = None
        def _hx_local_0():
            nonlocal _manager
            _manager = _gthis.manager
            return _manager
        self.lock.synchronized(_hx_local_0)
        if (_manager is not None):
            return _manager.getValue(itemPos,fieldPos)
        else:
            return None

    def getValuePosName(self,itemPos,fieldName):
        _gthis = self
        def _hx_local_1():
            def _hx_local_0():
                return _gthis.getFieldPos(fieldName)
            return self.getValuePosPos(itemPos,self.lock.synchronized(_hx_local_0))
        return _hx_local_1()

    def getValueNamePos(self,itemName,fieldPos):
        _gthis = self
        def _hx_local_1():
            def _hx_local_0():
                return _gthis.getItemPos(itemName)
            return self.getValuePosPos(self.lock.synchronized(_hx_local_0),fieldPos)
        return _hx_local_1()

    def getValueNameName(self,itemName,fieldName):
        _gthis = self
        def _hx_local_2():
            def _hx_local_0():
                return _gthis.getItemPos(itemName)
            def _hx_local_1():
                return _gthis.getFieldPos(fieldName)
            return self.getValuePosPos(self.lock.synchronized(_hx_local_0),self.lock.synchronized(_hx_local_1))
        return _hx_local_2()

    def getCommandValuePosPos(self,itemPos,keyValue,fieldPos):
        _gthis = self
        self.checkCommand()
        if ((itemPos < 1) or ((fieldPos < 1))):
            raise com_lightstreamer_internal_IllegalArgumentException("The specified position is out of bounds")
        _manager = None
        def _hx_local_0():
            nonlocal _manager
            _manager = _gthis.manager
            return _manager
        self.lock.synchronized(_hx_local_0)
        if (_manager is not None):
            return _manager.getCommandValue(itemPos,keyValue,fieldPos)
        else:
            return None

    def getCommandValuePosName(self,itemPos,keyValue,fieldName):
        _gthis = self
        def _hx_local_1():
            def _hx_local_0():
                return _gthis.getFieldPos(fieldName)
            return self.getCommandValuePosPos(itemPos,keyValue,self.lock.synchronized(_hx_local_0))
        return _hx_local_1()

    def getCommandValueNamePos(self,itemName,keyValue,fieldPos):
        _gthis = self
        def _hx_local_1():
            def _hx_local_0():
                return _gthis.getItemPos(itemName)
            return self.getCommandValuePosPos(self.lock.synchronized(_hx_local_0),keyValue,fieldPos)
        return _hx_local_1()

    def getCommandValueNameName(self,itemName,keyValue,fieldName):
        _gthis = self
        def _hx_local_2():
            def _hx_local_0():
                return _gthis.getItemPos(itemName)
            def _hx_local_1():
                return _gthis.getFieldPos(fieldName)
            return self.getCommandValuePosPos(self.lock.synchronized(_hx_local_0),keyValue,self.lock.synchronized(_hx_local_1))
        return _hx_local_2()

    def getItemPos(self,itemName):
        itemPos = None
        tmp = None
        if (self.items is not None):
            itemPos = com_lightstreamer_internal__Types_Items_Impl_.getPos(self.items,itemName)
            tmp = (itemPos == -1)
        else:
            tmp = True
        if tmp:
            raise com_lightstreamer_internal_IllegalArgumentException("Unknown item name")
        return itemPos

    def getFieldPos(self,fieldName):
        fieldPos = None
        tmp = None
        if (self.fields is not None):
            fieldPos = com_lightstreamer_internal__Types_Fields_Impl_.getPos(self.fields,fieldName)
            tmp = (fieldPos == -1)
        else:
            tmp = True
        if tmp:
            raise com_lightstreamer_internal_IllegalArgumentException("Unknown field name")
        return fieldPos

    def checkActive(self):
        if self.isActive():
            raise com_lightstreamer_internal_IllegalStateException("Cannot modify an active Subscription. Please unsubscribe before applying any change")

    def checkCommand(self):
        if (self.mode != "COMMAND"):
            raise com_lightstreamer_internal_IllegalStateException("This method can only be used on COMMAND subscriptions")

    def fetch_items(self):
        _gthis = self
        def _hx_local_1():
            def _hx_local_0():
                return _gthis.items
            return self.lock.synchronized(_hx_local_0)
        return _hx_local_1()

    def fetch_fields(self):
        _gthis = self
        def _hx_local_1():
            def _hx_local_0():
                return _gthis.fields
            return self.lock.synchronized(_hx_local_0)
        return _hx_local_1()

    def fetch_fields2(self):
        _gthis = self
        def _hx_local_1():
            def _hx_local_0():
                return _gthis.fields2
            return self.lock.synchronized(_hx_local_0)
        return _hx_local_1()

    def fetch_mode(self):
        _gthis = self
        def _hx_local_1():
            def _hx_local_0():
                return _gthis.mode
            return self.lock.synchronized(_hx_local_0)
        return _hx_local_1()

    def fetch_requestedBufferSize(self):
        _gthis = self
        def _hx_local_1():
            def _hx_local_0():
                return _gthis.bufferSize
            return self.lock.synchronized(_hx_local_0)
        return _hx_local_1()

    def fetch_requestedSnapshot(self):
        _gthis = self
        def _hx_local_1():
            def _hx_local_0():
                return _gthis.snapshot
            return self.lock.synchronized(_hx_local_0)
        return _hx_local_1()

    def fetch_requestedMaxFrequency(self):
        _gthis = self
        def _hx_local_1():
            def _hx_local_0():
                return _gthis.requestedMaxFrequency
            return self.lock.synchronized(_hx_local_0)
        return _hx_local_1()

    def fetch_nItems(self):
        _gthis = self
        def _hx_local_1():
            def _hx_local_0():
                return _gthis.nItems
            return self.lock.synchronized(_hx_local_0)
        return _hx_local_1()

    def fetch_subManager(self):
        _gthis = self
        def _hx_local_1():
            def _hx_local_0():
                return _gthis.manager
            return self.lock.synchronized(_hx_local_0)
        return _hx_local_1()

    def setActive(self):
        _gthis = self
        def _hx_local_2():
            def _hx_local_1():
                def _hx_local_0():
                    _gthis.state = com_lightstreamer_client__Subscription_SubscriptionState.Active
                    return _gthis.state
                return _hx_local_0()
            return _hx_local_1()
        self.lock.synchronized(_hx_local_2)

    def setInactive(self):
        _gthis = self
        def _hx_local_2():
            _gthis.state = com_lightstreamer_client__Subscription_SubscriptionState.Inactive
            _gthis.subId = None
            _gthis.cmdIdx = None
            _gthis.keyIdx = None
            _gthis.nItems = None
            def _hx_local_1():
                def _hx_local_0():
                    _gthis.nFields = None
                    return _gthis.nFields
                return _hx_local_0()
            return _hx_local_1()
        self.lock.synchronized(_hx_local_2)

    def setSubscribed(self,subId,nItems,nFields):
        _gthis = self
        def _hx_local_2():
            _gthis.state = com_lightstreamer_client__Subscription_SubscriptionState.Subscribed
            _gthis.subId = subId
            _gthis.nItems = nItems
            def _hx_local_1():
                def _hx_local_0():
                    _gthis.nFields = nFields
                    return _gthis.nFields
                return _hx_local_0()
            return _hx_local_1()
        self.lock.synchronized(_hx_local_2)

    def setSubscribedCMD(self,subId,nItems,nFields,cmdIdx,keyIdx):
        _gthis = self
        def _hx_local_2():
            _gthis.state = com_lightstreamer_client__Subscription_SubscriptionState.Subscribed
            _gthis.subId = subId
            _gthis.cmdIdx = cmdIdx
            _gthis.keyIdx = keyIdx
            _gthis.nItems = nItems
            def _hx_local_1():
                def _hx_local_0():
                    _gthis.nFields = nFields
                    return _gthis.nFields
                return _hx_local_0()
            return _hx_local_1()
        self.lock.synchronized(_hx_local_2)

    def fetch_nFields(self):
        _gthis = self
        def _hx_local_1():
            def _hx_local_0():
                return _gthis.nFields
            return self.lock.synchronized(_hx_local_0)
        return _hx_local_1()

    def isInternal(self):
        _gthis = self
        def _hx_local_1():
            def _hx_local_0():
                return _gthis.m_internal
            return self.lock.synchronized(_hx_local_0)
        return _hx_local_1()

    def setInternal(self):
        _gthis = self
        def _hx_local_2():
            def _hx_local_1():
                def _hx_local_0():
                    _gthis.m_internal = True
                    return _gthis.m_internal
                return _hx_local_0()
            return _hx_local_1()
        self.lock.synchronized(_hx_local_2)

    def getItemName(self,itemIdx):
        _gthis = self
        def _hx_local_1():
            def _hx_local_0():
                if (_gthis.items is not None):
                    return python_internal_ArrayImpl._get(_gthis.items, (itemIdx - 1))
                return None
            return self.lock.synchronized(_hx_local_0)
        return _hx_local_1()

    def relate(self,manager):
        _gthis = self
        def _hx_local_2():
            def _hx_local_1():
                def _hx_local_0():
                    _gthis.manager = manager
                    return _gthis.manager
                return _hx_local_0()
            return _hx_local_1()
        self.lock.synchronized(_hx_local_2)

    def unrelate(self,manager):
        _gthis = self
        def _hx_local_0():
            if (_gthis.manager != manager):
                return
            _gthis.manager = None
        self.lock.synchronized(_hx_local_0)

    def hasSnapshot(self):
        _gthis = self
        def _hx_local_1():
            def _hx_local_0():
                return (not (((_gthis.snapshot is None) or ((_gthis.snapshot == com_lightstreamer_internal_RequestedSnapshot.SnpNo)))))
            return self.lock.synchronized(_hx_local_0)
        return _hx_local_1()

    def getItemNameOrPos(self,itemIdx):
        if (self.items is not None):
            return python_internal_ArrayImpl._get(self.items, (itemIdx - 1))
        else:
            return ("" + Std.string(itemIdx))

    def fireOnSubscription(self,subId):
        _gthis = self
        def _hx_local_0():
            if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.subscriptionLogger.isInfoEnabled():
                com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.subscriptionLogger.info((("Subscription " + Std.string(subId)) + " added"))
            _gthis.eventDispatcher.onSubscription()
        self.lock.synchronized(_hx_local_0)

    def fireOnUnsubscription(self,subId):
        _gthis = self
        def _hx_local_0():
            if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.subscriptionLogger.isInfoEnabled():
                com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.subscriptionLogger.info((("Subscription " + Std.string(subId)) + " deleted"))
            _gthis.eventDispatcher.onUnsubscription()
        self.lock.synchronized(_hx_local_0)

    def fireOnSubscriptionError(self,subId,code,msg):
        _gthis = self
        def _hx_local_0():
            if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.subscriptionLogger.isWarnEnabled():
                com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.subscriptionLogger.warn(((((("Subscription " + Std.string(subId)) + " failed: ") + Std.string(code)) + " - ") + ("null" if msg is None else msg)))
            _gthis.eventDispatcher.onSubscriptionError(code,msg)
        self.lock.synchronized(_hx_local_0)

    def fireOnEndOfSnapshot(self,itemIdx,subId):
        _gthis = self
        def _hx_local_0():
            if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.subscriptionLogger.isDebugEnabled():
                com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.subscriptionLogger.debug((((("Subscription " + Std.string(subId)) + ":") + HxOverrides.stringOrNull(_gthis.getItemNameOrPos(itemIdx))) + ": snapshot ended"))
            _gthis.eventDispatcher.onEndOfSnapshot(_gthis.getItemName(itemIdx),itemIdx)
        self.lock.synchronized(_hx_local_0)

    def fireOnClearSnapshot(self,itemIdx,subId):
        _gthis = self
        def _hx_local_0():
            if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.subscriptionLogger.isDebugEnabled():
                com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.subscriptionLogger.debug((((("Subscription " + Std.string(subId)) + ":") + HxOverrides.stringOrNull(_gthis.getItemNameOrPos(itemIdx))) + ": snapshot cleared"))
            _gthis.eventDispatcher.onClearSnapshot(_gthis.getItemName(itemIdx),itemIdx)
        self.lock.synchronized(_hx_local_0)

    def fireOnLostUpdates(self,itemIdx,lostUpdates,subId):
        _gthis = self
        def _hx_local_0():
            if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.subscriptionLogger.isDebugEnabled():
                com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.subscriptionLogger.debug((((((("Subscription " + Std.string(subId)) + ":") + HxOverrides.stringOrNull(_gthis.getItemNameOrPos(itemIdx))) + ": lost ") + Std.string(lostUpdates)) + " updates"))
            _gthis.eventDispatcher.onItemLostUpdates(_gthis.getItemName(itemIdx),itemIdx,lostUpdates)
        self.lock.synchronized(_hx_local_0)

    def fireOnItemUpdate(self,update,subId):
        _gthis = self
        def _hx_local_0():
            if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.subscriptionLogger.isDebugEnabled():
                com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.subscriptionLogger.debug(((((("Subscription " + Std.string(subId)) + ":") + HxOverrides.stringOrNull(_gthis.getItemNameOrPos(update.getItemPos()))) + " update: ") + Std.string(update)))
            _gthis.eventDispatcher.onItemUpdate(update)
        self.lock.synchronized(_hx_local_0)

    def fireOnRealMaxFrequency(self,freq,subId):
        _gthis = self
        def _hx_local_0():
            if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.subscriptionLogger.isDebugEnabled():
                com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.subscriptionLogger.debug(((("Subscription " + Std.string(subId)) + " real max frequency changed: ") + Std.string(freq)))
            _gthis.eventDispatcher.onRealMaxFrequency(com_lightstreamer_internal__Types_Types_Fields_.realFrequencyAsString(freq))
        self.lock.synchronized(_hx_local_0)

    def fireOnSubscriptionError2Level(self,keyName,code,msg,subId,itemIdx):
        _gthis = self
        def _hx_local_0():
            if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.subscriptionLogger.isWarnEnabled():
                com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.subscriptionLogger.warn(((((((((("Subscription " + Std.string(subId)) + ":") + HxOverrides.stringOrNull(_gthis.getItemNameOrPos(itemIdx))) + ":") + ("null" if keyName is None else keyName)) + " failed: ") + Std.string(code)) + " - ") + ("null" if msg is None else msg)))
            _gthis.eventDispatcher.onCommandSecondLevelSubscriptionError(code,msg,keyName)
        self.lock.synchronized(_hx_local_0)

    def fireOnLostUpdates2Level(self,keyName,lostUpdates,subId,itemIdx):
        _gthis = self
        def _hx_local_0():
            if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.subscriptionLogger.isDebugEnabled():
                com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.subscriptionLogger.debug((((((((("Subscription " + Std.string(subId)) + ":") + HxOverrides.stringOrNull(_gthis.getItemNameOrPos(itemIdx))) + ":") + ("null" if keyName is None else keyName)) + ": lost ") + Std.string(lostUpdates)) + " updates"))
            _gthis.eventDispatcher.onCommandSecondLevelItemLostUpdates(lostUpdates,keyName)
        self.lock.synchronized(_hx_local_0)

    def toString(self):
        _gthis = self
        def _hx_local_1():
            def _hx_local_0():
                _hx_map = com_lightstreamer_internal__InfoMap_InfoMap_Impl_._new()
                com_lightstreamer_internal__InfoMap_InfoMap_Impl_.set(_hx_map,"mode",_gthis.mode)
                com_lightstreamer_internal__InfoMap_InfoMap_Impl_.set(_hx_map,"items",(Std.string(_gthis.items) if ((_gthis.items is not None)) else _gthis.group))
                com_lightstreamer_internal__InfoMap_InfoMap_Impl_.set(_hx_map,"fields",(Std.string(_gthis.fields) if ((_gthis.fields is not None)) else _gthis.schema))
                com_lightstreamer_internal__InfoMap_InfoMap_Impl_.set(_hx_map,"dataAdapter",_gthis.dataAdapter)
                com_lightstreamer_internal__InfoMap_InfoMap_Impl_.set(_hx_map,"requestedBufferSize",_gthis.bufferSize)
                com_lightstreamer_internal__InfoMap_InfoMap_Impl_.set(_hx_map,"requestedSnapshot",_gthis.snapshot)
                com_lightstreamer_internal__InfoMap_InfoMap_Impl_.set(_hx_map,"requestedMaxFrequency",_gthis.requestedMaxFrequency)
                com_lightstreamer_internal__InfoMap_InfoMap_Impl_.set(_hx_map,"selector",_gthis.selector)
                com_lightstreamer_internal__InfoMap_InfoMap_Impl_.set(_hx_map,"secondLevelFields",(Std.string(_gthis.fields2) if ((_gthis.fields2 is not None)) else _gthis.schema2))
                com_lightstreamer_internal__InfoMap_InfoMap_Impl_.set(_hx_map,"secondLevelDataAdapter",_gthis.dataAdapter2)
                return _hx_map.toString()
            return self.lock.synchronized(_hx_local_0)
        return _hx_local_1()

LSSubscription._hx_class = LSSubscription


class com_lightstreamer_internal_IPageLifecycle:
    _hx_class_name = "com.lightstreamer.internal.IPageLifecycle"
    _hx_is_interface = "True"
    __slots__ = ("frozen",)
    _hx_fields = ["frozen"]
    _hx_methods = ["startListening", "stopListening"]
com_lightstreamer_internal_IPageLifecycle._hx_class = com_lightstreamer_internal_IPageLifecycle


class com_lightstreamer_internal_PageLifecycle:
    _hx_class_name = "com.lightstreamer.internal.PageLifecycle"
    _hx_is_interface = "False"
    __slots__ = ("frozen",)
    _hx_fields = ["frozen"]
    _hx_methods = ["startListening", "stopListening"]
    _hx_statics = ["newLoggingInstance"]
    _hx_interfaces = [com_lightstreamer_internal_IPageLifecycle]

    def __init__(self,onEvent):
        self.frozen = False

    def startListening(self):
        pass

    def stopListening(self):
        pass

    @staticmethod
    def newLoggingInstance():
        def _hx_local_1():
            def _hx_local_0(_):
                pass
            return com_lightstreamer_internal_PageLifecycle(_hx_local_0)
        return _hx_local_1()

com_lightstreamer_internal_PageLifecycle._hx_class = com_lightstreamer_internal_PageLifecycle


class com_lightstreamer_client_internal_ClientMachine:
    _hx_class_name = "com.lightstreamer.client.internal.ClientMachine"
    _hx_is_interface = "False"
    __slots__ = ("client", "details", "options", "lock", "clientEventDispatcher", "state", "wsFactory", "httpFactory", "ctrlFactory", "timerFactory", "randomGenerator", "delayCounter", "m_status", "m_nextReqId", "m_nextSubId", "defaultServerAddress", "requestLimit", "keepaliveInterval", "idleTimeout", "sessionId", "serverInstanceAddress", "lastKnownClientIp", "cause", "connectTs", "recoverTs", "ctrl_connectTs", "suspendedTransports", "disabledTransports", "sequenceMap", "messageManagers", "subscriptionManagers", "switchRequest", "constrainRequest", "swt_lastReqId", "rhb_grantedInterval", "rhb_currentInterval", "bw_requestedMaxBandwidth", "bw_lastReqId", "reachabilityFactory", "nr_reachabilityManager", "frz_pageLifecycleFactory", "frz_pageLifecycle", "rec_serverProg", "rec_clientProg", "slw_refTime", "slw_avgDelayMs", "slw_maxAvgDelayMs", "slw_hugeDelayMs", "slw_m", "ws", "http", "ctrl_http", "transportTimer", "retryTimer", "keepaliveTimer", "stalledTimer", "reconnectTimer", "rhbTimer", "recoveryTimer", "idleTimer", "pollingTimer", "ctrlTimer")
    _hx_fields = ["client", "details", "options", "lock", "clientEventDispatcher", "state", "wsFactory", "httpFactory", "ctrlFactory", "timerFactory", "randomGenerator", "delayCounter", "m_status", "m_nextReqId", "m_nextSubId", "defaultServerAddress", "requestLimit", "keepaliveInterval", "idleTimeout", "sessionId", "serverInstanceAddress", "lastKnownClientIp", "cause", "connectTs", "recoverTs", "ctrl_connectTs", "suspendedTransports", "disabledTransports", "sequenceMap", "messageManagers", "subscriptionManagers", "switchRequest", "constrainRequest", "swt_lastReqId", "rhb_grantedInterval", "rhb_currentInterval", "bw_requestedMaxBandwidth", "bw_lastReqId", "reachabilityFactory", "nr_reachabilityManager", "frz_pageLifecycleFactory", "frz_pageLifecycle", "rec_serverProg", "rec_clientProg", "slw_refTime", "slw_avgDelayMs", "slw_maxAvgDelayMs", "slw_hugeDelayMs", "slw_m", "ws", "http", "ctrl_http", "transportTimer", "retryTimer", "keepaliveTimer", "stalledTimer", "reconnectTimer", "rhbTimer", "recoveryTimer", "idleTimer", "pollingTimer", "ctrlTimer"]
    _hx_methods = ["disposeSession", "disposeClient", "evtExtConnect", "evtExtConnect_NextRegion", "evtExtConnect_NetworkReachabilityRegion", "doInstallPageLifecycle", "doUnistallPageLifecycle", "evtPageFrozen", "evtPageResumed", "evtNetworkNotReachable", "evtNetworkReachable", "evtOnlineAgain", "evtServerAddressChanged", "evtExtDisconnect", "evtSelectCreate", "evtWSOpen", "evtMessage", "evtCtrlMessage", "evtTransportTimeout", "evtTransportError", "evtIdleTimeout", "evtPollingTimeout", "evtKeepaliveTimeout", "evtStalledTimeout", "evtReconnectTimeout", "evtRestartKeepalive", "evtWSOK", "evtCONERR", "evtEND", "evtERROR", "evtREQOK_withoutReqId", "evtREQOK", "evtREQOK_Forward", "evtREQOK_TransportRegion", "evtREQERR", "evtREQERR_Forward", "evtREQERR_TransportRegion", "evtPROG", "evtLOOP", "evtCONOK", "evtSERVNAME", "evtCLIENTIP", "evtCONS", "evtPROBE", "evtNOOP", "evtSYNC", "evtSYNC_PushingRegion", "evtMSGDONE", "evtMSGFAIL", "evtU", "evtSUBOK", "evtSUBCMD", "evtUNSUB", "evtEOS", "evtCS", "evtOV", "evtCONF", "evtCheckAvg", "evtSendPendingControls", "evtSendPendingMessages", "evtSelectRhb", "evtExtSetReverseHeartbeatInterval", "evtRestartHeartbeat", "evtRhbTimeout", "evtDisposeCtrl", "evtStartRecovery", "evtRecoveryTimeout", "evtCheckRecoveryTimeout", "evtCreate", "evtCheckTransport", "evtCheckBW", "evtCheckCtrlRequests", "evtCtrlDone", "evtCtrlError", "evtCtrlTimeout", "evtSendControl", "evtSendHeartbeat", "evtStartSession", "evtEndSession", "evtRetry", "evtRetry_NextRegion", "evtTerminate", "evtTerminate_NextRegion", "evtTerminate_NetworkReachabilityRegion", "evtRetryTimeout", "evtExtSetForcedTransport", "evtExtSetRequestedMaxBandwidth", "evtForceSlowing", "evtForcePolling", "evtSendMessage", "evtSwitchTransport", "evtSwitchTransport_forwardToTransportRegion", "onFreshData", "onStaleData", "isFreshData", "openWS", "openWS_Create", "openWS_Bind", "sendCreateWS", "sendBindWS_Streaming", "sendBindWS_FirstPolling", "sendBindWS_Polling", "sendDestroyWS", "sendHttpRequest", "sendCreateHTTP", "sendBindHTTP_Streaming", "sendBindHTTP_Polling", "sendCreateTTL", "sendRecovery", "disposeWS", "closeWS", "suspendWS_Streaming", "disableWS", "disableHTTP_Streaming", "disableStreaming", "enableAllTransports", "disposeHTTP", "closeHTTP", "disposeCtrl", "closeCtrl", "notifyStatus", "getBestForCreating", "getBestForBinding", "resetCurrentRetryDelay", "notifyServerErrorIfCauseIsError", "notifyServerError_CONERR", "notifyServerError_END", "notifyServerError_ERROR", "notifyServerError_REQERR", "doCONOK", "doCONOK_CreateWS", "doCONOK_BindWS_Streaming", "doCONOK_BindWS_Polling", "doCONOK_CreateHTTP", "doCONOK_BindHTTP_Streaming", "doCONOK_BindHTTP_Polling", "doSERVNAME", "doCLIENTIP", "doCONS", "doLOOP", "doPROG", "doMSGDONE", "doMSGFAIL", "doU", "doSUBOK", "doSUBCMD", "doUNSUB", "doEOS", "doCS", "doOV", "doCONF", "doREQOK", "doREQERR", "doSYNC", "doSYNC_G", "doSYNC_NG", "diffTimeSync", "slowAvg", "schedule_evtTransportTimeout", "schedule_evtRetryTimeout", "schedule_evtRecoveryTimeout", "schedule_evtIdleTimeout", "schedule_evtPollingTimeout", "schedule_evtCtrlTimeout", "schedule_evtKeepaliveTimeout", "schedule_evtStalledTimeout", "schedule_evtReconnectTimeout", "schedule_evtRhbTimeout", "createTimer", "cancel_evtTransportTimeout", "cancel_evtRetryTimeout", "cancel_evtKeepaliveTimeout", "cancel_evtStalledTimeout", "cancel_evtReconnectTimeout", "cancel_evtRhbTimeout", "cancel_evtIdleTimeout", "cancel_evtPollingTimeout", "cancel_evtCtrlTimeout", "cancel_evtRecoveryTimeout", "waitingInterval", "exit_tr", "entry_m111", "entry_m112", "entry_m113", "entry_m115", "entry_rec", "exit_w", "exit_ws", "exit_wp", "exit_hs", "exit_hp", "exit_ctrl", "exit_rec", "exit_keepalive_unit", "exit_w_to_m", "exit_ws_to_m", "exit_wp_to_m", "exit_hs_to_m", "exit_hs_to_rec", "exit_hp_to_m", "exit_hp_to_rec", "exit_ctrl_to_m", "exit_rec_to_m", "randomPause", "generateFreshReqId", "generateFreshSubId", "genAbortSubscriptions", "genAckMessagesWS", "genAbortMessages", "resetSequenceMap", "isSwitching", "encodeSwitch", "encodeConstrain", "getPendingControls", "sendControlWS", "sendMsgWS", "sendPengingControlsWS", "sendPendingMessagesWS", "sendBatchWS", "sendHeartbeatWS", "sendPendingControlsHTTP", "sendPendingMessagesHTTP", "sendHeartbeatHTTP", "sendBatchHTTP", "prepareBatchWS", "prepareBatchHTTP", "getHeadersForRequestOtherThanCreate", "getServerAddress", "relateSubManager", "unrelateSubManager", "isRelatedWithSubManager", "relateMsgManager", "unrelateMsgManager", "getAndSetNextMsgProg", "onPropertyChange", "traceEvent", "connect", "disconnect", "getStatus", "sendMessage", "subscribeExt", "unsubscribe", "getSubscriptions"]
    _hx_statics = ["frz_globalPageLifecycle"]

    def __init__(self,client,factory):
        self.ctrlTimer = None
        self.pollingTimer = None
        self.idleTimer = None
        self.recoveryTimer = None
        self.rhbTimer = None
        self.reconnectTimer = None
        self.stalledTimer = None
        self.keepaliveTimer = None
        self.retryTimer = None
        self.transportTimer = None
        self.ctrl_http = None
        self.http = None
        self.ws = None
        self.frz_pageLifecycle = None
        self.nr_reachabilityManager = None
        self.bw_lastReqId = None
        self.bw_requestedMaxBandwidth = None
        self.rhb_currentInterval = None
        self.rhb_grantedInterval = None
        self.swt_lastReqId = None
        self.constrainRequest = None
        self.switchRequest = None
        self.cause = None
        self.lastKnownClientIp = None
        self.serverInstanceAddress = None
        self.sessionId = None
        self.idleTimeout = None
        self.keepaliveInterval = None
        self.requestLimit = None
        self.defaultServerAddress = None
        self.slw_m = 0.5
        self.slw_hugeDelayMs = 20000
        self.slw_maxAvgDelayMs = 7000
        self.slw_avgDelayMs = 0
        self.slw_refTime = 0
        self.rec_clientProg = 0
        self.rec_serverProg = 0
        self.subscriptionManagers = com_lightstreamer_internal_OrderedIntMapImpl()
        self.messageManagers = com_lightstreamer_internal_MyArray()
        self.sequenceMap = haxe_ds_StringMap()
        self.disabledTransports = com_lightstreamer_internal_Set()
        self.suspendedTransports = com_lightstreamer_internal_Set()
        self.ctrl_connectTs = 0
        self.recoverTs = 0
        self.connectTs = 0
        self.m_nextSubId = 0
        self.m_nextReqId = 0
        self.m_status = "DISCONNECTED"
        self.delayCounter = com_lightstreamer_client_internal_RetryDelayCounter()
        self.state = com_lightstreamer_client_internal_State()
        self.client = client
        self.lock = client.lock
        self.details = client.connectionDetails
        self.options = client.connectionOptions
        self.wsFactory = factory.createWsClient
        self.httpFactory = factory.createHttpClient
        self.ctrlFactory = factory.createCtrlClient
        self.timerFactory = factory.createTimer
        self.randomGenerator = factory.randomMillis
        self.reachabilityFactory = factory.createReachabilityManager
        self.frz_pageLifecycleFactory = factory.createPageLifecycleFactory
        self.clientEventDispatcher = client.eventDispatcher
        self.switchRequest = com_lightstreamer_client_internal_SwitchRequest(self)
        self.constrainRequest = com_lightstreamer_client_internal_ConstrainRequest(self)
        self.delayCounter.reset(self.options.retryDelay)

    def disposeSession(self):
        self.disposeWS()
        self.disposeHTTP()
        self.disposeCtrl()
        self.details.setServerInstanceAddress(None)
        self.details.setSessionId(None)
        self.details.setServerSocketName(None)
        self.details.setClientIp(None)
        self.options.setRealMaxBandwidth(None)
        self.lastKnownClientIp = None
        self.resetSequenceMap()
        self.rec_serverProg = 0
        self.rec_clientProg = 0
        self.bw_lastReqId = None
        self.bw_requestedMaxBandwidth = None
        self.swt_lastReqId = None

    def disposeClient(self):
        self.sessionId = None
        self.enableAllTransports()
        self.resetCurrentRetryDelay()
        self.resetSequenceMap()
        self.cause = None

    def evtExtConnect(self):
        _gthis = self
        def _hx_local_0():
            _gthis.traceEvent("connect")
            forward = True
            if (_gthis.state.s_m == 100):
                if com_lightstreamer_client_internal_ClientMachine.frz_globalPageLifecycle.frozen:
                    if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.pageLogger.isWarnEnabled():
                        com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.pageLogger.warn("connection requested while page is frozen")
                    _gthis.cause = "page.frozen"
                    _gthis.resetCurrentRetryDelay()
                    _gthis.doInstallPageLifecycle()
                    _gthis.state.s_m = 117
                    _gthis.state.traceState()
                    forward = _gthis.evtExtConnect_NextRegion()
                    tmp = _gthis.frz_pageLifecycle
                    if (tmp is not None):
                        tmp.startListening()
                    _gthis.evtRetry(com_lightstreamer_client_internal__ClientMachine_RetryCause.page_frozen)
                else:
                    _gthis.cause = "api"
                    _gthis.resetCurrentRetryDelay()
                    _gthis.doInstallPageLifecycle()
                    _gthis.state.s_m = 101
                    _gthis.state.traceState()
                    forward = _gthis.evtExtConnect_NextRegion()
                    tmp = _gthis.frz_pageLifecycle
                    if (tmp is not None):
                        tmp.startListening()
                    _gthis.evtSelectCreate()
            if forward:
                _gthis.evtExtConnect_NextRegion()
        self.lock.synchronized(_hx_local_0)

    def evtExtConnect_NextRegion(self):
        return self.evtExtConnect_NetworkReachabilityRegion()

    def evtExtConnect_NetworkReachabilityRegion(self):
        _gthis = self
        if (self.state.s_nr == 1400):
            hostAddress = com_lightstreamer_internal_Url(self.getServerAddress()).get_hostname()
            self.nr_reachabilityManager = self.reachabilityFactory(hostAddress)
            self.state.s_nr = 1410
            self.state.traceState()
            def _hx_local_0(status):
                tmp = status.index
                if (tmp == 0):
                    _gthis.evtNetworkReachable(hostAddress)
                elif (tmp == 1):
                    _gthis.evtNetworkNotReachable(hostAddress)
                else:
                    pass
            self.nr_reachabilityManager.startListening(_hx_local_0)
        return False

    def doInstallPageLifecycle(self):
        _gthis = self
        def _hx_local_0(e):
            tmp = e.index
            if (tmp == 0):
                _gthis.evtPageFrozen()
            elif (tmp == 1):
                _gthis.evtPageResumed()
            else:
                pass
        self.frz_pageLifecycle = self.frz_pageLifecycleFactory(_hx_local_0)

    def doUnistallPageLifecycle(self):
        tmp = self.frz_pageLifecycle
        if (tmp is not None):
            tmp.stopListening()
        self.frz_pageLifecycle = None

    def evtPageFrozen(self):
        self.traceEvent("page.frozen")
        _g = self.state.s_m
        if (((((((_g == 116) or ((_g == 115))) or ((_g == 114))) or ((_g == 113))) or ((_g == 112))) or ((_g == 111))) or ((_g == 110))):
            self.notifyStatus("DISCONNECTED:WILL-RETRY")
            self.cause = "page.frozen"
            self.state.s_m = 117
            self.state.traceState()
            self.cancel_evtRetryTimeout()
        elif (((_g == 122) or ((_g == 121))) or ((_g == 120))):
            self.disposeWS()
            self.notifyStatus("DISCONNECTED:WILL-RETRY")
            self.cause = "page.frozen"
            self.state.s_m = 117
            self.state.traceState()
            self.cancel_evtTransportTimeout()
            self.evtRetry(com_lightstreamer_client_internal__ClientMachine_RetryCause.page_frozen)
        elif (_g == 130):
            self.disposeHTTP()
            self.notifyStatus("DISCONNECTED:WILL-RETRY")
            self.cause = "page.frozen"
            self.state.s_m = 117
            self.state.traceState()
            self.cancel_evtTransportTimeout()
            self.evtRetry(com_lightstreamer_client_internal__ClientMachine_RetryCause.page_frozen)
        elif (_g == 140):
            self.disposeHTTP()
            self.notifyStatus("DISCONNECTED:WILL-RETRY")
            self.cause = "page.frozen"
            self.state.s_m = 117
            self.state.traceState()
            self.cancel_evtTransportTimeout()
            self.evtRetry(com_lightstreamer_client_internal__ClientMachine_RetryCause.page_frozen)
        elif (_g == 150):
            _g = self.state.s_tr
            if (_g is not None):
                if (_g == 210):
                    self.sendDestroyWS("page.frozen")
                    self.closeWS()
                    self.notifyStatus("DISCONNECTED:WILL-RETRY")
                    self.cause = "page.frozen"
                    self.state.clear_w()
                    self.state.goto_m_from_session(117)
                    self.exit_w()
                    self.evtEndSession()
                    self.evtRetry(com_lightstreamer_client_internal__ClientMachine_RetryCause.page_frozen)
                elif (_g == 220):
                    self.disposeHTTP()
                    self.notifyStatus("DISCONNECTED:WILL-RETRY")
                    self.cause = "page.frozen"
                    self.state.goto_m_from_session(117)
                    self.cancel_evtTransportTimeout()
                    self.evtEndSession()
                    self.evtRetry(com_lightstreamer_client_internal__ClientMachine_RetryCause.page_frozen)
                elif (_g == 230):
                    self.disposeHTTP()
                    self.notifyStatus("DISCONNECTED:WILL-RETRY")
                    self.cause = "page.frozen"
                    self.state.goto_m_from_session(117)
                    self.cancel_evtTransportTimeout()
                    self.evtEndSession()
                    self.evtRetry(com_lightstreamer_client_internal__ClientMachine_RetryCause.page_frozen)
                elif (_g == 240):
                    tmp = self.state.s_ws
                    if (((tmp.m if ((tmp is not None)) else None)) == 500):
                        self.disposeWS()
                        self.notifyStatus("DISCONNECTED:WILL-RETRY")
                        self.cause = "page.frozen"
                        self.state.goto_m_from_ws(117)
                        self.exit_ws_to_m()
                        self.evtRetry(com_lightstreamer_client_internal__ClientMachine_RetryCause.page_frozen)
                    else:
                        tmp = None
                        tmp1 = None
                        tmp2 = self.state.s_ws
                        if (((tmp2.m if ((tmp2 is not None)) else None)) != 501):
                            tmp2 = self.state.s_ws
                            tmp1 = (((tmp2.m if ((tmp2 is not None)) else None)) == 502)
                        else:
                            tmp1 = True
                        if (not tmp1):
                            tmp1 = self.state.s_ws
                            tmp = (((tmp1.m if ((tmp1 is not None)) else None)) == 503)
                        else:
                            tmp = True
                        if tmp:
                            self.sendDestroyWS("page.frozen")
                            self.closeWS()
                            self.notifyStatus("DISCONNECTED:WILL-RETRY")
                            self.cause = "page.frozen"
                            self.state.goto_m_from_ws(117)
                            self.exit_ws_to_m()
                            self.evtRetry(com_lightstreamer_client_internal__ClientMachine_RetryCause.page_frozen)
                elif (_g == 250):
                    tmp = None
                    tmp1 = self.state.s_wp
                    if (((tmp1.m if ((tmp1 is not None)) else None)) != 600):
                        tmp1 = self.state.s_wp
                        tmp = (((tmp1.m if ((tmp1 is not None)) else None)) == 601)
                    else:
                        tmp = True
                    if tmp:
                        self.disposeWS()
                        self.notifyStatus("DISCONNECTED:WILL-RETRY")
                        self.cause = "page.frozen"
                        self.state.goto_m_from_wp(117)
                        self.exit_ws_to_m()
                        self.evtRetry(com_lightstreamer_client_internal__ClientMachine_RetryCause.page_frozen)
                    else:
                        tmp = self.state.s_wp
                        if (((tmp.m if ((tmp is not None)) else None)) == 602):
                            self.sendDestroyWS("page.frozen")
                            self.closeWS()
                            self.notifyStatus("DISCONNECTED:WILL-RETRY")
                            self.cause = "page.frozen"
                            self.state.goto_m_from_wp(117)
                            self.exit_wp_to_m()
                            self.evtRetry(com_lightstreamer_client_internal__ClientMachine_RetryCause.page_frozen)
                elif (_g == 260):
                    self.disposeHTTP()
                    self.notifyStatus("DISCONNECTED:WILL-RETRY")
                    self.cause = "page.frozen"
                    self.state.goto_m_from_rec(117)
                    self.exit_rec_to_m()
                    self.evtRetry(com_lightstreamer_client_internal__ClientMachine_RetryCause.page_frozen)
                elif (_g == 270):
                    if (self.state.s_h == 710):
                        self.disposeHTTP()
                        self.notifyStatus("DISCONNECTED:WILL-RETRY")
                        self.cause = "page.frozen"
                        self.state.goto_m_from_hs(117)
                        self.exit_hs_to_m()
                        self.evtRetry(com_lightstreamer_client_internal__ClientMachine_RetryCause.page_frozen)
                    elif (self.state.s_h == 720):
                        self.disposeHTTP()
                        self.notifyStatus("DISCONNECTED:WILL-RETRY")
                        self.cause = "page.frozen"
                        self.state.goto_m_from_hp(117)
                        self.exit_hp_to_m()
                        self.evtRetry(com_lightstreamer_client_internal__ClientMachine_RetryCause.page_frozen)
                else:
                    pass
        else:
            pass

    def evtPageResumed(self):
        self.traceEvent("page.resumed")
        if (self.state.s_m == 117):
            self.state.s_m = 116
            self.state.traceState()
            self.evtSelectCreate()

    def evtNetworkNotReachable(self,host):
        if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.reachabilityLogger.isInfoEnabled():
            com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.reachabilityLogger.info((("" + ("null" if host is None else host)) + " is NOT reachable"))
        self.traceEvent("nr:network.not.reachable")
        if (self.state.s_nr == 1410):
            self.state.s_nr = 1411
            self.state.traceState()
        elif (self.state.s_nr == 1412):
            self.state.s_nr = 1411
            self.state.traceState()

    def evtNetworkReachable(self,host):
        if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.reachabilityLogger.isInfoEnabled():
            com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.reachabilityLogger.info((("" + ("null" if host is None else host)) + " is reachable"))
        self.traceEvent("nr:network.reachable")
        if (self.state.s_nr == 1410):
            self.state.s_nr = 1412
            self.state.traceState()
        elif (self.state.s_nr == 1411):
            self.state.s_nr = 1412
            self.state.traceState()
            self.evtOnlineAgain()

    def evtOnlineAgain(self):
        self.traceEvent("online.again")
        if (self.state.s_m == 112):
            self.state.s_m = 116
            self.state.traceState()
            self.cancel_evtRetryTimeout()
            self.evtSelectCreate()
        elif (self.state.s_rec == 1003):
            self.sendRecovery()
            self.state.s_rec = 1001
            self.state.traceState()
            self.cancel_evtRetryTimeout()
            self.schedule_evtTransportTimeout(self.options.retryDelay)

    def evtServerAddressChanged(self):
        _gthis = self
        self.traceEvent("nr:serverAddress.changed")
        _g = self.state.s_nr
        if (((_g == 1412) or ((_g == 1411))) or ((_g == 1410))):
            oldManager = self.nr_reachabilityManager
            hostAddress = com_lightstreamer_internal_Url(self.getServerAddress()).get_hostname()
            self.nr_reachabilityManager = self.reachabilityFactory(hostAddress)
            self.state.s_nr = 1410
            self.state.traceState()
            if (oldManager is not None):
                oldManager.stopListening()
            def _hx_local_0(status):
                tmp = status.index
                if (tmp == 0):
                    _gthis.evtNetworkReachable(hostAddress)
                elif (tmp == 1):
                    _gthis.evtNetworkNotReachable(hostAddress)
                else:
                    pass
            self.nr_reachabilityManager.startListening(_hx_local_0)
        else:
            pass

    def evtExtDisconnect(self,terminationCause):
        _gthis = self
        def _hx_local_0():
            _gthis.traceEvent(("disconnect: cause=" + Std.string(terminationCause)))
            _g = _gthis.state.s_m
            if ((((((((_g == 117) or ((_g == 116))) or ((_g == 115))) or ((_g == 114))) or ((_g == 113))) or ((_g == 112))) or ((_g == 111))) or ((_g == 110))):
                _gthis.notifyStatus("DISCONNECTED")
                _gthis.notifyServerErrorIfCauseIsError(terminationCause)
                _gthis.state.s_m = 100
                _gthis.state.traceState()
                _gthis.cancel_evtRetryTimeout()
                _gthis.evtTerminate(terminationCause)
            elif (((_g == 122) or ((_g == 121))) or ((_g == 120))):
                _gthis.disposeWS()
                _gthis.notifyStatus("DISCONNECTED")
                _gthis.notifyServerErrorIfCauseIsError(terminationCause)
                _gthis.state.s_m = 100
                _gthis.state.traceState()
                _gthis.cancel_evtTransportTimeout()
                _gthis.evtTerminate(terminationCause)
            elif (_g == 130):
                _gthis.disposeHTTP()
                _gthis.notifyStatus("DISCONNECTED")
                _gthis.notifyServerErrorIfCauseIsError(terminationCause)
                _gthis.state.s_m = 100
                _gthis.state.traceState()
                _gthis.cancel_evtTransportTimeout()
                _gthis.evtTerminate(terminationCause)
            elif (_g == 140):
                _gthis.disposeHTTP()
                _gthis.notifyStatus("DISCONNECTED")
                _gthis.notifyServerErrorIfCauseIsError(terminationCause)
                _gthis.state.s_m = 100
                _gthis.state.traceState()
                _gthis.cancel_evtTransportTimeout()
                _gthis.evtTerminate(terminationCause)
            elif (_g == 150):
                _g = _gthis.state.s_tr
                if (_g is not None):
                    if (_g == 210):
                        _gthis.sendDestroyWS()
                        _gthis.closeWS()
                        _gthis.notifyStatus("DISCONNECTED")
                        _gthis.notifyServerErrorIfCauseIsError(terminationCause)
                        _gthis.state.clear_w()
                        _gthis.state.goto_m_from_session(100)
                        _gthis.exit_w()
                        _gthis.evtEndSession()
                        _gthis.evtTerminate(terminationCause)
                    elif (_g == 220):
                        _gthis.disposeHTTP()
                        _gthis.notifyStatus("DISCONNECTED")
                        _gthis.notifyServerErrorIfCauseIsError(terminationCause)
                        _gthis.state.goto_m_from_session(100)
                        _gthis.cancel_evtTransportTimeout()
                        _gthis.evtEndSession()
                        _gthis.evtTerminate(terminationCause)
                    elif (_g == 230):
                        _gthis.disposeHTTP()
                        _gthis.notifyStatus("DISCONNECTED")
                        _gthis.notifyServerErrorIfCauseIsError(terminationCause)
                        _gthis.state.goto_m_from_session(100)
                        _gthis.cancel_evtTransportTimeout()
                        _gthis.evtEndSession()
                        _gthis.evtTerminate(terminationCause)
                    elif (_g == 240):
                        tmp = _gthis.state.s_ws
                        if (((tmp.m if ((tmp is not None)) else None)) == 500):
                            _gthis.disposeWS()
                            _gthis.notifyStatus("DISCONNECTED")
                            _gthis.notifyServerErrorIfCauseIsError(terminationCause)
                            _gthis.state.goto_m_from_ws(100)
                            _gthis.exit_ws_to_m()
                            _gthis.evtTerminate(terminationCause)
                        else:
                            tmp = None
                            tmp1 = None
                            tmp2 = _gthis.state.s_ws
                            if (((tmp2.m if ((tmp2 is not None)) else None)) != 501):
                                tmp2 = _gthis.state.s_ws
                                tmp1 = (((tmp2.m if ((tmp2 is not None)) else None)) == 502)
                            else:
                                tmp1 = True
                            if (not tmp1):
                                tmp1 = _gthis.state.s_ws
                                tmp = (((tmp1.m if ((tmp1 is not None)) else None)) == 503)
                            else:
                                tmp = True
                            if tmp:
                                _gthis.sendDestroyWS()
                                _gthis.closeWS()
                                _gthis.notifyStatus("DISCONNECTED")
                                _gthis.notifyServerErrorIfCauseIsError(terminationCause)
                                _gthis.state.goto_m_from_ws(100)
                                _gthis.exit_ws_to_m()
                                _gthis.evtTerminate(terminationCause)
                    elif (_g == 250):
                        tmp = None
                        tmp1 = _gthis.state.s_wp
                        if (((tmp1.m if ((tmp1 is not None)) else None)) != 600):
                            tmp1 = _gthis.state.s_wp
                            tmp = (((tmp1.m if ((tmp1 is not None)) else None)) == 601)
                        else:
                            tmp = True
                        if tmp:
                            _gthis.disposeWS()
                            _gthis.notifyStatus("DISCONNECTED")
                            _gthis.notifyServerErrorIfCauseIsError(terminationCause)
                            _gthis.state.goto_m_from_wp(100)
                            _gthis.exit_ws_to_m()
                            _gthis.evtTerminate(terminationCause)
                        else:
                            tmp = _gthis.state.s_wp
                            if (((tmp.m if ((tmp is not None)) else None)) == 602):
                                _gthis.sendDestroyWS()
                                _gthis.closeWS()
                                _gthis.notifyStatus("DISCONNECTED")
                                _gthis.notifyServerErrorIfCauseIsError(terminationCause)
                                _gthis.state.goto_m_from_wp(100)
                                _gthis.exit_wp_to_m()
                                _gthis.evtTerminate(terminationCause)
                    elif (_g == 260):
                        _gthis.disposeHTTP()
                        _gthis.notifyStatus("DISCONNECTED")
                        _gthis.notifyServerErrorIfCauseIsError(terminationCause)
                        _gthis.state.goto_m_from_rec(100)
                        _gthis.exit_rec_to_m()
                        _gthis.evtTerminate(terminationCause)
                    elif (_g == 270):
                        if (_gthis.state.s_h == 710):
                            _gthis.disposeHTTP()
                            _gthis.notifyStatus("DISCONNECTED")
                            _gthis.notifyServerErrorIfCauseIsError(terminationCause)
                            _gthis.state.goto_m_from_hs(100)
                            _gthis.exit_hs_to_m()
                            _gthis.evtTerminate(terminationCause)
                        elif (_gthis.state.s_h == 720):
                            _gthis.disposeHTTP()
                            _gthis.notifyStatus("DISCONNECTED")
                            _gthis.notifyServerErrorIfCauseIsError(terminationCause)
                            _gthis.state.goto_m_from_hp(100)
                            _gthis.exit_hp_to_m()
                            _gthis.evtTerminate(terminationCause)
                    else:
                        pass
            else:
                pass
        self.lock.synchronized(_hx_local_0)

    def evtSelectCreate(self):
        self.traceEvent("select.create")
        if ((self.state.s_m == 101) or ((self.state.s_m == 116))):
            tmp = self.getBestForCreating().index
            if (tmp == 0):
                self.notifyStatus("CONNECTING")
                self.openWS_Create()
                self.state.s_m = 120
                self.state.traceState()
                self.evtCreate()
                self.schedule_evtTransportTimeout(self.delayCounter.get_currentRetryDelay())
            elif (tmp == 1):
                self.notifyStatus("CONNECTING")
                self.sendCreateHTTP()
                self.state.s_m = 130
                self.state.traceState()
                self.evtCreate()
                self.schedule_evtTransportTimeout(self.delayCounter.get_currentRetryDelay())
            elif (tmp == 2):
                self.notifyStatus("DISCONNECTED")
                self.state.s_m = 100
                self.state.traceState()
                self.evtTerminate(com_lightstreamer_client_internal__ClientMachine_TerminationCause.TC_otherError("Unable to select a transport"))
            else:
                pass

    def evtWSOpen(self):
        self.traceEvent("ws.open")
        if (self.state.s_m == 120):
            self.sendCreateWS()
            self.state.s_m = 121
            self.state.traceState()
        else:
            tmp = self.state.s_ws
            if (((tmp.m if ((tmp is not None)) else None)) == 500):
                self.sendBindWS_Streaming()
                self.state.s_ws.m = 501
                self.state.traceState()
            else:
                tmp = self.state.s_wp
                if (((tmp.m if ((tmp is not None)) else None)) == 600):
                    com_lightstreamer_internal_NullTools.sure(self.ws).send("wsok")
                    self.state.s_wp.m = 601
                    self.state.traceState()

    def evtMessage(self,line):
        matched = True
        if line.startswith("U,"):
            update = com_lightstreamer_client_internal__ParseTools_ParseTools_Fields_.parseUpdate(line)
            self.evtU(update.subId,update.itemIdx,update.values,line)
        elif line.startswith("REQOK"):
            if (line == "REQOK"):
                self.evtREQOK_withoutReqId()
            else:
                args = line.split(",")
                self.evtREQOK(com_lightstreamer_client_internal__ParseTools_ParseTools_Fields_.parseInt((args[1] if 1 < len(args) else None)))
        elif line.startswith("PROBE"):
            self.evtPROBE()
        elif line.startswith("LOOP"):
            args = line.split(",")
            self.evtLOOP(com_lightstreamer_client_internal__ParseTools_ParseTools_Fields_.parseInt((args[1] if 1 < len(args) else None)))
        elif line.startswith("CONOK"):
            args = line.split(",")
            self.evtCONOK((args[1] if 1 < len(args) else None),com_lightstreamer_client_internal__ParseTools_ParseTools_Fields_.parseInt((args[2] if 2 < len(args) else None)),com_lightstreamer_client_internal__ParseTools_ParseTools_Fields_.parseInt((args[3] if 3 < len(args) else None)),(args[4] if 4 < len(args) else None))
        elif line.startswith("WSOK"):
            self.evtWSOK()
        elif line.startswith("SERVNAME"):
            args = line.split(",")
            self.evtSERVNAME((args[1] if 1 < len(args) else None))
        elif line.startswith("CLIENTIP"):
            args = line.split(",")
            self.evtCLIENTIP((args[1] if 1 < len(args) else None))
        elif line.startswith("CONS"):
            args = line.split(",")
            bw = (args[1] if 1 < len(args) else None)
            if (bw == "unlimited"):
                self.evtCONS(com_lightstreamer_internal_RealMaxBandwidth.BWUnlimited)
            elif (bw == "unmanaged"):
                self.evtCONS(com_lightstreamer_internal_RealMaxBandwidth.BWUnmanaged)
            else:
                self.evtCONS(com_lightstreamer_internal_RealMaxBandwidth.BWLimited(com_lightstreamer_client_internal__ParseTools_ParseTools_Fields_.parseFloat(bw)))
        elif line.startswith("MSGDONE"):
            args = line.split(",")
            seq = (args[1] if 1 < len(args) else None)
            if (seq == "*"):
                seq = "UNORDERED_MESSAGES"
            prog = com_lightstreamer_client_internal__ParseTools_ParseTools_Fields_.parseInt((args[2] if 2 < len(args) else None))
            rawResp = (args[3] if 3 < len(args) else None)
            self.evtMSGDONE(seq,prog,("" if ((rawResp == "")) else com_lightstreamer_client_internal__ParseTools_ParseTools_Fields_.unquote(rawResp)))
        elif line.startswith("MSGFAIL"):
            args = line.split(",")
            seq = (args[1] if 1 < len(args) else None)
            if (seq == "*"):
                seq = "UNORDERED_MESSAGES"
            self.evtMSGFAIL(seq,com_lightstreamer_client_internal__ParseTools_ParseTools_Fields_.parseInt((args[2] if 2 < len(args) else None)),com_lightstreamer_client_internal__ParseTools_ParseTools_Fields_.parseInt((args[3] if 3 < len(args) else None)),com_lightstreamer_client_internal__ParseTools_ParseTools_Fields_.unquote((args[4] if 4 < len(args) else None)))
        elif line.startswith("REQERR"):
            args = line.split(",")
            self.evtREQERR(com_lightstreamer_client_internal__ParseTools_ParseTools_Fields_.parseInt((args[1] if 1 < len(args) else None)),com_lightstreamer_client_internal__ParseTools_ParseTools_Fields_.parseInt((args[2] if 2 < len(args) else None)),com_lightstreamer_client_internal__ParseTools_ParseTools_Fields_.unquote((args[3] if 3 < len(args) else None)))
        elif line.startswith("PROG"):
            args = line.split(",")
            self.evtPROG(com_lightstreamer_client_internal__ParseTools_ParseTools_Fields_.parseInt((args[1] if 1 < len(args) else None)))
        elif line.startswith("SUBOK"):
            args = line.split(",")
            self.evtSUBOK(com_lightstreamer_client_internal__ParseTools_ParseTools_Fields_.parseInt((args[1] if 1 < len(args) else None)),com_lightstreamer_client_internal__ParseTools_ParseTools_Fields_.parseInt((args[2] if 2 < len(args) else None)),com_lightstreamer_client_internal__ParseTools_ParseTools_Fields_.parseInt((args[3] if 3 < len(args) else None)))
        elif line.startswith("SUBCMD"):
            args = line.split(",")
            self.evtSUBCMD(com_lightstreamer_client_internal__ParseTools_ParseTools_Fields_.parseInt((args[1] if 1 < len(args) else None)),com_lightstreamer_client_internal__ParseTools_ParseTools_Fields_.parseInt((args[2] if 2 < len(args) else None)),com_lightstreamer_client_internal__ParseTools_ParseTools_Fields_.parseInt((args[3] if 3 < len(args) else None)),com_lightstreamer_client_internal__ParseTools_ParseTools_Fields_.parseInt((args[4] if 4 < len(args) else None)),com_lightstreamer_client_internal__ParseTools_ParseTools_Fields_.parseInt((args[5] if 5 < len(args) else None)))
        elif line.startswith("UNSUB"):
            args = line.split(",")
            self.evtUNSUB(com_lightstreamer_client_internal__ParseTools_ParseTools_Fields_.parseInt((args[1] if 1 < len(args) else None)))
        elif line.startswith("CONF"):
            args = line.split(",")
            subId = com_lightstreamer_client_internal__ParseTools_ParseTools_Fields_.parseInt((args[1] if 1 < len(args) else None))
            if ((args[2] if 2 < len(args) else None) == "unlimited"):
                self.evtCONF(subId,com_lightstreamer_internal_RealMaxFrequency.RFreqUnlimited)
            else:
                self.evtCONF(subId,com_lightstreamer_internal_RealMaxFrequency.RFreqLimited(com_lightstreamer_client_internal__ParseTools_ParseTools_Fields_.parseFloat((args[2] if 2 < len(args) else None))))
        elif line.startswith("EOS"):
            args = line.split(",")
            self.evtEOS(com_lightstreamer_client_internal__ParseTools_ParseTools_Fields_.parseInt((args[1] if 1 < len(args) else None)),com_lightstreamer_client_internal__ParseTools_ParseTools_Fields_.parseInt((args[2] if 2 < len(args) else None)))
        elif line.startswith("CS"):
            args = line.split(",")
            self.evtCS(com_lightstreamer_client_internal__ParseTools_ParseTools_Fields_.parseInt((args[1] if 1 < len(args) else None)),com_lightstreamer_client_internal__ParseTools_ParseTools_Fields_.parseInt((args[2] if 2 < len(args) else None)))
        elif line.startswith("OV"):
            args = line.split(",")
            self.evtOV(com_lightstreamer_client_internal__ParseTools_ParseTools_Fields_.parseInt((args[1] if 1 < len(args) else None)),com_lightstreamer_client_internal__ParseTools_ParseTools_Fields_.parseInt((args[2] if 2 < len(args) else None)),com_lightstreamer_client_internal__ParseTools_ParseTools_Fields_.parseInt((args[3] if 3 < len(args) else None)))
        elif line.startswith("NOOP"):
            self.evtNOOP()
        elif line.startswith("CONERR"):
            args = line.split(",")
            self.evtCONERR(com_lightstreamer_client_internal__ParseTools_ParseTools_Fields_.parseInt((args[1] if 1 < len(args) else None)),com_lightstreamer_client_internal__ParseTools_ParseTools_Fields_.unquote((args[2] if 2 < len(args) else None)))
        elif line.startswith("END"):
            args = line.split(",")
            self.evtEND(com_lightstreamer_client_internal__ParseTools_ParseTools_Fields_.parseInt((args[1] if 1 < len(args) else None)),com_lightstreamer_client_internal__ParseTools_ParseTools_Fields_.unquote((args[2] if 2 < len(args) else None)))
        elif line.startswith("ERROR"):
            args = line.split(",")
            self.evtERROR(com_lightstreamer_client_internal__ParseTools_ParseTools_Fields_.parseInt((args[1] if 1 < len(args) else None)),com_lightstreamer_client_internal__ParseTools_ParseTools_Fields_.unquote((args[2] if 2 < len(args) else None)))
        elif line.startswith("SYNC"):
            args = line.split(",")
            self.evtSYNC(com_lightstreamer_client_internal__ParseTools_ParseTools_Fields_.parseInt((args[1] if 1 < len(args) else None)))
        else:
            matched = False
        return matched

    def evtCtrlMessage(self,line):
        if line.startswith("REQOK"):
            if (line == "REQOK"):
                self.evtREQOK_withoutReqId()
            else:
                args = line.split(",")
                self.evtREQOK(com_lightstreamer_client_internal__ParseTools_ParseTools_Fields_.parseInt((args[1] if 1 < len(args) else None)))
        elif line.startswith("REQERR"):
            args = line.split(",")
            self.evtREQERR(com_lightstreamer_client_internal__ParseTools_ParseTools_Fields_.parseInt((args[1] if 1 < len(args) else None)),com_lightstreamer_client_internal__ParseTools_ParseTools_Fields_.parseInt((args[2] if 2 < len(args) else None)),com_lightstreamer_client_internal__ParseTools_ParseTools_Fields_.unquote((args[3] if 3 < len(args) else None)))
        elif line.startswith("ERROR"):
            args = line.split(",")
            self.evtERROR(com_lightstreamer_client_internal__ParseTools_ParseTools_Fields_.parseInt((args[1] if 1 < len(args) else None)),com_lightstreamer_client_internal__ParseTools_ParseTools_Fields_.unquote((args[2] if 2 < len(args) else None)))

    def evtTransportTimeout(self):
        self.traceEvent("transport.timeout")
        _g = self.state.s_m
        if ((_g == 121) or ((_g == 120))):
            self.suspendWS_Streaming()
            self.disposeWS()
            self.cause = "ws.unavailable"
            self.state.s_m = 115
            self.state.traceState()
            self.cancel_evtTransportTimeout()
            self.entry_m115(com_lightstreamer_client_internal__ClientMachine_RetryCause.ws_unavailable)
        elif (_g == 122):
            self.disposeWS()
            self.notifyStatus("DISCONNECTED:WILL-RETRY")
            self.cause = "ws.timeout"
            self.state.s_m = 112
            self.state.traceState()
            self.cancel_evtTransportTimeout()
            self.entry_m112(com_lightstreamer_client_internal__ClientMachine_RetryCause.ws_timeout)
        elif (_g == 130):
            self.disposeHTTP()
            self.notifyStatus("DISCONNECTED:WILL-RETRY")
            self.cause = "http.timeout"
            self.state.s_m = 112
            self.state.traceState()
            self.cancel_evtTransportTimeout()
            self.entry_m112(com_lightstreamer_client_internal__ClientMachine_RetryCause.http_timeout)
        elif (_g == 140):
            self.disposeHTTP()
            self.notifyStatus("DISCONNECTED:WILL-RETRY")
            self.cause = "ttl.timeout"
            pauseMs = self.waitingInterval(self.delayCounter.get_currentRetryDelay(),self.connectTs)
            self.state.s_m = 111
            self.state.traceState()
            self.cancel_evtTransportTimeout()
            self.entry_m111(com_lightstreamer_client_internal__ClientMachine_RetryCause.http_error,pauseMs)
        elif (_g == 150):
            _g = self.state.s_tr
            if (_g is not None):
                if (_g == 220):
                    if (self.options.sessionRecoveryTimeout == 0):
                        self.disposeHTTP()
                        self.notifyStatus("DISCONNECTED:WILL-RETRY")
                        self.cause = "http.timeout"
                        self.state.goto_m_from_session(112)
                        self.cancel_evtTransportTimeout()
                        self.evtEndSession()
                        self.entry_m112(com_lightstreamer_client_internal__ClientMachine_RetryCause.http_timeout)
                    else:
                        self.disposeHTTP()
                        self.notifyStatus("DISCONNECTED:TRYING-RECOVERY")
                        self.cause = "http.timeout"
                        pauseMs = self.randomGenerator(self.options.firstRetryMaxDelay)
                        self.state.goto_rec()
                        self.cancel_evtTransportTimeout()
                        self.entry_rec(pauseMs,com_lightstreamer_client_internal__ClientMachine_RetryCause.http_timeout)
                elif (_g == 230):
                    if (self.options.sessionRecoveryTimeout == 0):
                        self.disposeHTTP()
                        self.notifyStatus("DISCONNECTED:WILL-RETRY")
                        self.cause = "ttl.timeout"
                        self.state.goto_m_from_session(112)
                        self.cancel_evtTransportTimeout()
                        self.evtEndSession()
                        self.entry_m112(com_lightstreamer_client_internal__ClientMachine_RetryCause.http_timeout)
                    else:
                        self.disposeHTTP()
                        self.notifyStatus("DISCONNECTED:TRYING-RECOVERY")
                        self.cause = "ttl.timeout"
                        pauseMs = self.randomGenerator(self.options.firstRetryMaxDelay)
                        self.state.goto_rec()
                        self.cancel_evtTransportTimeout()
                        self.entry_rec(pauseMs,com_lightstreamer_client_internal__ClientMachine_RetryCause.http_error)
                elif (_g == 240):
                    tmp = self.state.s_ws
                    _g = (tmp.m if ((tmp is not None)) else None)
                    if (_g is not None):
                        _g1 = _g
                        if (_g1 == 500):
                            self.disableWS()
                            self.disposeWS()
                            self.cause = "ws.unavailable"
                            self.state.clear_ws()
                            self.state.s_tr = 200
                            self.state.traceState()
                            self.cancel_evtTransportTimeout()
                            self.evtSwitchTransport()
                        elif (_g1 == 501):
                            if (self.options.sessionRecoveryTimeout == 0):
                                self.disableWS()
                                self.disposeWS()
                                self.notifyStatus("DISCONNECTED:WILL-RETRY")
                                self.cause = "ws.unavailable"
                                self.state.goto_m_from_ws(112)
                                self.exit_ws_to_m()
                                self.entry_m112(com_lightstreamer_client_internal__ClientMachine_RetryCause.ws_unavailable)
                            else:
                                self.disableWS()
                                self.disposeWS()
                                self.notifyStatus("DISCONNECTED:TRYING-RECOVERY")
                                self.cause = "ws.unavailable"
                                pauseMs = self.randomGenerator(self.options.firstRetryMaxDelay)
                                self.state.goto_rec_from_ws()
                                self.exit_ws()
                                self.entry_rec(pauseMs,com_lightstreamer_client_internal__ClientMachine_RetryCause.ws_unavailable)
                        elif (_g1 == 502):
                            if (self.options.sessionRecoveryTimeout == 0):
                                self.disposeWS()
                                self.notifyStatus("DISCONNECTED:WILL-RETRY")
                                self.cause = "ws.timeout"
                                self.state.goto_m_from_ws(112)
                                self.exit_ws_to_m()
                                self.entry_m112(com_lightstreamer_client_internal__ClientMachine_RetryCause.ws_timeout)
                            else:
                                self.disposeWS()
                                self.notifyStatus("DISCONNECTED:TRYING-RECOVERY")
                                self.cause = "ws.timeout"
                                pauseMs = self.randomGenerator(self.options.firstRetryMaxDelay)
                                self.state.goto_rec_from_ws()
                                self.exit_ws()
                                self.entry_rec(pauseMs,com_lightstreamer_client_internal__ClientMachine_RetryCause.ws_timeout)
                        else:
                            pass
                elif (_g == 250):
                    tmp = self.state.s_wp
                    _g = (tmp.m if ((tmp is not None)) else None)
                    if (_g is not None):
                        _g1 = _g
                        if ((_g1 == 601) or ((_g1 == 600))):
                            self.disableWS()
                            self.disposeWS()
                            self.cause = "ws.unavailable"
                            self.state.clear_wp()
                            self.state.s_tr = 200
                            self.state.traceState()
                            self.exit_wp()
                            self.evtSwitchTransport()
                        else:
                            pass
                elif (_g == 260):
                    if (self.state.s_rec == 1001):
                        self.disposeHTTP()
                        self.state.s_rec = 1002
                        self.state.traceState()
                        self.cancel_evtTransportTimeout()
                        self.evtCheckRecoveryTimeout(com_lightstreamer_client_internal__ClientMachine_RecoveryRetryCause.RRC_transport_timeout)
                elif (_g == 270):
                    _g = self.state.s_h
                    if (_g is not None):
                        if (_g == 710):
                            tmp = self.state.s_hs
                            _g = (tmp.m if ((tmp is not None)) else None)
                            if (_g is not None):
                                _g1 = _g
                                if (_g1 == 800):
                                    self.disableHTTP_Streaming()
                                    self.cause = "http.streaming.unavailable"
                                    self.state.s_hs.m = 801
                                    self.state.traceState()
                                    self.cancel_evtTransportTimeout()
                                    self.evtForcePolling()
                                    self.schedule_evtTransportTimeout(self.options.retryDelay)
                                elif (_g1 == 801):
                                    if (self.options.sessionRecoveryTimeout == 0):
                                        self.disposeHTTP()
                                        self.notifyStatus("DISCONNECTED:WILL-RETRY")
                                        self.cause = "http.timeout"
                                        self.state.goto_m_from_hs(112)
                                        self.exit_hs_to_m()
                                        self.entry_m112(com_lightstreamer_client_internal__ClientMachine_RetryCause.http_timeout)
                                    else:
                                        self.disposeHTTP()
                                        self.notifyStatus("DISCONNECTED:TRYING-RECOVERY")
                                        self.cause = "http.timeout"
                                        pauseMs = self.randomGenerator(self.options.firstRetryMaxDelay)
                                        self.state.goto_rec_from_hs()
                                        self.exit_hs_to_rec()
                                        self.entry_rec(pauseMs,com_lightstreamer_client_internal__ClientMachine_RetryCause.http_timeout)
                                else:
                                    pass
                else:
                    pass
        else:
            pass

    def evtTransportError(self):
        self.traceEvent("transport.error")
        _g = self.state.s_m
        if ((_g == 121) or ((_g == 120))):
            self.suspendWS_Streaming()
            self.disposeWS()
            self.cause = "ws.unavailable"
            self.state.s_m = 115
            self.state.traceState()
            self.cancel_evtTransportTimeout()
            self.evtRetry(com_lightstreamer_client_internal__ClientMachine_RetryCause.ws_unavailable)
            self.evtRetryTimeout()
        elif (_g == 122):
            self.disposeWS()
            self.notifyStatus("DISCONNECTED:WILL-RETRY")
            self.cause = "ws.error"
            pauseMs = self.waitingInterval(self.delayCounter.get_currentRetryDelay(),self.connectTs)
            self.state.s_m = 112
            self.state.traceState()
            self.cancel_evtTransportTimeout()
            self.evtRetry(com_lightstreamer_client_internal__ClientMachine_RetryCause.ws_error,pauseMs)
            self.schedule_evtRetryTimeout(pauseMs)
        elif (_g == 130):
            self.disposeHTTP()
            self.notifyStatus("DISCONNECTED:WILL-RETRY")
            self.cause = "http.error"
            pauseMs = self.waitingInterval(self.delayCounter.get_currentRetryDelay(),self.connectTs)
            self.state.s_m = 112
            self.state.traceState()
            self.cancel_evtTransportTimeout()
            self.evtRetry(com_lightstreamer_client_internal__ClientMachine_RetryCause.http_error,pauseMs)
            self.schedule_evtRetryTimeout(pauseMs)
        elif (_g == 140):
            self.disposeHTTP()
            self.notifyStatus("DISCONNECTED:WILL-RETRY")
            self.cause = "ttl.error"
            pauseMs = self.waitingInterval(self.delayCounter.get_currentRetryDelay(),self.connectTs)
            self.state.s_m = 111
            self.state.traceState()
            self.cancel_evtTransportTimeout()
            self.evtRetry(com_lightstreamer_client_internal__ClientMachine_RetryCause.http_error,pauseMs)
            self.schedule_evtRetryTimeout(pauseMs)
        elif (_g == 150):
            _g = self.state.s_tr
            if (_g is not None):
                if (_g == 210):
                    if (self.options.sessionRecoveryTimeout == 0):
                        self.disposeWS()
                        self.notifyStatus("DISCONNECTED:WILL-RETRY")
                        self.cause = "ws.error"
                        self.state.clear_w()
                        self.state.goto_m_from_session(113)
                        self.exit_w()
                        self.evtEndSession()
                        self.entry_m113(com_lightstreamer_client_internal__ClientMachine_RetryCause.ws_error)
                    else:
                        self.disposeWS()
                        self.notifyStatus("DISCONNECTED:TRYING-RECOVERY")
                        self.cause = "ws.error"
                        pauseMs = self.randomGenerator(self.options.firstRetryMaxDelay)
                        self.state.clear_w()
                        self.state.s_tr = 260
                        self.state.s_rec = 1000
                        self.state.traceState()
                        self.exit_w()
                        self.entry_rec(pauseMs,com_lightstreamer_client_internal__ClientMachine_RetryCause.ws_error)
                elif (_g == 220):
                    if (self.options.sessionRecoveryTimeout == 0):
                        self.disposeHTTP()
                        self.notifyStatus("DISCONNECTED:WILL-RETRY")
                        self.cause = "http.error"
                        pauseMs = self.waitingInterval(self.delayCounter.get_currentRetryDelay(),self.connectTs)
                        self.state.goto_m_from_session(112)
                        self.cancel_evtTransportTimeout()
                        self.evtEndSession()
                        self.evtRetry(com_lightstreamer_client_internal__ClientMachine_RetryCause.http_error,pauseMs)
                        self.schedule_evtRetryTimeout(pauseMs)
                    else:
                        self.disposeHTTP()
                        self.notifyStatus("DISCONNECTED:TRYING-RECOVERY")
                        self.cause = "http.error"
                        pauseMs = self.randomGenerator(self.options.firstRetryMaxDelay)
                        self.state.goto_rec()
                        self.cancel_evtTransportTimeout()
                        self.entry_rec(pauseMs,com_lightstreamer_client_internal__ClientMachine_RetryCause.http_error)
                elif (_g == 230):
                    if (self.options.sessionRecoveryTimeout == 0):
                        self.disposeHTTP()
                        self.notifyStatus("DISCONNECTED:WILL-RETRY")
                        self.cause = "ttl.error"
                        pauseMs = self.waitingInterval(self.delayCounter.get_currentRetryDelay(),self.connectTs)
                        self.state.goto_m_from_session(112)
                        self.cancel_evtTransportTimeout()
                        self.evtEndSession()
                        self.evtRetry(com_lightstreamer_client_internal__ClientMachine_RetryCause.http_error,pauseMs)
                        self.schedule_evtRetryTimeout(pauseMs)
                    else:
                        self.disposeHTTP()
                        self.notifyStatus("DISCONNECTED:TRYING-RECOVERY")
                        self.cause = "ttl.error"
                        pauseMs = self.randomGenerator(self.options.firstRetryMaxDelay)
                        self.state.goto_rec()
                        self.cancel_evtTransportTimeout()
                        self.entry_rec(pauseMs,com_lightstreamer_client_internal__ClientMachine_RetryCause.http_error)
                elif (_g == 240):
                    _g = com_lightstreamer_internal_NullTools.sure(self.state.s_ws).m
                    if (_g == 500):
                        self.disableWS()
                        self.disposeWS()
                        self.cause = "ws.unavailable"
                        self.state.clear_ws()
                        self.state.s_tr = 200
                        self.state.traceState()
                        self.cancel_evtTransportTimeout()
                        self.evtSwitchTransport()
                    elif (_g == 501):
                        if (self.options.sessionRecoveryTimeout == 0):
                            self.disableWS()
                            self.disposeWS()
                            self.notifyStatus("DISCONNECTED:WILL-RETRY")
                            self.cause = "ws.unavailable"
                            self.state.goto_m_from_ws(112)
                            self.exit_ws_to_m()
                            self.entry_m112(com_lightstreamer_client_internal__ClientMachine_RetryCause.ws_unavailable)
                        else:
                            self.disableWS()
                            self.disposeWS()
                            self.notifyStatus("DISCONNECTED:TRYING-RECOVERY")
                            self.cause = "ws.unavailable"
                            pauseMs = self.randomGenerator(self.options.firstRetryMaxDelay)
                            self.state.goto_rec_from_ws()
                            self.exit_ws()
                            self.entry_rec(pauseMs,com_lightstreamer_client_internal__ClientMachine_RetryCause.ws_unavailable)
                    elif (_g == 502):
                        if (self.options.sessionRecoveryTimeout == 0):
                            self.disposeWS()
                            self.notifyStatus("DISCONNECTED:WILL-RETRY")
                            self.cause = "ws.error"
                            self.state.goto_m_from_ws(112)
                            self.exit_ws_to_m()
                            self.entry_m112(com_lightstreamer_client_internal__ClientMachine_RetryCause.ws_error)
                        else:
                            self.disposeWS()
                            self.notifyStatus("DISCONNECTED:TRYING-RECOVERY")
                            self.cause = "ws.error"
                            pauseMs = self.randomGenerator(self.options.firstRetryMaxDelay)
                            self.state.goto_rec_from_ws()
                            self.cancel_evtTransportTimeout()
                            self.entry_rec(pauseMs,com_lightstreamer_client_internal__ClientMachine_RetryCause.ws_error)
                    elif (_g == 503):
                        if (self.options.sessionRecoveryTimeout == 0):
                            self.disposeWS()
                            self.notifyStatus("DISCONNECTED:WILL-RETRY")
                            self.cause = "ws.error"
                            self.state.goto_m_from_ws(113)
                            self.exit_ws_to_m()
                            self.entry_m113(com_lightstreamer_client_internal__ClientMachine_RetryCause.ws_error)
                        else:
                            self.disposeWS()
                            self.notifyStatus("DISCONNECTED:TRYING-RECOVERY")
                            self.cause = "ws.error"
                            pauseMs = self.randomGenerator(self.options.firstRetryMaxDelay)
                            self.state.goto_rec_from_ws()
                            self.exit_ws()
                            self.entry_rec(pauseMs,com_lightstreamer_client_internal__ClientMachine_RetryCause.ws_error)
                    else:
                        pass
                elif (_g == 250):
                    _g = com_lightstreamer_internal_NullTools.sure(self.state.s_wp).m
                    if ((_g == 601) or ((_g == 600))):
                        self.disableWS()
                        self.disposeWS()
                        self.cause = "ws.unavailable"
                        self.state.clear_wp()
                        self.state.s_tr = 200
                        self.state.traceState()
                        self.cancel_evtTransportTimeout()
                        self.evtSwitchTransport()
                    elif (_g == 602):
                        if (self.options.sessionRecoveryTimeout == 0):
                            self.disposeWS()
                            self.notifyStatus("DISCONNECTED:WILL-RETRY")
                            self.cause = "ws.error"
                            self.state.goto_m_from_wp(113)
                            self.exit_wp_to_m()
                            self.entry_m113(com_lightstreamer_client_internal__ClientMachine_RetryCause.ws_error)
                        else:
                            self.disposeWS()
                            self.notifyStatus("DISCONNECTED:TRYING-RECOVERY")
                            self.cause = "ws.error"
                            pauseMs = self.randomGenerator(self.options.firstRetryMaxDelay)
                            self.state.goto_rec_from_wp()
                            self.exit_wp()
                            self.entry_rec(pauseMs,com_lightstreamer_client_internal__ClientMachine_RetryCause.ws_error)
                    else:
                        pass
                elif (_g == 260):
                    if (self.state.s_rec == 1001):
                        self.disposeHTTP()
                        self.state.s_rec = 1002
                        self.state.traceState()
                        self.cancel_evtTransportTimeout()
                        self.evtCheckRecoveryTimeout(com_lightstreamer_client_internal__ClientMachine_RecoveryRetryCause.RRC_transport_error)
                elif (_g == 270):
                    _g = com_lightstreamer_internal_NullTools.sure(self.state.s_h)
                    if (_g == 710):
                        _g = com_lightstreamer_internal_NullTools.sure(self.state.s_hs).m
                        if ((_g == 801) or ((_g == 800))):
                            if (self.options.sessionRecoveryTimeout == 0):
                                self.disposeHTTP()
                                self.notifyStatus("DISCONNECTED:WILL-RETRY")
                                self.cause = "http.error"
                                self.state.goto_m_from_hs(112)
                                self.exit_hs_to_m()
                                self.entry_m112(com_lightstreamer_client_internal__ClientMachine_RetryCause.http_error)
                            else:
                                self.disposeHTTP()
                                self.notifyStatus("DISCONNECTED:TRYING-RECOVERY")
                                self.cause = "http.error"
                                pauseMs = self.randomGenerator(self.options.firstRetryMaxDelay)
                                self.state.goto_rec_from_hs()
                                self.exit_hs_to_rec()
                                self.entry_rec(pauseMs,com_lightstreamer_client_internal__ClientMachine_RetryCause.http_error)
                        elif (_g == 802):
                            if (self.options.sessionRecoveryTimeout == 0):
                                self.disposeHTTP()
                                self.notifyStatus("DISCONNECTED:WILL-RETRY")
                                self.cause = "http.error"
                                self.state.goto_m_from_hs(113)
                                self.exit_hs_to_m()
                                self.entry_m113(com_lightstreamer_client_internal__ClientMachine_RetryCause.http_error)
                            else:
                                self.disposeHTTP()
                                self.notifyStatus("DISCONNECTED:TRYING-RECOVERY")
                                self.cause = "http.error"
                                pauseMs = self.randomGenerator(self.options.firstRetryMaxDelay)
                                self.state.goto_rec_from_hs()
                                self.exit_hs_to_rec()
                                self.entry_rec(pauseMs,com_lightstreamer_client_internal__ClientMachine_RetryCause.http_error)
                        else:
                            pass
                    elif (_g == 720):
                        _g = com_lightstreamer_internal_NullTools.sure(self.state.s_hp).m
                        if (((((_g == 904) or ((_g == 903))) or ((_g == 902))) or ((_g == 901))) or ((_g == 900))):
                            if (self.options.sessionRecoveryTimeout == 0):
                                self.disposeHTTP()
                                self.notifyStatus("DISCONNECTED:WILL-RETRY")
                                self.cause = "http.error"
                                self.state.goto_m_from_hp(112)
                                self.exit_hp_to_m()
                                self.entry_m112(com_lightstreamer_client_internal__ClientMachine_RetryCause.http_error)
                            else:
                                self.disposeHTTP()
                                self.notifyStatus("DISCONNECTED:TRYING-RECOVERY")
                                self.cause = "http.error"
                                pauseMs = self.randomGenerator(self.options.firstRetryMaxDelay)
                                self.state.goto_rec_from_hp()
                                self.exit_hp_to_rec()
                                self.entry_rec(pauseMs,com_lightstreamer_client_internal__ClientMachine_RetryCause.http_error)
                        else:
                            pass
                    else:
                        pass
                else:
                    pass
        else:
            pass

    def evtIdleTimeout(self):
        self.traceEvent("idle.timeout")
        tmp = None
        tmp1 = self.state.s_wp
        _g = (tmp1.p if ((tmp1 is not None)) else None)
        if (_g is None):
            tmp = False
        else:
            _g1 = _g
            if (((_g1 == 613) or ((_g1 == 611))) or ((_g1 == 610))):
                tmp = True
            else:
                tmp = False
        if tmp:
            if (self.options.sessionRecoveryTimeout == 0):
                self.disposeWS()
                self.notifyStatus("DISCONNECTED:WILL-RETRY")
                self.cause = "ws.idle.timeout"
                self.state.goto_m_from_wp(113)
                self.exit_wp_to_m()
                self.entry_m113(com_lightstreamer_client_internal__ClientMachine_RetryCause.idle_timeout)
            else:
                self.disposeWS()
                self.notifyStatus("DISCONNECTED:TRYING-RECOVERY")
                self.cause = "ws.idle.timeout"
                pauseMs = self.randomGenerator(self.options.firstRetryMaxDelay)
                self.state.goto_rec_from_wp()
                self.exit_wp()
                self.entry_rec(pauseMs,com_lightstreamer_client_internal__ClientMachine_RetryCause.idle_timeout)
        else:
            tmp = None
            tmp1 = self.state.s_hp
            _g = (tmp1.m if ((tmp1 is not None)) else None)
            if (_g is None):
                tmp = False
            else:
                _g1 = _g
                if (((_g1 == 903) or ((_g1 == 901))) or ((_g1 == 900))):
                    tmp = True
                else:
                    tmp = False
            if tmp:
                if (self.options.sessionRecoveryTimeout == 0):
                    self.disposeHTTP()
                    self.notifyStatus("DISCONNECTED:WILL-RETRY")
                    self.cause = "http.idle.timeout"
                    self.state.goto_m_from_hp(112)
                    self.exit_hp_to_m()
                    self.entry_m112(com_lightstreamer_client_internal__ClientMachine_RetryCause.idle_timeout)
                else:
                    self.disposeHTTP()
                    self.notifyStatus("DISCONNECTED:TRYING-RECOVERY")
                    self.cause = "http.idle.timeout"
                    pauseMs = self.randomGenerator(self.options.firstRetryMaxDelay)
                    self.state.goto_rec_from_hp()
                    self.exit_hp_to_rec()
                    self.entry_rec(pauseMs,com_lightstreamer_client_internal__ClientMachine_RetryCause.idle_timeout)

    def evtPollingTimeout(self):
        self.traceEvent("polling.timeout")
        tmp = self.state.s_wp
        if (((tmp.p if ((tmp is not None)) else None)) == 612):
            self.sendBindWS_Polling()
            self.state.s_wp.p = 613
            self.state.traceState()
            self.cancel_evtPollingTimeout()
            self.schedule_evtIdleTimeout(com_lightstreamer_internal__Types_Millis_Impl_.plus(com_lightstreamer_internal_NullTools.sure(self.idleTimeout),self.options.retryDelay))
        else:
            tmp = self.state.s_hp
            if (((tmp.m if ((tmp is not None)) else None)) == 902):
                self.sendBindHTTP_Polling()
                self.state.s_hp.m = 903
                self.state.traceState()
                self.cancel_evtPollingTimeout()
                self.schedule_evtIdleTimeout(com_lightstreamer_internal__Types_Millis_Impl_.plus(com_lightstreamer_internal_NullTools.sure(self.idleTimeout),self.options.retryDelay))

    def evtKeepaliveTimeout(self):
        self.traceEvent("keepalive.timeout")
        tmp = self.state.s_w
        if (((tmp.k if ((tmp is not None)) else None)) == 310):
            self.state.s_w.k = 311
            self.state.traceState()
            self.cancel_evtKeepaliveTimeout()
            self.schedule_evtStalledTimeout(self.options.stalledTimeout)
        else:
            tmp = self.state.s_ws
            if (((tmp.k if ((tmp is not None)) else None)) == 520):
                self.state.s_ws.k = 521
                self.state.traceState()
                self.cancel_evtKeepaliveTimeout()
                self.schedule_evtStalledTimeout(self.options.stalledTimeout)
            else:
                tmp = self.state.s_hs
                if (((tmp.k if ((tmp is not None)) else None)) == 820):
                    self.state.s_hs.k = 821
                    self.state.traceState()
                    self.cancel_evtKeepaliveTimeout()
                    self.schedule_evtStalledTimeout(self.options.stalledTimeout)

    def evtStalledTimeout(self):
        self.traceEvent("stalled.timeout")
        tmp = self.state.s_w
        if (((tmp.k if ((tmp is not None)) else None)) == 311):
            self.state.s_w.k = 312
            self.state.traceState()
            self.cancel_evtStalledTimeout()
            self.schedule_evtReconnectTimeout(self.options.reconnectTimeout)
        else:
            tmp = self.state.s_ws
            if (((tmp.k if ((tmp is not None)) else None)) == 521):
                self.state.s_ws.k = 522
                self.state.traceState()
                self.cancel_evtStalledTimeout()
                self.schedule_evtReconnectTimeout(self.options.reconnectTimeout)
            else:
                tmp = self.state.s_hs
                if (((tmp.k if ((tmp is not None)) else None)) == 821):
                    self.state.s_hs.k = 822
                    self.state.traceState()
                    self.cancel_evtStalledTimeout()
                    self.schedule_evtReconnectTimeout(self.options.reconnectTimeout)

    def evtReconnectTimeout(self):
        self.traceEvent("reconnect.timeout")
        tmp = self.state.s_w
        if (((tmp.k if ((tmp is not None)) else None)) == 312):
            if (self.options.sessionRecoveryTimeout == 0):
                self.disposeWS()
                self.notifyStatus("DISCONNECTED:WILL-RETRY")
                self.cause = "ws.stalled"
                self.state.goto_m_from_w(113)
                self.exit_w_to_m()
                self.entry_m113(com_lightstreamer_client_internal__ClientMachine_RetryCause.stalled_timeout)
            else:
                self.disposeWS()
                self.notifyStatus("DISCONNECTED:TRYING-RECOVERY")
                self.cause = "ws.stalled"
                pauseMs = self.randomGenerator(self.options.firstRetryMaxDelay)
                self.state.goto_rec_from_w()
                self.exit_w()
                self.entry_rec(pauseMs,com_lightstreamer_client_internal__ClientMachine_RetryCause.stalled_timeout)
        else:
            tmp = self.state.s_ws
            if (((tmp.k if ((tmp is not None)) else None)) == 522):
                if (self.options.sessionRecoveryTimeout == 0):
                    self.disposeWS()
                    self.notifyStatus("DISCONNECTED:WILL-RETRY")
                    self.cause = "ws.stalled"
                    self.state.goto_m_from_ws(113)
                    self.exit_ws_to_m()
                    self.entry_m113(com_lightstreamer_client_internal__ClientMachine_RetryCause.stalled_timeout)
                else:
                    self.disposeWS()
                    self.notifyStatus("DISCONNECTED:TRYING-RECOVERY")
                    self.cause = "ws.stalled"
                    pauseMs = self.randomGenerator(self.options.firstRetryMaxDelay)
                    self.state.goto_rec_from_ws()
                    self.exit_ws()
                    self.entry_rec(pauseMs,com_lightstreamer_client_internal__ClientMachine_RetryCause.stalled_timeout)
            else:
                tmp = self.state.s_hs
                if (((tmp.k if ((tmp is not None)) else None)) == 822):
                    if (self.options.sessionRecoveryTimeout == 0):
                        self.disposeHTTP()
                        self.notifyStatus("DISCONNECTED:WILL-RETRY")
                        self.cause = "http.stalled"
                        self.state.goto_m_from_hs(113)
                        self.exit_hs_to_m()
                        self.entry_m113(com_lightstreamer_client_internal__ClientMachine_RetryCause.stalled_timeout)
                    else:
                        self.disposeHTTP()
                        self.notifyStatus("DISCONNECTED:TRYING-RECOVERY")
                        self.cause = "http.stalled"
                        pauseMs = self.randomGenerator(self.options.firstRetryMaxDelay)
                        self.state.goto_rec_from_hs()
                        self.exit_hs_to_rec()
                        self.entry_rec(pauseMs,com_lightstreamer_client_internal__ClientMachine_RetryCause.stalled_timeout)

    def evtRestartKeepalive(self):
        self.traceEvent("restart.keepalive")
        tmp = self.state.s_w
        if (((tmp.k if ((tmp is not None)) else None)) is not None):
            self.state.s_w.k = 310
            self.state.traceState()
            self.exit_keepalive_unit()
            self.schedule_evtKeepaliveTimeout(com_lightstreamer_internal_NullTools.sure(self.keepaliveInterval))
        else:
            tmp = self.state.s_ws
            if (((tmp.k if ((tmp is not None)) else None)) is not None):
                self.state.s_ws.k = 520
                self.state.traceState()
                self.exit_keepalive_unit()
                self.schedule_evtKeepaliveTimeout(com_lightstreamer_internal_NullTools.sure(self.keepaliveInterval))
            else:
                tmp = self.state.s_hs
                if (((tmp.k if ((tmp is not None)) else None)) is not None):
                    self.state.s_hs.k = 820
                    self.state.traceState()
                    self.exit_keepalive_unit()
                    self.schedule_evtKeepaliveTimeout(com_lightstreamer_internal_NullTools.sure(self.keepaliveInterval))

    def evtWSOK(self):
        self.traceEvent("WSOK")
        if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.protocolLogger.isDebugEnabled():
            com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.protocolLogger.debug("WSOK")
        _g = self.state.s_m
        if (_g == 121):
            self.state.s_m = 122
            self.state.traceState()
        elif (_g == 150):
            _g = self.state.s_tr
            if (_g is not None):
                if (_g == 240):
                    tmp = self.state.s_ws
                    _g = (tmp.m if ((tmp is not None)) else None)
                    if (_g is not None):
                        if (_g == 501):
                            self.state.s_ws.m = 502
                            self.state.traceState()
                elif (_g == 250):
                    tmp = self.state.s_wp
                    _g = (tmp.m if ((tmp is not None)) else None)
                    if (_g is not None):
                        if (_g == 601):
                            self.sendBindWS_FirstPolling()
                            self.state.s_wp.m = 602
                            self.state.s_wp.p = 610
                            self.state.s_wp.c = 620
                            self.state.s_wp.s = 630
                            self.state.traceState()
                            self.cancel_evtTransportTimeout()
                            self.evtSendPendingControls()
                            self.evtSendPendingMessages()
                            self.schedule_evtIdleTimeout(com_lightstreamer_internal__Types_Millis_Impl_.plus(com_lightstreamer_internal_NullTools.sure(self.idleTimeout),self.options.retryDelay))
                else:
                    pass
        else:
            pass

    def evtCONERR(self,code,msg):
        self.traceEvent("CONERR")
        if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.protocolLogger.isDebugEnabled():
            com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.protocolLogger.debug(((("CONERR " + Std.string(code)) + " ") + ("null" if msg is None else msg)))
        retryCause = com_lightstreamer_client_internal__ClientMachine_RetryCause.standardError(code,msg)
        terminationCause = com_lightstreamer_client_internal__ClientMachine_TerminationCause.TC_standardError(code,msg)
        if (self.state.s_m == 122):
            if (code == 5):
                self.disposeWS()
                self.notifyStatus("DISCONNECTED:WILL-RETRY")
                self.cause = ("ws.conerr." + Std.string(code))
                self.state.s_m = 110
                self.state.traceState()
                self.cancel_evtTransportTimeout()
                self.evtRetry(retryCause)
                self.evtRetryTimeout()
            elif ((((((code == 48) or ((code == 41))) or ((code == 40))) or ((code == 20))) or ((code == 6))) or ((code == 4))):
                self.disposeWS()
                self.notifyStatus("DISCONNECTED:WILL-RETRY")
                self.cause = ("ws.conerr." + Std.string(code))
                pauseMs = self.waitingInterval(self.delayCounter.get_currentRetryDelay(),self.connectTs)
                self.state.s_m = 112
                self.state.traceState()
                self.cancel_evtTransportTimeout()
                self.evtRetry(retryCause,pauseMs)
                self.schedule_evtRetryTimeout(pauseMs)
            else:
                self.disposeWS()
                self.notifyStatus("DISCONNECTED")
                self.notifyServerError_CONERR(code,msg)
                self.state.s_m = 100
                self.state.traceState()
                self.cancel_evtTransportTimeout()
                self.evtTerminate(terminationCause)
        elif (self.state.s_m == 130):
            if (code == 5):
                self.disposeHTTP()
                self.notifyStatus("DISCONNECTED:WILL-RETRY")
                self.cause = ("http.conerr." + Std.string(code))
                self.state.s_m = 110
                self.state.traceState()
                self.cancel_evtTransportTimeout()
                self.evtRetry(retryCause)
                self.evtRetryTimeout()
            elif ((((((code == 48) or ((code == 41))) or ((code == 40))) or ((code == 20))) or ((code == 6))) or ((code == 4))):
                self.disposeHTTP()
                self.notifyStatus("DISCONNECTED:WILL-RETRY")
                self.cause = ("http.conerr." + Std.string(code))
                pauseMs = self.waitingInterval(self.delayCounter.get_currentRetryDelay(),self.connectTs)
                self.state.s_m = 112
                self.state.traceState()
                self.cancel_evtTransportTimeout()
                self.evtRetry(retryCause,pauseMs)
                self.schedule_evtRetryTimeout(pauseMs)
            else:
                self.disposeHTTP()
                self.notifyStatus("DISCONNECTED")
                self.notifyServerError_CONERR(code,msg)
                self.state.s_m = 100
                self.state.traceState()
                self.cancel_evtTransportTimeout()
                self.evtTerminate(terminationCause)
        elif (self.state.s_m == 140):
            if (code == 5):
                self.disposeHTTP()
                self.notifyStatus("DISCONNECTED:WILL-RETRY")
                self.cause = ("ttl.conerr." + Std.string(code))
                self.state.s_m = 110
                self.state.traceState()
                self.cancel_evtTransportTimeout()
                self.evtRetry(retryCause)
                self.evtRetryTimeout()
            elif ((((((code == 48) or ((code == 41))) or ((code == 40))) or ((code == 20))) or ((code == 6))) or ((code == 4))):
                self.disposeHTTP()
                self.notifyStatus("DISCONNECTED:WILL-RETRY")
                self.cause = ("ttl.conerr." + Std.string(code))
                pauseMs = self.waitingInterval(self.delayCounter.get_currentRetryDelay(),self.connectTs)
                self.state.s_m = 112
                self.state.traceState()
                self.cancel_evtTransportTimeout()
                self.evtRetry(retryCause,pauseMs)
                self.schedule_evtRetryTimeout(pauseMs)
            else:
                self.disposeHTTP()
                self.notifyStatus("DISCONNECTED")
                self.notifyServerError_CONERR(code,msg)
                self.state.s_m = 100
                self.state.traceState()
                self.cancel_evtTransportTimeout()
                self.evtTerminate(terminationCause)
        else:
            tmp = self.state.s_ws
            if (((tmp.m if ((tmp is not None)) else None)) == 502):
                if ((((((code == 48) or ((code == 41))) or ((code == 40))) or ((code == 20))) or ((code == 6))) or ((code == 4))):
                    self.disposeWS()
                    self.notifyStatus("DISCONNECTED:WILL-RETRY")
                    self.cause = ("ws.conerr." + Std.string(code))
                    self.state.goto_m_from_ws(112)
                    self.exit_ws_to_m()
                    self.entry_m112(com_lightstreamer_client_internal__ClientMachine_RetryCause.standardError(code,msg))
                else:
                    self.disposeWS()
                    self.notifyStatus("DISCONNECTED")
                    self.notifyServerError_CONERR(code,msg)
                    self.state.goto_m_from_ws(100)
                    self.exit_ws_to_m()
                    self.evtTerminate(terminationCause)
            else:
                tmp = None
                tmp1 = self.state.s_wp
                if (((tmp1.p if ((tmp1 is not None)) else None)) != 610):
                    tmp1 = self.state.s_wp
                    tmp = (((tmp1.p if ((tmp1 is not None)) else None)) == 613)
                else:
                    tmp = True
                if tmp:
                    if ((((((code == 48) or ((code == 41))) or ((code == 40))) or ((code == 20))) or ((code == 6))) or ((code == 4))):
                        self.disposeWS()
                        self.notifyStatus("DISCONNECTED:WILL-RETRY")
                        self.cause = ("ws.conerr." + Std.string(code))
                        self.state.goto_m_from_wp(112)
                        self.exit_wp_to_m()
                        self.entry_m112(com_lightstreamer_client_internal__ClientMachine_RetryCause.standardError(code,msg))
                    else:
                        self.disposeWS()
                        self.notifyStatus("DISCONNECTED")
                        self.notifyServerError_CONERR(code,msg)
                        self.state.goto_m_from_wp(100)
                        self.exit_wp_to_m()
                        self.evtTerminate(terminationCause)
                else:
                    tmp = None
                    tmp1 = self.state.s_hs
                    if (((tmp1.m if ((tmp1 is not None)) else None)) != 800):
                        tmp1 = self.state.s_hs
                        tmp = (((tmp1.m if ((tmp1 is not None)) else None)) == 801)
                    else:
                        tmp = True
                    if tmp:
                        if ((((((code == 48) or ((code == 41))) or ((code == 40))) or ((code == 20))) or ((code == 6))) or ((code == 4))):
                            self.disposeHTTP()
                            self.notifyStatus("DISCONNECTED:WILL-RETRY")
                            self.cause = ("http.conerr." + Std.string(code))
                            self.state.goto_m_from_hs(112)
                            self.exit_hs_to_m()
                            self.entry_m112(com_lightstreamer_client_internal__ClientMachine_RetryCause.standardError(code,msg))
                        else:
                            self.disposeHTTP()
                            self.notifyStatus("DISCONNECTED")
                            self.notifyServerError_CONERR(code,msg)
                            self.state.goto_m_from_hs(100)
                            self.exit_hs_to_m()
                            self.evtTerminate(terminationCause)
                    else:
                        tmp = None
                        tmp1 = self.state.s_hp
                        if (((tmp1.m if ((tmp1 is not None)) else None)) != 900):
                            tmp1 = self.state.s_hp
                            tmp = (((tmp1.m if ((tmp1 is not None)) else None)) == 903)
                        else:
                            tmp = True
                        if tmp:
                            if ((((((code == 48) or ((code == 41))) or ((code == 40))) or ((code == 20))) or ((code == 6))) or ((code == 4))):
                                self.disposeHTTP()
                                self.notifyStatus("DISCONNECTED:WILL-RETRY")
                                self.cause = ("http.conerr." + Std.string(code))
                                self.state.goto_m_from_hp(112)
                                self.exit_hp_to_m()
                                self.entry_m112(com_lightstreamer_client_internal__ClientMachine_RetryCause.standardError(code,msg))
                            else:
                                self.disposeHTTP()
                                self.notifyStatus("DISCONNECTED")
                                self.notifyServerError_CONERR(code,msg)
                                self.state.goto_m_from_hp(100)
                                self.exit_hp_to_m()
                                self.evtTerminate(terminationCause)
                        elif (self.state.s_rec == 1001):
                            if ((((((code == 48) or ((code == 41))) or ((code == 40))) or ((code == 20))) or ((code == 6))) or ((code == 4))):
                                self.disposeHTTP()
                                self.notifyStatus("DISCONNECTED:WILL-RETRY")
                                self.cause = ("recovery.conerr." + Std.string(code))
                                self.state.goto_m_from_rec(113)
                                self.exit_rec_to_m()
                                self.entry_m113(retryCause)
                            else:
                                self.disposeHTTP()
                                self.notifyStatus("DISCONNECTED")
                                self.notifyServerError_CONERR(code,msg)
                                self.state.goto_m_from_rec(100)
                                self.exit_rec_to_m()
                                self.evtTerminate(terminationCause)

    def evtEND(self,code,msg):
        self.traceEvent("END")
        if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.protocolLogger.isDebugEnabled():
            com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.protocolLogger.debug(((("END " + Std.string(code)) + " ") + ("null" if msg is None else msg)))
        retryCause = com_lightstreamer_client_internal__ClientMachine_RetryCause.standardError(code,msg)
        terminationCause = com_lightstreamer_client_internal__ClientMachine_TerminationCause.TC_standardError(code,msg)
        tmp = self.state.s_w
        if (((tmp.p if ((tmp is not None)) else None)) == 300):
            if ((code == 48) or ((code == 41))):
                self.disposeWS()
                self.notifyStatus("DISCONNECTED:WILL-RETRY")
                self.cause = ("ws.end." + Std.string(code))
                pauseMs = self.randomGenerator(self.options.firstRetryMaxDelay)
                self.state.clear_w()
                self.state.goto_m_from_session(113)
                self.exit_w()
                self.evtEndSession()
                self.evtRetry(com_lightstreamer_client_internal__ClientMachine_RetryCause.standardError(code,msg),pauseMs)
                self.schedule_evtRetryTimeout(pauseMs)
            else:
                self.disposeWS()
                self.notifyStatus("DISCONNECTED")
                self.notifyServerError_END(code,msg)
                self.state.clear_w()
                self.state.goto_m_from_session(100)
                self.exit_w()
                self.evtEndSession()
                self.evtTerminate(terminationCause)
        else:
            tmp = self.state.s_ws
            if (((tmp.m if ((tmp is not None)) else None)) == 502):
                if ((code == 48) or ((code == 41))):
                    self.disposeWS()
                    self.notifyStatus("DISCONNECTED:WILL-RETRY")
                    self.cause = ("ws.end." + Std.string(code))
                    self.state.goto_m_from_ws(112)
                    self.exit_ws_to_m()
                    self.entry_m112(com_lightstreamer_client_internal__ClientMachine_RetryCause.standardError(code,msg))
                else:
                    self.disposeWS()
                    self.notifyStatus("DISCONNECTED")
                    self.notifyServerError_END(code,msg)
                    self.state.goto_m_from_ws(100)
                    self.exit_ws_to_m()
                    self.evtTerminate(terminationCause)
            else:
                tmp = self.state.s_ws
                if (((tmp.p if ((tmp is not None)) else None)) == 510):
                    if ((code == 48) or ((code == 41))):
                        self.disposeWS()
                        self.notifyStatus("DISCONNECTED:WILL-RETRY")
                        self.cause = ("ws.end." + Std.string(code))
                        self.state.goto_m_from_ws(113)
                        self.exit_ws_to_m()
                        self.entry_m113(retryCause)
                    else:
                        self.disposeWS()
                        self.notifyStatus("DISCONNECTED")
                        self.notifyServerError_END(code,msg)
                        self.state.goto_m_from_ws(100)
                        self.exit_ws_to_m()
                        self.evtTerminate(terminationCause)
                else:
                    tmp = None
                    tmp1 = self.state.s_wp
                    if (((tmp1.p if ((tmp1 is not None)) else None)) != 610):
                        tmp1 = self.state.s_wp
                        tmp = (((tmp1.p if ((tmp1 is not None)) else None)) == 613)
                    else:
                        tmp = True
                    if tmp:
                        if ((code == 48) or ((code == 41))):
                            self.disposeWS()
                            self.notifyStatus("DISCONNECTED:WILL-RETRY")
                            self.cause = ("ws.end." + Std.string(code))
                            self.state.goto_m_from_wp(112)
                            self.exit_wp_to_m()
                            self.entry_m112(com_lightstreamer_client_internal__ClientMachine_RetryCause.standardError(code,msg))
                        else:
                            self.disposeWS()
                            self.notifyStatus("DISCONNECTED")
                            self.notifyServerError_END(code,msg)
                            self.state.goto_m_from_wp(100)
                            self.exit_wp_to_m()
                            self.evtTerminate(terminationCause)
                    else:
                        tmp = self.state.s_wp
                        if (((tmp.p if ((tmp is not None)) else None)) == 611):
                            if ((code == 48) or ((code == 41))):
                                self.disposeWS()
                                self.notifyStatus("DISCONNECTED:WILL-RETRY")
                                self.cause = ("ws.end." + Std.string(code))
                                self.state.goto_m_from_wp(113)
                                self.exit_wp_to_m()
                                self.entry_m113(retryCause)
                            else:
                                self.disposeWS()
                                self.notifyStatus("DISCONNECTED")
                                self.notifyServerError_END(code,msg)
                                self.state.goto_m_from_wp(100)
                                self.exit_wp_to_m()
                                self.evtTerminate(terminationCause)
                        else:
                            tmp = None
                            tmp1 = self.state.s_hs
                            if (((tmp1.m if ((tmp1 is not None)) else None)) != 800):
                                tmp1 = self.state.s_hs
                                tmp = (((tmp1.m if ((tmp1 is not None)) else None)) == 801)
                            else:
                                tmp = True
                            if tmp:
                                if ((code == 48) or ((code == 41))):
                                    self.disposeHTTP()
                                    self.notifyStatus("DISCONNECTED:WILL-RETRY")
                                    self.cause = ("http.end." + Std.string(code))
                                    self.state.goto_m_from_hs(112)
                                    self.exit_hs_to_m()
                                    self.entry_m112(com_lightstreamer_client_internal__ClientMachine_RetryCause.standardError(code,msg))
                                else:
                                    self.disposeHTTP()
                                    self.notifyStatus("DISCONNECTED")
                                    self.notifyServerError_END(code,msg)
                                    self.state.goto_m_from_hs(100)
                                    self.exit_hs_to_m()
                                    self.evtTerminate(terminationCause)
                            else:
                                tmp = self.state.s_hs
                                if (((tmp.p if ((tmp is not None)) else None)) == 810):
                                    if ((code == 48) or ((code == 41))):
                                        self.disposeHTTP()
                                        self.notifyStatus("DISCONNECTED:WILL-RETRY")
                                        self.cause = ("http.end." + Std.string(code))
                                        self.state.goto_m_from_hs(113)
                                        self.exit_hs_to_m()
                                        self.entry_m113(retryCause)
                                    else:
                                        self.disposeHTTP()
                                        self.notifyStatus("DISCONNECTED")
                                        self.notifyServerError_END(code,msg)
                                        self.state.goto_m_from_hs(100)
                                        self.exit_hs_to_m()
                                        self.evtTerminate(terminationCause)
                                else:
                                    tmp = None
                                    tmp1 = self.state.s_hp
                                    if (((tmp1.m if ((tmp1 is not None)) else None)) != 900):
                                        tmp1 = self.state.s_hp
                                        tmp = (((tmp1.m if ((tmp1 is not None)) else None)) == 903)
                                    else:
                                        tmp = True
                                    if tmp:
                                        if ((code == 48) or ((code == 41))):
                                            self.disposeHTTP()
                                            self.notifyStatus("DISCONNECTED:WILL-RETRY")
                                            self.cause = ("http.end." + Std.string(code))
                                            self.state.goto_m_from_hp(112)
                                            self.exit_hp_to_m()
                                            self.entry_m112(com_lightstreamer_client_internal__ClientMachine_RetryCause.standardError(code,msg))
                                        else:
                                            self.disposeHTTP()
                                            self.notifyStatus("DISCONNECTED")
                                            self.notifyServerError_END(code,msg)
                                            self.state.goto_m_from_hp(100)
                                            self.exit_hp_to_m()
                                            self.evtTerminate(terminationCause)
                                    else:
                                        tmp = self.state.s_hp
                                        if (((tmp.m if ((tmp is not None)) else None)) == 901):
                                            if ((code == 48) or ((code == 41))):
                                                self.disposeHTTP()
                                                self.notifyStatus("DISCONNECTED:WILL-RETRY")
                                                self.cause = ("http.end." + Std.string(code))
                                                self.state.goto_m_from_hp(113)
                                                self.exit_hp_to_m()
                                                self.entry_m113(retryCause)
                                            else:
                                                self.disposeHTTP()
                                                self.notifyStatus("DISCONNECTED")
                                                self.notifyServerError_END(code,msg)
                                                self.state.goto_m_from_hp(100)
                                                self.exit_hp_to_m()
                                                self.evtTerminate(terminationCause)
                                        elif (self.state.s_rec == 1001):
                                            if ((code == 48) or ((code == 41))):
                                                self.disposeHTTP()
                                                self.notifyStatus("DISCONNECTED:WILL-RETRY")
                                                self.cause = ("recovery.end." + Std.string(code))
                                                self.state.goto_m_from_rec(113)
                                                self.exit_rec_to_m()
                                                self.entry_m113(retryCause)
                                            else:
                                                self.disposeHTTP()
                                                self.notifyStatus("DISCONNECTED")
                                                self.notifyServerError_END(code,msg)
                                                self.state.goto_m_from_rec(100)
                                                self.exit_rec_to_m()
                                                self.evtTerminate(terminationCause)

    def evtERROR(self,code,msg):
        self.traceEvent("ERROR")
        if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.protocolLogger.isDebugEnabled():
            com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.protocolLogger.debug(((("ERROR " + Std.string(code)) + " ") + ("null" if msg is None else msg)))
        terminationCause = com_lightstreamer_client_internal__ClientMachine_TerminationCause.TC_standardError(code,msg)
        tmp = self.state.s_w
        if (((tmp.p if ((tmp is not None)) else None)) == 300):
            self.disposeWS()
            self.notifyStatus("DISCONNECTED")
            self.notifyServerError_ERROR(code,msg)
            self.state.clear_w()
            self.state.goto_m_from_session(100)
            self.exit_w()
            self.evtEndSession()
            self.evtTerminate(terminationCause)
        else:
            tmp = self.state.s_ws
            if (((tmp.p if ((tmp is not None)) else None)) == 510):
                self.disposeWS()
                self.notifyStatus("DISCONNECTED")
                self.notifyServerError_ERROR(code,msg)
                self.state.goto_m_from_ws(100)
                self.exit_ws_to_m()
                self.evtTerminate(terminationCause)
            else:
                tmp = self.state.s_wp
                if (((tmp.c if ((tmp is not None)) else None)) == 620):
                    self.disposeWS()
                    self.notifyStatus("DISCONNECTED")
                    self.notifyServerError_ERROR(code,msg)
                    self.state.goto_m_from_wp(100)
                    self.exit_wp_to_m()
                    self.evtTerminate(terminationCause)
                elif (self.state.s_ctrl == 1102):
                    self.disposeHTTP()
                    self.notifyStatus("DISCONNECTED")
                    self.notifyServerError_ERROR(code,msg)
                    self.state.goto_m_from_ctrl(100)
                    self.exit_ctrl_to_m()
                    self.evtTerminate(terminationCause)

    def evtREQOK_withoutReqId(self):
        self.traceEvent("REQOK")
        if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.protocolLogger.isDebugEnabled():
            com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.protocolLogger.debug("REQOK")
        if (self.state.s_ctrl == 1102):
            self.state.s_ctrl = 1102
            self.state.traceState()

    def evtREQOK(self,reqId):
        self.traceEvent("REQOK")
        if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.protocolLogger.isDebugEnabled():
            com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.protocolLogger.debug(("REQOK " + Std.string(reqId)))
        forward = True
        if ((self.state.s_swt == 1302) and ((reqId == self.swt_lastReqId))):
            self.state.s_swt = 1303
            self.state.traceState()
            forward = self.evtREQOK_TransportRegion(reqId)
        elif ((self.state.s_bw == 1202) and ((reqId == self.bw_lastReqId))):
            self.state.s_bw = 1200
            self.state.traceState()
            forward = self.evtREQOK_TransportRegion(reqId)
            self.evtCheckBW()
        else:
            forward = self.evtREQOK_Forward(reqId)
        if forward:
            self.evtREQOK_TransportRegion(reqId)

    def evtREQOK_Forward(self,reqId):
        return True

    def evtREQOK_TransportRegion(self,reqId):
        tmp = self.state.s_w
        if (((tmp.p if ((tmp is not None)) else None)) == 300):
            self.state.s_w.p = 300
            self.state.traceState()
            self.doREQOK(reqId)
            self.evtRestartKeepalive()
        else:
            tmp = self.state.s_ws
            if (((tmp.p if ((tmp is not None)) else None)) == 510):
                self.state.s_ws.p = 510
                self.state.traceState()
                self.doREQOK(reqId)
                self.evtRestartKeepalive()
            else:
                tmp = self.state.s_wp
                if (((tmp.c if ((tmp is not None)) else None)) == 620):
                    self.state.s_wp.c = 620
                    self.state.traceState()
                    self.doREQOK(reqId)
                elif (self.state.s_ctrl == 1102):
                    self.state.s_ctrl = 1102
                    self.state.traceState()
                    self.doREQOK(reqId)
        return False

    def evtREQERR(self,reqId,code,msg):
        self.traceEvent("REQERR")
        if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.protocolLogger.isDebugEnabled():
            com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.protocolLogger.debug(((((("REQERR " + Std.string(reqId)) + " ") + Std.string(code)) + " ") + ("null" if msg is None else msg)))
        forward = True
        if ((self.state.s_swt == 1302) and ((reqId == self.swt_lastReqId))):
            self.state.s_swt = 1301
            self.state.traceState()
            forward = self.evtREQERR_TransportRegion(reqId,code,msg)
        elif ((self.state.s_bw == 1202) and ((reqId == self.bw_lastReqId))):
            self.state.s_bw = 1200
            self.state.traceState()
            forward = self.evtREQERR_TransportRegion(reqId,code,msg)
            self.evtCheckBW()
        else:
            forward = self.evtREQERR_Forward(reqId,code,msg)
        if forward:
            self.evtREQERR_TransportRegion(reqId,code,msg)

    def evtREQERR_Forward(self,reqId,code,msg):
        return True

    def evtREQERR_TransportRegion(self,reqId,code,msg):
        retryCause = com_lightstreamer_client_internal__ClientMachine_RetryCause.standardError(code,msg)
        terminationCause = com_lightstreamer_client_internal__ClientMachine_TerminationCause.TC_standardError(code,msg)
        tmp = self.state.s_w
        if (((tmp.p if ((tmp is not None)) else None)) == 300):
            if (code == 20):
                self.disposeWS()
                self.notifyStatus("DISCONNECTED:WILL-RETRY")
                self.cause = ("ws.reqerr." + Std.string(code))
                pauseMs = self.randomGenerator(self.options.firstRetryMaxDelay)
                self.state.clear_w()
                self.state.goto_m_from_session(113)
                self.exit_w()
                self.evtEndSession()
                self.evtRetry(com_lightstreamer_client_internal__ClientMachine_RetryCause.standardError(code,msg),pauseMs)
                self.schedule_evtRetryTimeout(pauseMs)
            elif (((code == 67) or ((code == 65))) or ((code == 11))):
                self.disposeWS()
                self.notifyStatus("DISCONNECTED")
                self.notifyServerError_REQERR(code,msg)
                self.state.clear_w()
                self.state.goto_m_from_session(100)
                self.exit_w()
                self.evtEndSession()
                self.evtTerminate(terminationCause)
            else:
                self.state.s_w.p = 300
                self.state.traceState()
                self.doREQERR(reqId,code,msg)
                self.evtRestartKeepalive()
        else:
            tmp = self.state.s_ws
            if (((tmp.p if ((tmp is not None)) else None)) == 510):
                if (code == 20):
                    self.disposeWS()
                    self.notifyStatus("DISCONNECTED:WILL-RETRY")
                    self.cause = (("ws.reqerr." + Std.string(code)) + ")")
                    self.state.goto_m_from_ws(113)
                    self.exit_ws_to_m()
                    self.entry_m113(retryCause)
                elif (((code == 67) or ((code == 65))) or ((code == 11))):
                    self.disposeWS()
                    self.notifyStatus("DISCONNECTED")
                    self.notifyServerError_REQERR(code,msg)
                    self.state.goto_m_from_ws(100)
                    self.exit_ws_to_m()
                    self.evtTerminate(terminationCause)
                else:
                    self.state.s_ws.p = 510
                    self.state.traceState()
                    self.doREQERR(reqId,code,msg)
                    self.evtRestartKeepalive()
            else:
                tmp = self.state.s_wp
                if (((tmp.c if ((tmp is not None)) else None)) == 620):
                    if (code == 20):
                        self.disposeWS()
                        self.notifyStatus("DISCONNECTED:WILL-RETRY")
                        self.cause = ("ws.reqerr." + Std.string(code))
                        self.state.goto_m_from_wp(113)
                        self.exit_wp_to_m()
                        self.entry_m113(retryCause)
                    elif (((code == 67) or ((code == 65))) or ((code == 11))):
                        self.disposeWS()
                        self.notifyStatus("DISCONNECTED")
                        self.notifyServerError_REQERR(code,msg)
                        self.state.goto_m_from_wp(100)
                        self.exit_wp_to_m()
                        self.evtTerminate(terminationCause)
                    else:
                        self.state.s_wp.c = 620
                        self.state.traceState()
                        self.doREQERR(reqId,code,msg)
                elif (self.state.s_ctrl == 1102):
                    if (code == 20):
                        self.disposeHTTP()
                        self.notifyStatus("DISCONNECTED:WILL-RETRY")
                        self.cause = ("http.reqerr." + Std.string(code))
                        self.state.goto_m_from_ctrl(113)
                        self.exit_ctrl_to_m()
                        self.entry_m113(retryCause)
                    elif (((code == 67) or ((code == 65))) or ((code == 11))):
                        self.disposeHTTP()
                        self.notifyStatus("DISCONNECTED")
                        self.notifyServerError_REQERR(code,msg)
                        self.state.goto_m_from_ctrl(100)
                        self.exit_ctrl_to_m()
                        self.evtTerminate(terminationCause)
                    else:
                        self.state.s_ctrl = 1102
                        self.state.traceState()
                        self.doREQERR(reqId,code,msg)
        return False

    def evtPROG(self,prog):
        self.traceEvent("PROG")
        retryCause = com_lightstreamer_client_internal__ClientMachine_RetryCause.prog_mismatch(self.rec_serverProg,prog)
        if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.protocolLogger.isDebugEnabled():
            com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.protocolLogger.debug(("PROG " + Std.string(prog)))
        tmp = self.state.s_w
        if (((tmp.p if ((tmp is not None)) else None)) == 300):
            if (prog != self.rec_serverProg):
                self.disposeWS()
                self.notifyStatus("DISCONNECTED:WILL-RETRY")
                self.cause = ((("prog.mismatch." + Std.string(prog)) + ".") + Std.string(self.rec_serverProg))
                self.state.clear_w()
                self.state.goto_m_from_session(113)
                self.exit_w()
                self.evtEndSession()
                self.entry_m113(retryCause)
            else:
                self.state.s_w.p = 300
                self.state.traceState()
                self.evtRestartKeepalive()
        elif (self.state.s_tr == 220):
            if (prog != self.rec_serverProg):
                self.disposeHTTP()
                self.notifyStatus("DISCONNECTED:WILL-RETRY")
                self.cause = ((("prog.mismatch." + Std.string(prog)) + ".") + Std.string(self.rec_serverProg))
                self.state.goto_m_from_session(113)
                self.cancel_evtTransportTimeout()
                self.evtEndSession()
                self.entry_m113(retryCause)
            else:
                self.state.s_tr = 220
                self.state.traceState()
        elif (self.state.s_tr == 230):
            if (prog != self.rec_serverProg):
                self.disposeHTTP()
                self.notifyStatus("DISCONNECTED:WILL-RETRY")
                self.cause = ((("prog.mismatch." + Std.string(prog)) + ".") + Std.string(self.rec_serverProg))
                self.state.goto_m_from_session(113)
                self.cancel_evtTransportTimeout()
                self.evtEndSession()
                self.entry_m113(retryCause)
            else:
                self.state.s_tr = 230
                self.state.traceState()
        else:
            tmp = self.state.s_ws
            if (((tmp.p if ((tmp is not None)) else None)) == 510):
                if (prog != self.rec_serverProg):
                    self.disposeWS()
                    self.notifyStatus("DISCONNECTED:WILL-RETRY")
                    self.cause = ((("prog.mismatch." + Std.string(prog)) + ".") + Std.string(self.rec_serverProg))
                    self.state.goto_m_from_ws(113)
                    self.exit_ws_to_m()
                    self.entry_m113(retryCause)
                else:
                    self.state.s_ws.p = 510
                    self.state.traceState()
                    self.evtRestartKeepalive()
            else:
                tmp = self.state.s_wp
                if (((tmp.p if ((tmp is not None)) else None)) == 611):
                    if (prog != self.rec_serverProg):
                        self.disposeWS()
                        self.notifyStatus("DISCONNECTED:WILL-RETRY")
                        self.cause = ((("prog.mismatch." + Std.string(prog)) + ".") + Std.string(self.rec_serverProg))
                        self.state.goto_m_from_wp(113)
                        self.exit_wp_to_m()
                        self.entry_m113(retryCause)
                    else:
                        self.state.s_wp.p = 611
                        self.state.traceState()
                else:
                    tmp = self.state.s_hs
                    if (((tmp.p if ((tmp is not None)) else None)) == 810):
                        if (prog != self.rec_serverProg):
                            self.disposeHTTP()
                            self.notifyStatus("DISCONNECTED:WILL-RETRY")
                            self.cause = ((("prog.mismatch." + Std.string(prog)) + ".") + Std.string(self.rec_serverProg))
                            self.state.goto_m_from_hs(113)
                            self.exit_hs_to_m()
                            self.entry_m113(retryCause)
                        else:
                            self.state.s_hs.p = 810
                            self.state.traceState()
                            self.evtRestartKeepalive()
                    else:
                        tmp = self.state.s_hp
                        if (((tmp.m if ((tmp is not None)) else None)) == 901):
                            if (prog != self.rec_serverProg):
                                self.disposeHTTP()
                                self.notifyStatus("DISCONNECTED:WILL-RETRY")
                                self.cause = ((("prog.mismatch." + Std.string(prog)) + ".") + Std.string(self.rec_serverProg))
                                self.state.goto_m_from_hp(113)
                                self.exit_hp_to_m()
                                self.entry_m113(retryCause)
                            else:
                                self.state.s_hp.m = 901
                                self.state.traceState()
                        elif (self.state.s_rec == 1001):
                            if (prog > self.rec_clientProg):
                                self.disposeHTTP()
                                self.notifyStatus("DISCONNECTED:WILL-RETRY")
                                self.cause = ((("prog.mismatch." + Std.string(prog)) + ".") + Std.string(self.rec_serverProg))
                                self.state.goto_m_from_rec(113)
                                self.exit_rec_to_m()
                                self.entry_m113(retryCause)
                            else:
                                self.state.s_rec = 1001
                                self.state.traceState()
                                self.doPROG(prog)

    def evtLOOP(self,pollingMs):
        self.traceEvent("LOOP")
        if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.protocolLogger.isDebugEnabled():
            com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.protocolLogger.debug(("LOOP " + Std.string(pollingMs)))
        tmp = self.state.s_w
        if (((tmp.p if ((tmp is not None)) else None)) == 300):
            self.closeWS()
            self.cause = "ws.loop"
            self.state.clear_w()
            self.state.s_tr = 200
            self.state.traceState()
            self.exit_w()
            self.evtSwitchTransport()
        elif (self.state.s_tr == 220):
            self.closeHTTP()
            self.cause = "http.loop"
            self.state.s_tr = 200
            self.state.traceState()
            self.cancel_evtTransportTimeout()
            self.evtSwitchTransport()
        elif (self.state.s_tr == 230):
            self.closeHTTP()
            self.cause = "ttl.loop"
            self.state.s_tr = 200
            self.state.traceState()
            self.cancel_evtTransportTimeout()
            self.evtSwitchTransport()
        else:
            tmp = self.state.s_ws
            if (((tmp.p if ((tmp is not None)) else None)) == 510):
                self.closeWS()
                self.cause = "ws.loop"
                self.state.clear_ws()
                self.state.s_tr = 200
                self.state.traceState()
                self.exit_ws()
                self.evtSwitchTransport()
            else:
                tmp = self.state.s_wp
                if (((tmp.p if ((tmp is not None)) else None)) == 611):
                    if self.isSwitching():
                        self.closeWS()
                        self.cause = "ws.loop"
                        self.state.clear_wp()
                        self.state.s_tr = 200
                        self.state.traceState()
                        self.exit_wp()
                        self.evtSwitchTransport()
                    else:
                        self.doLOOP(pollingMs)
                        self.state.s_wp.p = 612
                        self.state.traceState()
                        self.cancel_evtIdleTimeout()
                        self.schedule_evtPollingTimeout(self.options.pollingInterval)
                else:
                    tmp = self.state.s_hs
                    if (((tmp.p if ((tmp is not None)) else None)) == 810):
                        self.closeHTTP()
                        self.cause = "http.loop"
                        self.state.s_hs.p = 811
                        self.state.traceState()
                        self.evtSwitchTransport()
                    else:
                        tmp = self.state.s_hp
                        if (((tmp.m if ((tmp is not None)) else None)) == 901):
                            if self.isSwitching():
                                self.closeHTTP()
                                self.state.s_hp.m = 904
                                self.state.traceState()
                                self.cancel_evtIdleTimeout()
                                self.evtSwitchTransport()
                            else:
                                self.doLOOP(pollingMs)
                                self.closeHTTP()
                                self.state.s_hp.m = 902
                                self.state.traceState()
                                self.cancel_evtIdleTimeout()
                                self.schedule_evtPollingTimeout(self.options.pollingInterval)
                        elif (self.state.s_rec == 1001):
                            self.closeHTTP()
                            self.cause = "recovery.loop"
                            self.state.goto_200_from_rec()
                            self.exit_rec()
                            self.evtSwitchTransport()

    def evtCONOK(self,sessionId,reqLimit,keepalive,clink):
        self.traceEvent("CONOK")
        if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.protocolLogger.isDebugEnabled():
            com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.protocolLogger.debug(((((((("CONOK " + ("null" if sessionId is None else sessionId)) + " ") + Std.string(reqLimit)) + " ") + Std.string(keepalive)) + " ") + ("null" if clink is None else clink)))
        if (self.state.s_m == 122):
            self.doCONOK_CreateWS(sessionId,reqLimit,keepalive,clink)
            self.resetCurrentRetryDelay()
            self.notifyStatus("CONNECTED:WS-STREAMING")
            self.state.s_m = 150
            self.state.s_tr = 210
            self.state.s_w = com_lightstreamer_client_internal_StateVar_w(300,310,340)
            self.state.s_rhb = 320
            self.state.s_slw = 330
            self.state.s_swt = 1300
            self.state.s_bw = 1200
            self.state.traceState()
            self.cancel_evtTransportTimeout()
            self.evtSendPendingControls()
            self.evtSendPendingMessages()
            self.evtStartSession()
            self.schedule_evtKeepaliveTimeout(com_lightstreamer_internal_NullTools.sure(self.keepaliveInterval))
            self.evtSelectRhb()
            self.evtCheckTransport()
            self.evtCheckBW()
        elif (self.state.s_m == 130):
            self.doCONOK_CreateHTTP(sessionId,reqLimit,keepalive,clink)
            self.resetCurrentRetryDelay()
            self.notifyStatus("CONNECTED:STREAM-SENSING")
            self.state.s_m = 150
            self.state.s_tr = 220
            self.state.s_swt = 1300
            self.state.s_bw = 1200
            self.state.traceState()
            self.cancel_evtTransportTimeout()
            self.evtStartSession()
            self.schedule_evtTransportTimeout(self.options.retryDelay)
            self.evtCheckTransport()
            self.evtCheckBW()
        elif (self.state.s_m == 140):
            self.doCONOK_CreateHTTP(sessionId,reqLimit,keepalive,clink)
            self.resetCurrentRetryDelay()
            self.notifyStatus("CONNECTED:STREAM-SENSING")
            self.state.s_m = 150
            self.state.s_tr = 230
            self.state.s_swt = 1300
            self.state.s_bw = 1200
            self.state.traceState()
            self.cancel_evtTransportTimeout()
            self.evtStartSession()
            self.schedule_evtTransportTimeout(self.options.retryDelay)
            self.evtCheckTransport()
            self.evtCheckBW()
        else:
            tmp = self.state.s_ws
            if (((tmp.m if ((tmp is not None)) else None)) == 502):
                self.doCONOK_BindWS_Streaming(sessionId,reqLimit,keepalive,clink)
                self.notifyStatus("CONNECTED:WS-STREAMING")
                self.state.s_ws.m = 503
                self.state.s_ws.p = 510
                self.state.s_ws.k = 520
                self.state.s_ws.s = 550
                self.state.s_rhb = 320
                self.state.s_slw = 330
                self.state.traceState()
                self.cancel_evtTransportTimeout()
                self.evtSendPendingControls()
                self.evtSendPendingMessages()
                self.schedule_evtKeepaliveTimeout(com_lightstreamer_internal_NullTools.sure(self.keepaliveInterval))
                self.evtSelectRhb()
            else:
                tmp = self.state.s_wp
                if (((tmp.p if ((tmp is not None)) else None)) == 610):
                    self.doCONOK_BindWS_Polling(sessionId,reqLimit,keepalive,clink)
                    self.notifyStatus("CONNECTED:WS-POLLING")
                    self.state.s_wp.p = 611
                    self.state.traceState()
                else:
                    tmp = self.state.s_wp
                    if (((tmp.p if ((tmp is not None)) else None)) == 613):
                        self.doCONOK_BindWS_Polling(sessionId,reqLimit,keepalive,clink)
                        self.state.s_wp.p = 611
                        self.state.traceState()
                    else:
                        tmp = self.state.s_hs
                        if (((tmp.m if ((tmp is not None)) else None)) == 800):
                            self.doCONOK_BindHTTP_Streaming(sessionId,reqLimit,keepalive,clink)
                            self.notifyStatus("CONNECTED:HTTP-STREAMING")
                            self.state.s_hs.m = 802
                            self.state.s_hs.p = 810
                            self.state.s_hs.k = 820
                            self.state.s_rhb = 320
                            self.state.s_slw = 330
                            self.state.traceState()
                            self.cancel_evtTransportTimeout()
                            self.schedule_evtKeepaliveTimeout(com_lightstreamer_internal_NullTools.sure(self.keepaliveInterval))
                            self.evtSelectRhb()
                        else:
                            tmp = self.state.s_hs
                            if (((tmp.m if ((tmp is not None)) else None)) == 801):
                                self.doCONOK_BindHTTP_Streaming(sessionId,reqLimit,keepalive,clink)
                                self.notifyStatus("CONNECTED:HTTP-STREAMING")
                                self.state.s_hs.m = 802
                                self.state.s_hs.p = 810
                                self.state.s_hs.k = 820
                                self.state.s_rhb = 320
                                self.state.s_slw = 330
                                self.state.traceState()
                                self.cancel_evtTransportTimeout()
                                self.schedule_evtKeepaliveTimeout(com_lightstreamer_internal_NullTools.sure(self.keepaliveInterval))
                                self.evtSelectRhb()
                            else:
                                tmp = self.state.s_hp
                                if (((tmp.m if ((tmp is not None)) else None)) == 900):
                                    self.doCONOK_BindHTTP_Polling(sessionId,reqLimit,keepalive,clink)
                                    self.notifyStatus("CONNECTED:HTTP-POLLING")
                                    self.state.s_hp.m = 901
                                    self.state.traceState()
                                else:
                                    tmp = self.state.s_hp
                                    if (((tmp.m if ((tmp is not None)) else None)) == 903):
                                        self.doCONOK_BindHTTP_Polling(sessionId,reqLimit,keepalive,clink)
                                        self.state.s_hp.m = 901
                                        self.state.traceState()

    def evtSERVNAME(self,serverName):
        self.traceEvent("SERVNAME")
        if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.protocolLogger.isDebugEnabled():
            com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.protocolLogger.debug(("SERVNAME " + ("null" if serverName is None else serverName)))
        if self.state.inPushing():
            self.doSERVNAME(serverName)
            if self.state.inStreaming():
                self.evtRestartKeepalive()

    def evtCLIENTIP(self,clientIp):
        self.traceEvent("CLIENTIP")
        if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.protocolLogger.isDebugEnabled():
            com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.protocolLogger.debug(("CLIENTIP " + ("null" if clientIp is None else clientIp)))
        if self.state.inPushing():
            self.doCLIENTIP(clientIp)
            if self.state.inStreaming():
                self.evtRestartKeepalive()

    def evtCONS(self,bandwidth):
        self.traceEvent("CONS")
        if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.protocolLogger.isDebugEnabled():
            com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.protocolLogger.debug(("CONS " + Std.string(bandwidth)))
        if self.state.inPushing():
            self.doCONS(bandwidth)
            if self.state.inStreaming():
                self.evtRestartKeepalive()

    def evtPROBE(self):
        self.traceEvent("PROBE")
        if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.protocolLogger.isDebugEnabled():
            com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.protocolLogger.debug("PROBE")
        if self.state.inPushing():
            if self.state.inStreaming():
                self.evtRestartKeepalive()

    def evtNOOP(self):
        self.traceEvent("NOOP")
        if self.state.inPushing():
            if self.state.inStreaming():
                self.evtRestartKeepalive()

    def evtSYNC(self,seconds):
        self.traceEvent("SYNC")
        if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.protocolLogger.isDebugEnabled():
            com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.protocolLogger.debug(("SYNC " + Std.string(seconds)))
        forward = True
        tmp = None
        tmp1 = None
        tmp2 = self.state.s_w
        if (((tmp2.p if ((tmp2 is not None)) else None)) != 300):
            tmp2 = self.state.s_ws
            tmp1 = (((tmp2.p if ((tmp2 is not None)) else None)) == 510)
        else:
            tmp1 = True
        if (not tmp1):
            tmp1 = self.state.s_hs
            tmp = (((tmp1.p if ((tmp1 is not None)) else None)) == 810)
        else:
            tmp = True
        if tmp:
            forward = self.evtSYNC_PushingRegion(seconds)
            self.evtRestartKeepalive()
        else:
            tmp = None
            tmp1 = None
            if (not (((self.state.s_tr == 220) or ((self.state.s_tr == 230))))):
                tmp2 = self.state.s_wp
                tmp1 = (((tmp2.p if ((tmp2 is not None)) else None)) == 611)
            else:
                tmp1 = True
            if (not tmp1):
                tmp1 = self.state.s_hp
                tmp = (((tmp1.m if ((tmp1 is not None)) else None)) == 901)
            else:
                tmp = True
            if (tmp or ((self.state.s_rec == 1001))):
                forward = self.evtSYNC_PushingRegion(seconds)
        if forward:
            self.evtSYNC_PushingRegion(seconds)

    def evtSYNC_PushingRegion(self,seconds):
        syncMs = (seconds * 1000)
        if (self.state.s_slw is not None):
            _g = self.state.s_slw
            if (_g is not None):
                if (_g == 330):
                    self.doSYNC(syncMs)
                    self.state.s_slw = 331
                    self.state.traceState()
                elif (_g == 331):
                    result = self.doSYNC_G(syncMs)
                    self.state.s_slw = 332
                    self.state.traceState()
                    self.evtCheckAvg(result)
                elif (_g == 333):
                    result = self.doSYNC_NG(syncMs)
                    self.state.s_slw = 332
                    self.state.traceState()
                    self.evtCheckAvg(result)
                else:
                    pass
        return False

    def evtMSGDONE(self,sequence,prog,response):
        self.traceEvent("MSGDONE")
        if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.protocolLogger.isDebugEnabled():
            com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.protocolLogger.debug(((((("MSGDONE " + ("null" if sequence is None else sequence)) + " ") + Std.string(prog)) + " ") + ("null" if response is None else response)))
        if self.state.inPushing():
            if self.isFreshData():
                self.doMSGDONE(sequence,prog,response)
                if self.state.inStreaming():
                    self.evtRestartKeepalive()
            else:
                self.onStaleData()
                if self.state.inStreaming():
                    self.evtRestartKeepalive()

    def evtMSGFAIL(self,sequence,prog,errorCode,errorMsg):
        self.traceEvent("MSGFAIL")
        if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.protocolLogger.isDebugEnabled():
            com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.protocolLogger.debug(((((((("MSGFAIL " + ("null" if sequence is None else sequence)) + " ") + Std.string(prog)) + " ") + Std.string(errorCode)) + " ") + ("null" if errorMsg is None else errorMsg)))
        if self.state.inPushing():
            if self.isFreshData():
                self.doMSGFAIL(sequence,prog,errorCode,errorMsg)
                if self.state.inStreaming():
                    self.evtRestartKeepalive()
            else:
                self.onStaleData()
                if self.state.inStreaming():
                    self.evtRestartKeepalive()

    def evtU(self,subId,itemIdx,values,rawValue):
        self.traceEvent("U")
        if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.protocolLogger.isDebugEnabled():
            com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.protocolLogger.debug(("" + ("null" if rawValue is None else rawValue)))
        if self.state.inPushing():
            if self.isFreshData():
                self.doU(subId,itemIdx,values)
                if self.state.inStreaming():
                    self.evtRestartKeepalive()
            else:
                self.onStaleData()
                if self.state.inStreaming():
                    self.evtRestartKeepalive()

    def evtSUBOK(self,subId,nItems,nFields):
        self.traceEvent("SUBOK")
        if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.protocolLogger.isDebugEnabled():
            com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.protocolLogger.debug(((((("SUBOK " + Std.string(subId)) + " ") + Std.string(nItems)) + " ") + Std.string(nFields)))
        if self.state.inPushing():
            if self.isFreshData():
                self.doSUBOK(subId,nItems,nFields)
                if self.state.inStreaming():
                    self.evtRestartKeepalive()
            else:
                self.onStaleData()
                if self.state.inStreaming():
                    self.evtRestartKeepalive()

    def evtSUBCMD(self,subId,nItems,nFields,keyIdx,cmdIdx):
        self.traceEvent("SUBCMD")
        if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.protocolLogger.isDebugEnabled():
            com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.protocolLogger.debug(((((((((("SUBCMD " + Std.string(subId)) + " ") + Std.string(nItems)) + " ") + Std.string(nFields)) + " ") + Std.string(keyIdx)) + " ") + Std.string(cmdIdx)))
        if self.state.inPushing():
            if self.isFreshData():
                self.doSUBCMD(subId,nItems,nFields,keyIdx,cmdIdx)
                if self.state.inStreaming():
                    self.evtRestartKeepalive()
            else:
                self.onStaleData()
                if self.state.inStreaming():
                    self.evtRestartKeepalive()

    def evtUNSUB(self,subId):
        self.traceEvent("UNSUB")
        if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.protocolLogger.isDebugEnabled():
            com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.protocolLogger.debug(("UNSUB " + Std.string(subId)))
        if self.state.inPushing():
            if self.isFreshData():
                self.doUNSUB(subId)
                if self.state.inStreaming():
                    self.evtRestartKeepalive()
            else:
                self.onStaleData()
                if self.state.inStreaming():
                    self.evtRestartKeepalive()

    def evtEOS(self,subId,itemIdx):
        self.traceEvent("EOS")
        if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.protocolLogger.isDebugEnabled():
            com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.protocolLogger.debug(((("EOS " + Std.string(subId)) + " ") + Std.string(itemIdx)))
        if self.state.inPushing():
            if self.isFreshData():
                self.doEOS(subId,itemIdx)
                if self.state.inStreaming():
                    self.evtRestartKeepalive()
            else:
                self.onStaleData()
                if self.state.inStreaming():
                    self.evtRestartKeepalive()

    def evtCS(self,subId,itemIdx):
        self.traceEvent("CS")
        if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.protocolLogger.isDebugEnabled():
            com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.protocolLogger.debug(((("CS " + Std.string(subId)) + " ") + Std.string(itemIdx)))
        if self.state.inPushing():
            if self.isFreshData():
                self.doCS(subId,itemIdx)
                if self.state.inStreaming():
                    self.evtRestartKeepalive()
            else:
                self.onStaleData()
                if self.state.inStreaming():
                    self.evtRestartKeepalive()

    def evtOV(self,subId,itemIdx,lostUpdates):
        self.traceEvent("OV")
        if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.protocolLogger.isDebugEnabled():
            com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.protocolLogger.debug(((((("OV " + Std.string(subId)) + " ") + Std.string(itemIdx)) + " ") + Std.string(lostUpdates)))
        if self.state.inPushing():
            if self.isFreshData():
                self.doOV(subId,itemIdx,lostUpdates)
                if self.state.inStreaming():
                    self.evtRestartKeepalive()
            else:
                self.onStaleData()
                if self.state.inStreaming():
                    self.evtRestartKeepalive()

    def evtCONF(self,subId,freq):
        self.traceEvent("CONF")
        if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.protocolLogger.isDebugEnabled():
            com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.protocolLogger.debug(((("CONF " + Std.string(subId)) + " ") + Std.string(freq)))
        if self.state.inPushing():
            if self.isFreshData():
                self.doCONF(subId,freq)
                if self.state.inStreaming():
                    self.evtRestartKeepalive()
            else:
                self.onStaleData()
                if self.state.inStreaming():
                    self.evtRestartKeepalive()

    def evtCheckAvg(self,result):
        self.traceEvent("check.avg")
        if (self.state.s_slw == 332):
            tmp = result.index
            if (tmp == 0):
                self.state.s_slw = 331
                self.state.traceState()
            elif (tmp == 1):
                self.state.s_slw = 333
                self.state.traceState()
            elif (tmp == 2):
                self.disableStreaming()
                self.cause = "slow"
                self.state.s_slw = 334
                self.state.traceState()
                self.evtForcePolling()
            else:
                pass

    def evtSendPendingControls(self):
        self.traceEvent("send.pending.controls")
        controls = self.getPendingControls()
        tmp = self.state.s_w
        if ((((tmp.s if ((tmp is not None)) else None)) == 340) and (not Lambda.empty(controls))):
            self.sendPengingControlsWS(controls)
            self.state.s_w.s = 340
            self.state.traceState()
            self.evtRestartHeartbeat()
        else:
            tmp = self.state.s_ws
            if ((((tmp.s if ((tmp is not None)) else None)) == 550) and (not Lambda.empty(controls))):
                self.sendPengingControlsWS(controls)
                self.state.s_ws.s = 550
                self.state.traceState()
                self.evtRestartHeartbeat()
            else:
                tmp = self.state.s_wp
                if ((((tmp.s if ((tmp is not None)) else None)) == 630) and (not Lambda.empty(controls))):
                    self.sendPengingControlsWS(controls)
                    self.state.s_wp.s = 630
                    self.state.traceState()

    def evtSendPendingMessages(self):
        self.traceEvent("send.pending.messages")
        tmp = self.state.s_w
        def _hx_local_0(msg):
            return msg.isPending()
        if ((((tmp.s if ((tmp is not None)) else None)) == 340) and Lambda.exists(self.messageManagers,_hx_local_0)):
            self.sendPendingMessagesWS()
            self.state.s_w.s = 340
            self.state.traceState()
            self.genAckMessagesWS()
            self.evtRestartHeartbeat()
        else:
            tmp = self.state.s_ws
            def _hx_local_1(msg):
                return msg.isPending()
            if ((((tmp.s if ((tmp is not None)) else None)) == 550) and Lambda.exists(self.messageManagers,_hx_local_1)):
                self.sendPendingMessagesWS()
                self.state.s_ws.s = 550
                self.state.traceState()
                self.genAckMessagesWS()
                self.evtRestartHeartbeat()
            else:
                tmp = self.state.s_wp
                def _hx_local_2(msg):
                    return msg.isPending()
                if ((((tmp.s if ((tmp is not None)) else None)) == 630) and Lambda.exists(self.messageManagers,_hx_local_2)):
                    self.sendPendingMessagesWS()
                    self.state.s_wp.s = 630
                    self.state.traceState()
                    self.genAckMessagesWS()

    def evtSelectRhb(self):
        self.traceEvent("select.rhb")
        if (self.state.s_rhb == 320):
            if (self.rhb_grantedInterval == 0):
                if (self.options.reverseHeartbeatInterval == 0):
                    self.state.s_rhb = 321
                    self.state.traceState()
                else:
                    self.rhb_currentInterval = self.options.reverseHeartbeatInterval
                    self.state.s_rhb = 322
                    self.state.traceState()
                    self.schedule_evtRhbTimeout(self.rhb_currentInterval)
            elif ((self.options.reverseHeartbeatInterval > 0) and ((self.options.reverseHeartbeatInterval < com_lightstreamer_internal_NullTools.sure(self.rhb_grantedInterval)))):
                self.rhb_currentInterval = self.options.reverseHeartbeatInterval
                self.state.s_rhb = 323
                self.state.traceState()
                self.schedule_evtRhbTimeout(self.rhb_currentInterval)
            else:
                self.rhb_currentInterval = self.rhb_grantedInterval
                self.state.s_rhb = 323
                self.state.traceState()
                self.schedule_evtRhbTimeout(com_lightstreamer_internal_NullTools.sure(self.rhb_currentInterval))

    def evtExtSetReverseHeartbeatInterval(self):
        self.traceEvent("setReverseHeartbeatInterval")
        if (self.state.s_rhb is not None):
            _g = self.state.s_rhb
            if (_g is not None):
                if (_g == 321):
                    if (self.options.reverseHeartbeatInterval != 0):
                        self.rhb_currentInterval = self.options.reverseHeartbeatInterval
                        self.state.s_rhb = 322
                        self.state.traceState()
                        self.schedule_evtRhbTimeout(self.rhb_currentInterval)
                elif (_g == 322):
                    if (self.options.reverseHeartbeatInterval == 0):
                        self.state.s_rhb = 321
                        self.state.traceState()
                        self.cancel_evtRhbTimeout()
                    else:
                        self.rhb_currentInterval = self.options.reverseHeartbeatInterval
                        self.state.s_rhb = 322
                        self.state.traceState()
                elif (_g == 323):
                    if ((self.options.reverseHeartbeatInterval > 0) and ((self.options.reverseHeartbeatInterval < com_lightstreamer_internal_NullTools.sure(self.rhb_grantedInterval)))):
                        self.rhb_currentInterval = self.options.reverseHeartbeatInterval
                        self.state.s_rhb = 323
                        self.state.traceState()
                    else:
                        self.rhb_currentInterval = self.rhb_grantedInterval
                        self.state.s_rhb = 323
                        self.state.traceState()
                else:
                    pass

    def evtRestartHeartbeat(self):
        self.traceEvent("restart.heartbeat")
        if (self.state.s_rhb is not None):
            _g = self.state.s_rhb
            if (_g is not None):
                if (_g == 322):
                    self.state.s_rhb = 322
                    self.state.traceState()
                    self.cancel_evtRhbTimeout()
                    self.schedule_evtRhbTimeout(com_lightstreamer_internal_NullTools.sure(self.rhb_currentInterval))
                elif (_g == 323):
                    self.state.s_rhb = 323
                    self.state.traceState()
                    self.cancel_evtRhbTimeout()
                    self.schedule_evtRhbTimeout(com_lightstreamer_internal_NullTools.sure(self.rhb_currentInterval))
                elif (_g == 324):
                    if (self.rhb_grantedInterval == 0):
                        if (self.options.reverseHeartbeatInterval != 0):
                            self.rhb_currentInterval = self.options.reverseHeartbeatInterval
                            self.state.s_rhb = 322
                            self.state.traceState()
                            self.schedule_evtRhbTimeout(self.rhb_currentInterval)
                        else:
                            self.state.s_rhb = 321
                            self.state.traceState()
                    elif ((self.options.reverseHeartbeatInterval > 0) and ((self.options.reverseHeartbeatInterval < com_lightstreamer_internal_NullTools.sure(self.rhb_grantedInterval)))):
                        self.rhb_currentInterval = self.options.reverseHeartbeatInterval
                        self.state.s_rhb = 323
                        self.state.traceState()
                        self.schedule_evtRhbTimeout(self.rhb_currentInterval)
                    else:
                        self.rhb_currentInterval = self.rhb_grantedInterval
                        self.state.s_rhb = 323
                        self.state.traceState()
                        self.schedule_evtRhbTimeout(com_lightstreamer_internal_NullTools.sure(self.rhb_currentInterval))
                else:
                    pass

    def evtRhbTimeout(self):
        self.traceEvent("rhb.timeout")
        if (self.state.s_rhb == 322):
            self.state.s_rhb = 324
            self.state.traceState()
            self.cancel_evtRhbTimeout()
            self.evtSendHeartbeat()
        elif (self.state.s_rhb == 323):
            self.state.s_rhb = 324
            self.state.traceState()
            self.cancel_evtRhbTimeout()
            self.evtSendHeartbeat()

    def evtDisposeCtrl(self):
        self.traceEvent("du:dispose.ctrl")
        self.disposeCtrl()

    def evtStartRecovery(self):
        self.traceEvent("start.recovery")
        if (self.state.s_rec == 1000):
            self.recoverTs = python_lib_Timeit.default_timer()
            self.state.s_rec = 1000
            self.state.traceState()

    def evtRecoveryTimeout(self):
        self.traceEvent("recovery.timeout")
        if (self.state.s_rec == 1000):
            self.sendRecovery()
            self.state.s_rec = 1001
            self.state.traceState()
            self.cancel_evtRecoveryTimeout()
            self.schedule_evtTransportTimeout(self.options.retryDelay)

    def evtCheckRecoveryTimeout(self,retryCause):
        self.traceEvent("check.recovery.timeout")
        if (self.state.s_rec == 1002):
            retryDelayMs = self.options.retryDelay
            if (com_lightstreamer_internal__Timer_TimerStamp_Impl_.plus(self.connectTs,retryDelayMs) < com_lightstreamer_internal__Timer_TimerStamp_Impl_.plus(self.recoverTs,self.options.sessionRecoveryTimeout)):
                self.cause = "recovery.error"
                diffMs = com_lightstreamer_internal__Timer_TimerStamp_Impl_.minus(python_lib_Timeit.default_timer(),self.connectTs)
                pauseMs = (com_lightstreamer_internal__Types_Millis_Impl_.minus(retryDelayMs,com_lightstreamer_internal__Timer_TimerMillis_Impl_.toMillis(diffMs)) if ((retryDelayMs > com_lightstreamer_internal__Timer_TimerMillis_Impl_.toMillis(diffMs))) else com_lightstreamer_internal__Types_Millis_Impl_.ZERO)
                self.state.s_rec = 1003
                self.state.traceState()
                if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.sessionLogger.isErrorEnabled():
                    if (pauseMs > 0):
                        if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.sessionLogger.isErrorEnabled():
                            com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.sessionLogger.error(((("Retrying recovery in " + Std.string(pauseMs)) + "ms. Cause: ") + Std.string(retryCause)))
                    elif com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.sessionLogger.isErrorEnabled():
                        com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.sessionLogger.error(("Retrying recovery. Cause: " + Std.string(retryCause)))
                self.schedule_evtRetryTimeout(pauseMs)
            else:
                self.notifyStatus("DISCONNECTED:WILL-RETRY")
                self.cause = "recovery.timeout"
                self.state.goto_m_from_rec(113)
                self.exit_rec_to_m()
                self.entry_m113(com_lightstreamer_client_internal__ClientMachine_RetryCause.recovery_timeout)

    def evtCreate(self):
        self.traceEvent("du:create")
        if (self.state.s_du == 20):
            self.state.s_du = 21
            self.state.traceState()
        elif (self.state.s_du == 23):
            self.state.s_du = 21
            self.state.traceState()

    def evtCheckTransport(self):
        self.traceEvent("check.transport")
        if (self.state.s_swt == 1300):
            if (((self.state.s_tr == 220) or ((self.state.s_tr == 230))) or ((self.state.s_tr == 260))):
                self.state.s_swt = 1301
                self.state.traceState()
            else:
                best = self.getBestForBinding()
                if (((((best == com_lightstreamer_client_internal__ClientMachine_BestForBindingEnum.BFB_ws_streaming) and (((self.state.s_tr == 210) or ((self.state.s_tr == 240))))) or ((((best == com_lightstreamer_client_internal__ClientMachine_BestForBindingEnum.BFB_http_streaming) and ((self.state.s_tr == 270))) and ((self.state.s_h == 710))))) or (((best == com_lightstreamer_client_internal__ClientMachine_BestForBindingEnum.BFB_ws_polling) and ((self.state.s_tr == 250))))) or ((((best == com_lightstreamer_client_internal__ClientMachine_BestForBindingEnum.BFB_http_polling) and ((self.state.s_tr == 270))) and ((self.state.s_h == 720))))):
                    self.state.s_swt = 1301
                    self.state.traceState()
                else:
                    self.state.s_swt = 1302
                    self.state.traceState()
                    self.evtSendControl(com_lightstreamer_internal_NullTools.sure(self.switchRequest))

    def evtCheckBW(self):
        self.traceEvent("check.bw")
        if (self.state.s_bw == 1200):
            if ((self.bw_requestedMaxBandwidth != self.options.requestedMaxBandwidth) and ((self.options.realMaxBandwidth != com_lightstreamer_internal_RealMaxBandwidth.BWUnmanaged))):
                self.bw_requestedMaxBandwidth = self.options.requestedMaxBandwidth
                self.state.s_bw = 1202
                self.state.traceState()
                self.evtSendControl(com_lightstreamer_internal_NullTools.sure(self.constrainRequest))
            else:
                self.state.s_bw = 1201
                self.state.traceState()

    def evtCheckCtrlRequests(self):
        self.traceEvent("check.ctrl.requests")
        if (self.state.s_ctrl == 1100):
            controls = self.getPendingControls()
            if (not Lambda.empty(controls)):
                self.sendPendingControlsHTTP(controls)
                self.state.s_ctrl = 1102
                self.state.traceState()
                self.evtRestartHeartbeat()
                self.schedule_evtCtrlTimeout(self.options.retryDelay)
            else:
                def _hx_local_0(msg):
                    return msg.isPending()
                if Lambda.exists(self.messageManagers,_hx_local_0):
                    self.sendPendingMessagesHTTP()
                    self.state.s_ctrl = 1102
                    self.state.traceState()
                    self.evtRestartHeartbeat()
                    self.schedule_evtCtrlTimeout(self.options.retryDelay)
                elif (self.state.s_rhb == 324):
                    self.sendHeartbeatHTTP()
                    self.state.s_ctrl = 1102
                    self.state.traceState()
                    self.evtRestartHeartbeat()
                    self.schedule_evtCtrlTimeout(self.options.retryDelay)
                else:
                    self.state.s_ctrl = 1101
                    self.state.traceState()

    def evtCtrlDone(self):
        self.traceEvent("ctrl.done")
        if (self.state.s_ctrl == 1102):
            self.closeCtrl()
            self.state.s_ctrl = 1100
            self.state.traceState()
            self.cancel_evtCtrlTimeout()
            self.evtCheckCtrlRequests()

    def evtCtrlError(self):
        self.traceEvent("ctrl.error")
        if (self.state.s_ctrl == 1102):
            self.disposeCtrl()
            pauseMs = self.waitingInterval(self.options.retryDelay,self.ctrl_connectTs)
            self.state.s_ctrl = 1103
            self.state.traceState()
            self.cancel_evtCtrlTimeout()
            self.schedule_evtCtrlTimeout(pauseMs)

    def evtCtrlTimeout(self):
        self.traceEvent("ctrl.timeout")
        if (self.state.s_ctrl is not None):
            if (self.state.s_ctrl == 1102):
                self.disposeCtrl()
                pauseMs = self.waitingInterval(self.options.retryDelay,self.ctrl_connectTs)
                self.state.s_ctrl = 1103
                self.state.traceState()
                self.cancel_evtCtrlTimeout()
                self.schedule_evtCtrlTimeout(pauseMs)
            elif (self.state.s_ctrl == 1103):
                self.state.s_ctrl = 1100
                self.state.traceState()
                self.cancel_evtCtrlTimeout()
                self.evtCheckCtrlRequests()

    def evtSendControl(self,request):
        _gthis = self
        def _hx_local_0():
            _gthis.traceEvent("send.control")
            tmp = _gthis.state.s_w
            if (((tmp.s if ((tmp is not None)) else None)) == 340):
                _gthis.sendControlWS(request)
                _gthis.state.s_w.s = 340
                _gthis.state.traceState()
                _gthis.evtRestartHeartbeat()
            else:
                tmp = _gthis.state.s_ws
                if (((tmp.s if ((tmp is not None)) else None)) == 550):
                    _gthis.sendControlWS(request)
                    _gthis.state.s_ws.s = 550
                    _gthis.state.traceState()
                    _gthis.evtRestartHeartbeat()
                else:
                    tmp = _gthis.state.s_wp
                    if (((tmp.s if ((tmp is not None)) else None)) == 630):
                        _gthis.sendControlWS(request)
                        _gthis.state.s_wp.s = 630
                        _gthis.state.traceState()
                    elif (_gthis.state.s_ctrl == 1101):
                        _gthis.state.s_ctrl = 1100
                        _gthis.state.traceState()
                        _gthis.evtCheckCtrlRequests()
        self.lock.synchronized(_hx_local_0)

    def evtSendHeartbeat(self):
        self.traceEvent("send.heartbeat")
        tmp = self.state.s_w
        if (((tmp.s if ((tmp is not None)) else None)) == 340):
            self.sendHeartbeatWS()
            self.state.s_w.s = 340
            self.state.traceState()
            self.evtRestartHeartbeat()
        else:
            tmp = self.state.s_ws
            if (((tmp.s if ((tmp is not None)) else None)) == 550):
                self.sendHeartbeatWS()
                self.state.s_ws.s = 550
                self.state.traceState()
                self.evtRestartHeartbeat()
            elif (self.state.s_ctrl == 1101):
                self.state.s_ctrl = 1100
                self.state.traceState()
                self.evtCheckCtrlRequests()

    def evtStartSession(self):
        self.traceEvent("du:start.session")
        if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.sessionLogger.isInfoEnabled():
            com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.sessionLogger.info(("Starting new session: " + HxOverrides.stringOrNull(self.sessionId)))
        if (self.state.s_du == 21):
            self.state.s_du = 22
            self.state.traceState()

    def evtEndSession(self):
        if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.sessionLogger.isInfoEnabled():
            com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.sessionLogger.info(("Destroying session: " + HxOverrides.stringOrNull(self.sessionId)))

    def evtRetry(self,retryCause,timeout = None):
        self.traceEvent("du:retry")
        if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.sessionLogger.isErrorEnabled():
            if ((timeout is not None) and ((timeout > 0))):
                if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.sessionLogger.isErrorEnabled():
                    com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.sessionLogger.error(((("Retrying connection in " + Std.string(timeout)) + "ms. Cause: ") + HxOverrides.stringOrNull(com_lightstreamer_client_internal__ClientMachine_ClientMachine_Fields_.asErrorMsg(retryCause))))
            elif com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.sessionLogger.isErrorEnabled():
                com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.sessionLogger.error(("Retrying connection. Cause: " + HxOverrides.stringOrNull(com_lightstreamer_client_internal__ClientMachine_ClientMachine_Fields_.asErrorMsg(retryCause))))
        forward = True
        _g = self.state.s_du
        if (_g == 21):
            self.resetSequenceMap()
            self.state.s_du = 23
            self.state.traceState()
            forward = self.evtRetry_NextRegion()
            self.genAbortMessages()
        elif (_g == 22):
            self.disposeSession()
            self.state.s_du = 23
            self.state.traceState()
            forward = self.evtRetry_NextRegion()
            self.genAbortSubscriptions()
            self.genAbortMessages()
        else:
            pass
        if forward:
            self.evtRetry_NextRegion()

    def evtRetry_NextRegion(self):
        return False

    def evtTerminate(self,terminationCause):
        self.traceEvent("du:terminate")
        if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.sessionLogger.isInfoEnabled():
            if (terminationCause.index == 2):
                if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.sessionLogger.isInfoEnabled():
                    com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.sessionLogger.info("Disconnected. Cause: Requested by user")
        if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.sessionLogger.isErrorEnabled():
            tmp = terminationCause.index
            if (tmp == 0):
                if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.sessionLogger.isErrorEnabled():
                    com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.sessionLogger.error(((("Disconnected. Cause: " + Std.string(terminationCause.params[0])) + " - ") + HxOverrides.stringOrNull(terminationCause.params[1])))
            elif (tmp == 1):
                if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.sessionLogger.isErrorEnabled():
                    com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.sessionLogger.error(("Disconnected. Cause: " + HxOverrides.stringOrNull(terminationCause.params[0])))
            elif (tmp == 2):
                pass
            else:
                pass
        forward = True
        _g = self.state.s_du
        if (_g == 20):
            self.disposeClient()
            self.doUnistallPageLifecycle()
            self.state.s_du = 20
            self.state.traceState()
            forward = self.evtTerminate_NextRegion()
            self.genAbortMessages()
        elif (_g == 21):
            self.disposeClient()
            self.doUnistallPageLifecycle()
            self.state.s_du = 20
            self.state.traceState()
            forward = self.evtTerminate_NextRegion()
            self.genAbortMessages()
        elif (_g == 22):
            self.disposeSession()
            self.disposeClient()
            self.doUnistallPageLifecycle()
            self.state.s_du = 20
            self.state.traceState()
            forward = self.evtTerminate_NextRegion()
            self.genAbortSubscriptions()
            self.genAbortMessages()
        elif (_g == 23):
            self.disposeClient()
            self.doUnistallPageLifecycle()
            self.state.s_du = 20
            self.state.traceState()
            forward = self.evtTerminate_NextRegion()
            self.genAbortMessages()
        else:
            pass
        if forward:
            self.evtTerminate_NextRegion()

    def evtTerminate_NextRegion(self):
        return self.evtTerminate_NetworkReachabilityRegion()

    def evtTerminate_NetworkReachabilityRegion(self):
        _g = self.state.s_nr
        if (((_g == 1412) or ((_g == 1411))) or ((_g == 1410))):
            rm = self.nr_reachabilityManager
            self.nr_reachabilityManager = None
            self.state.s_nr = 1400
            self.state.traceState()
            if (rm is not None):
                rm.stopListening()
        else:
            pass
        return False

    def evtRetryTimeout(self):
        self.traceEvent("retry.timeout")
        _g = self.state.s_m
        if (_g == 110):
            self.notifyStatus("CONNECTING")
            self.sendCreateTTL()
            self.state.s_m = 140
            self.state.traceState()
            self.evtCreate()
            self.schedule_evtTransportTimeout(60000)
        elif (_g == 111):
            self.notifyStatus("CONNECTING")
            self.delayCounter.increase()
            self.sendCreateTTL()
            self.state.s_m = 140
            self.state.traceState()
            self.cancel_evtRetryTimeout()
            self.evtCreate()
            self.schedule_evtTransportTimeout(60000)
        elif (_g == 112):
            self.delayCounter.increase()
            self.state.s_m = 116
            self.state.traceState()
            self.cancel_evtRetryTimeout()
            self.evtSelectCreate()
        elif (_g == 113):
            self.state.s_m = 116
            self.state.traceState()
            self.cancel_evtRetryTimeout()
            self.evtSelectCreate()
        elif (_g == 115):
            self.state.s_m = 116
            self.state.traceState()
            self.evtSelectCreate()
        elif (_g == 150):
            if (self.state.s_rec == 1003):
                self.sendRecovery()
                self.state.s_rec = 1001
                self.state.traceState()
                self.cancel_evtRetryTimeout()
                self.schedule_evtTransportTimeout(self.options.retryDelay)
        else:
            pass

    def evtExtSetForcedTransport(self):
        self.traceEvent("setForcedTransport")
        if (self.state.s_swt == 1301):
            self.state.s_swt = 1300
            self.state.traceState()
            self.evtCheckTransport()

    def evtExtSetRequestedMaxBandwidth(self):
        self.traceEvent("setRequestedMaxBandwidth")
        if (self.state.s_bw == 1201):
            self.state.s_bw = 1200
            self.state.traceState()
            self.evtCheckBW()

    def evtForceSlowing(self):
        self.traceEvent("force.slowing")
        if (self.state.s_swt == 1301):
            self.state.s_swt = 1300
            self.state.traceState()
            self.evtCheckTransport()

    def evtForcePolling(self):
        self.traceEvent("force.polling")
        if (self.state.s_swt == 1301):
            self.state.s_swt = 1300
            self.state.traceState()
            self.evtCheckTransport()

    def evtSendMessage(self,msg):
        _gthis = self
        def _hx_local_0():
            _gthis.traceEvent("send.message")
            tmp = _gthis.state.s_w
            if (((tmp.s if ((tmp is not None)) else None)) == 340):
                _gthis.sendMsgWS(msg)
                _gthis.state.s_w.s = 340
                _gthis.state.traceState()
                msg.evtWSSent()
                _gthis.evtRestartHeartbeat()
            else:
                tmp = _gthis.state.s_ws
                if (((tmp.s if ((tmp is not None)) else None)) == 550):
                    _gthis.sendMsgWS(msg)
                    _gthis.state.s_ws.s = 550
                    _gthis.state.traceState()
                    msg.evtWSSent()
                    _gthis.evtRestartHeartbeat()
                else:
                    tmp = _gthis.state.s_wp
                    if (((tmp.s if ((tmp is not None)) else None)) == 630):
                        _gthis.sendMsgWS(msg)
                        _gthis.state.s_wp.s = 630
                        _gthis.state.traceState()
                        msg.evtWSSent()
                    elif (_gthis.state.s_ctrl == 1101):
                        _gthis.state.s_ctrl = 1100
                        _gthis.state.traceState()
                        _gthis.evtCheckCtrlRequests()
        self.lock.synchronized(_hx_local_0)

    def evtSwitchTransport(self):
        self.traceEvent("switch.transport")
        forward = True
        if ((self.state.s_swt == 1302) or ((self.state.s_swt == 1303))):
            self.state.s_swt = 1300
            self.state.traceState()
            forward = self.evtSwitchTransport_forwardToTransportRegion()
            self.evtCheckTransport()
        if forward:
            self.evtSwitchTransport_forwardToTransportRegion()

    def evtSwitchTransport_forwardToTransportRegion(self):
        terminationCause = com_lightstreamer_client_internal__ClientMachine_TerminationCause.TC_otherError((("Selected transport " + Std.string(self.options.forcedTransport)) + " is not available"))
        if (self.state.s_tr == 200):
            tmp = self.getBestForBinding().index
            if (tmp == 0):
                self.notifyStatus("DISCONNECTED")
                self.state.goto_m_from_session(100)
                self.evtEndSession()
                self.evtTerminate(terminationCause)
            elif (tmp == 1):
                self.openWS_Bind()
                self.state.s_tr = 240
                self.state.s_ws = com_lightstreamer_client_internal_StateVar_ws(500)
                self.state.traceState()
                self.schedule_evtTransportTimeout(self.options.retryDelay)
            elif (tmp == 2):
                self.openWS_Bind()
                self.state.s_tr = 250
                self.state.s_wp = com_lightstreamer_client_internal_StateVar_wp(600)
                self.state.traceState()
                self.schedule_evtTransportTimeout(self.options.retryDelay)
            elif (tmp == 3):
                self.sendBindHTTP_Streaming()
                self.state.s_tr = 270
                self.state.s_h = 710
                self.state.s_hs = com_lightstreamer_client_internal_StateVar_hs(800)
                self.state.s_ctrl = 1100
                self.state.traceState()
                self.evtCheckCtrlRequests()
                self.schedule_evtTransportTimeout(self.options.retryDelay)
            elif (tmp == 4):
                self.sendBindHTTP_Polling()
                self.state.s_tr = 270
                self.state.s_h = 720
                self.state.s_hp = com_lightstreamer_client_internal_StateVar_hp(900)
                self.state.s_rhb = 320
                self.state.s_ctrl = 1100
                self.state.traceState()
                self.evtCheckCtrlRequests()
                self.schedule_evtIdleTimeout(com_lightstreamer_internal__Types_Millis_Impl_.plus(com_lightstreamer_internal_NullTools.sure(self.idleTimeout),self.options.retryDelay))
                self.evtSelectRhb()
            else:
                pass
        else:
            tmp = self.state.s_hs
            if (((tmp.p if ((tmp is not None)) else None)) == 811):
                tmp = self.getBestForBinding().index
                if (tmp == 0):
                    self.notifyStatus("DISCONNECTED")
                    self.state.goto_m_from_hs(100)
                    self.exit_hs_to_m()
                    self.evtTerminate(terminationCause)
                elif (tmp == 1):
                    self.openWS_Bind()
                    self.state.clear_hs()
                    self.state.s_h = None
                    self.state.s_ctrl = None
                    self.state.s_tr = 240
                    self.state.s_ws = com_lightstreamer_client_internal_StateVar_ws(500)
                    self.state.traceState()
                    self.exit_hs()
                    self.exit_ctrl()
                    self.schedule_evtTransportTimeout(self.options.retryDelay)
                elif (tmp == 2):
                    self.openWS_Bind()
                    self.state.clear_hs()
                    self.state.s_h = None
                    self.state.s_ctrl = None
                    self.state.s_tr = 250
                    self.state.s_wp = com_lightstreamer_client_internal_StateVar_wp(600)
                    self.state.traceState()
                    self.exit_hs()
                    self.exit_ctrl()
                    self.schedule_evtTransportTimeout(self.options.retryDelay)
                elif (tmp == 3):
                    self.sendBindHTTP_Streaming()
                    self.state.s_hs = com_lightstreamer_client_internal_StateVar_hs(800)
                    self.state.traceState()
                    self.exit_hs()
                    self.schedule_evtTransportTimeout(self.options.retryDelay)
                elif (tmp == 4):
                    self.sendBindHTTP_Polling()
                    self.state.clear_hs()
                    self.state.s_h = 720
                    self.state.s_hp = com_lightstreamer_client_internal_StateVar_hp(900)
                    self.state.s_rhb = 320
                    self.state.traceState()
                    self.exit_hs()
                    self.schedule_evtIdleTimeout(com_lightstreamer_internal__Types_Millis_Impl_.plus(com_lightstreamer_internal_NullTools.sure(self.idleTimeout),self.options.retryDelay))
                    self.evtSelectRhb()
                else:
                    pass
            else:
                tmp = self.state.s_hp
                if (((tmp.m if ((tmp is not None)) else None)) == 904):
                    tmp = self.getBestForBinding().index
                    if (tmp == 0):
                        self.notifyStatus("DISCONNECTED")
                        self.state.goto_m_from_hp(100)
                        self.exit_hp_to_m()
                        self.evtTerminate(terminationCause)
                    elif (tmp == 1):
                        self.openWS_Bind()
                        self.state.clear_hp()
                        self.state.s_h = None
                        self.state.s_ctrl = None
                        self.state.s_tr = 240
                        self.state.s_ws = com_lightstreamer_client_internal_StateVar_ws(500)
                        self.state.traceState()
                        self.exit_hp()
                        self.exit_ctrl()
                        self.schedule_evtTransportTimeout(self.options.retryDelay)
                    elif (tmp == 2):
                        self.openWS_Bind()
                        self.state.clear_hp()
                        self.state.s_h = None
                        self.state.s_ctrl = None
                        self.state.s_tr = 250
                        self.state.s_wp = com_lightstreamer_client_internal_StateVar_wp(600)
                        self.state.traceState()
                        self.exit_hp()
                        self.exit_ctrl()
                        self.schedule_evtTransportTimeout(self.options.retryDelay)
                    elif (tmp == 3):
                        self.sendBindHTTP_Streaming()
                        self.state.clear_hp()
                        self.state.s_h = 710
                        self.state.s_hs = com_lightstreamer_client_internal_StateVar_hs(800)
                        self.state.traceState()
                        self.exit_hp()
                        self.schedule_evtTransportTimeout(self.options.retryDelay)
                    elif (tmp == 4):
                        self.sendBindHTTP_Polling()
                        self.state.s_hp = com_lightstreamer_client_internal_StateVar_hp(900)
                        self.state.s_rhb = 320
                        self.state.traceState()
                        self.exit_hp()
                        self.schedule_evtIdleTimeout(com_lightstreamer_internal__Types_Millis_Impl_.plus(com_lightstreamer_internal_NullTools.sure(self.idleTimeout),self.options.retryDelay))
                        self.evtSelectRhb()
                    else:
                        pass
        return False

    def onFreshData(self):
        if (self.rec_serverProg != self.rec_clientProg):
            raise com_lightstreamer_internal_IllegalStateException(("Assertion failure: " + "rec_serverProg == rec_clientProg"))
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.rec_serverProg
        _hx_local_0.rec_serverProg = (_hx_local_1 + 1)
        _hx_local_0.rec_serverProg
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.rec_clientProg
        _hx_local_2.rec_clientProg = (_hx_local_3 + 1)
        _hx_local_2.rec_clientProg

    def onStaleData(self):
        if (self.rec_serverProg >= self.rec_clientProg):
            raise com_lightstreamer_internal_IllegalStateException(("Assertion failure: " + "rec_serverProg < rec_clientProg"))
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.rec_serverProg
        _hx_local_0.rec_serverProg = (_hx_local_1 + 1)
        _hx_local_0.rec_serverProg

    def isFreshData(self):
        return (self.rec_serverProg == self.rec_clientProg)

    def openWS(self,url,headers):
        _gthis = self
        def _hx_local_2(client):
            def _hx_local_1():
                def _hx_local_0():
                    if client.isDisposed():
                        return
                    _gthis.evtWSOpen()
                _gthis.lock.synchronized(_hx_local_0)
            com_lightstreamer_internal__Threads_Threads_Fields_.sessionThread.loop.call_soon_threadsafe(_hx_local_1)
        onOpen = _hx_local_2
        def _hx_local_5(client,line):
            def _hx_local_4():
                def _hx_local_3():
                    if client.isDisposed():
                        return
                    try:
                        _gthis.evtMessage(line)
                    except BaseException as _g:
                        _g1 = haxe_Exception.caught(_g)
                        if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.sessionLogger.isErrorEnabled():
                            com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.sessionLogger.error(((("" + HxOverrides.stringOrNull(_g1.get_message())) + "\n") + HxOverrides.stringOrNull(_g1.details())))
                        _gthis.evtExtDisconnect(com_lightstreamer_client_internal__ClientMachine_TerminationCause.TC_standardError(61,_g1.get_message()))
                _gthis.lock.synchronized(_hx_local_3)
            com_lightstreamer_internal__Threads_Threads_Fields_.sessionThread.loop.call_soon_threadsafe(_hx_local_4)
        onText = _hx_local_5
        def _hx_local_8(client,error):
            def _hx_local_7():
                def _hx_local_6():
                    if client.isDisposed():
                        return
                    _gthis.evtTransportError()
                _gthis.lock.synchronized(_hx_local_6)
            com_lightstreamer_internal__Threads_Threads_Fields_.sessionThread.loop.call_soon_threadsafe(_hx_local_7)
        onError = _hx_local_8
        return self.wsFactory(url,headers,onOpen,onText,onError)

    def openWS_Create(self):
        self.connectTs = python_lib_Timeit.default_timer()
        self.serverInstanceAddress = self.getServerAddress()
        self.ws = self.openWS(com_lightstreamer_internal_Url.build(self.serverInstanceAddress,"lightstreamer"),self.options.httpExtraHeaders)

    def openWS_Bind(self):
        self.connectTs = python_lib_Timeit.default_timer()
        self.ws = self.openWS(com_lightstreamer_internal_Url.build(com_lightstreamer_internal_NullTools.sure(self.serverInstanceAddress),"lightstreamer"),self.getHeadersForRequestOtherThanCreate())

    def sendCreateWS(self):
        req = com_lightstreamer_internal_RequestBuilder()
        if (self.options.keepaliveInterval > 0):
            req.LS_keepalive_millis(self.options.keepaliveInterval)
        self.rhb_grantedInterval = self.options.reverseHeartbeatInterval
        if (self.rhb_grantedInterval > 0):
            req.LS_inactivity_millis(self.rhb_grantedInterval)
        self.bw_requestedMaxBandwidth = self.options.requestedMaxBandwidth
        _g = self.bw_requestedMaxBandwidth
        if (_g is not None):
            if (_g.index == 0):
                req.LS_requested_max_bandwidth_Float(_g.params[0])
        if (self.details.adapterSet is not None):
            req.LS_adapter_set(self.details.adapterSet)
        if (self.details.user is not None):
            req.LS_user(self.details.user)
        req.LS_cid(com_lightstreamer_internal__Constants_Constants_Fields_.LS_CID)
        if (self.sessionId is not None):
            req.LS_old_session(self.sessionId)
        if (not self.options.slowingEnabled):
            req.LS_send_sync(False)
        if (self.cause is not None):
            req.LS_cause(self.cause)
            self.cause = None
        if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.protocolLogger.isInfoEnabled():
            com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.protocolLogger.info(("Sending session create: " + Std.string(req)))
        if (self.details.password is not None):
            req.LS_password(self.details.password)
        com_lightstreamer_internal_NullTools.sure(self.ws).send("wsok")
        com_lightstreamer_internal_NullTools.sure(self.ws).send(("create_session\r\n" + HxOverrides.stringOrNull(req.getEncodedString())))

    def sendBindWS_Streaming(self):
        req = com_lightstreamer_internal_RequestBuilder()
        req.LS_session(com_lightstreamer_internal_NullTools.sure(self.sessionId))
        if (self.options.keepaliveInterval > 0):
            req.LS_keepalive_millis(self.options.keepaliveInterval)
        self.rhb_grantedInterval = self.options.reverseHeartbeatInterval
        if (self.rhb_grantedInterval > 0):
            req.LS_inactivity_millis(self.rhb_grantedInterval)
        if (not self.options.slowingEnabled):
            req.LS_send_sync(False)
        if (self.cause is not None):
            req.LS_cause(self.cause)
            self.cause = None
        if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.protocolLogger.isInfoEnabled():
            com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.protocolLogger.info(("Sending session bind: " + Std.string(req)))
        com_lightstreamer_internal_NullTools.sure(self.ws).send("wsok")
        com_lightstreamer_internal_NullTools.sure(self.ws).send(("bind_session\r\n" + HxOverrides.stringOrNull(req.getEncodedString())))

    def sendBindWS_FirstPolling(self):
        req = com_lightstreamer_internal_RequestBuilder()
        req.LS_session(com_lightstreamer_internal_NullTools.sure(self.sessionId))
        req.LS_polling(True)
        req.LS_polling_millis(self.options.pollingInterval)
        self.idleTimeout = self.options.idleTimeout
        req.LS_idle_millis(self.idleTimeout)
        if (self.cause is not None):
            req.LS_cause(self.cause)
            self.cause = None
        if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.protocolLogger.isInfoEnabled():
            com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.protocolLogger.info(("Sending session bind: " + Std.string(req)))
        com_lightstreamer_internal_NullTools.sure(self.ws).send(("bind_session\r\n" + HxOverrides.stringOrNull(req.getEncodedString())))

    def sendBindWS_Polling(self):
        req = com_lightstreamer_internal_RequestBuilder()
        req.LS_polling(True)
        req.LS_polling_millis(self.options.pollingInterval)
        self.idleTimeout = self.options.idleTimeout
        req.LS_idle_millis(self.idleTimeout)
        if (self.cause is not None):
            req.LS_cause(self.cause)
            self.cause = None
        if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.protocolLogger.isInfoEnabled():
            com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.protocolLogger.info(("Sending session bind: " + Std.string(req)))
        com_lightstreamer_internal_NullTools.sure(self.ws).send(("bind_session\r\n" + HxOverrides.stringOrNull(req.getEncodedString())))

    def sendDestroyWS(self,cause = None):
        if (cause is None):
            cause = "api"
        req = com_lightstreamer_internal_RequestBuilder()
        req.LS_reqId(self.generateFreshReqId())
        req.LS_op("destroy")
        req.LS_close_socket(True)
        req.LS_cause(cause)
        if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.protocolLogger.isInfoEnabled():
            com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.protocolLogger.info(("Sending session destroy: " + Std.string(req)))
        com_lightstreamer_internal_NullTools.sure(self.ws).send(("control\r\n" + HxOverrides.stringOrNull(req.getEncodedString())))

    def sendHttpRequest(self,url,req,headers):
        _gthis = self
        def _hx_local_2(client,line):
            def _hx_local_1():
                def _hx_local_0():
                    if client.isDisposed():
                        return
                    try:
                        _gthis.evtMessage(line)
                    except BaseException as _g:
                        _g1 = haxe_Exception.caught(_g)
                        if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.sessionLogger.isErrorEnabled():
                            com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.sessionLogger.error(((("" + HxOverrides.stringOrNull(_g1.get_message())) + "\n") + HxOverrides.stringOrNull(_g1.details())))
                        _gthis.evtExtDisconnect(com_lightstreamer_client_internal__ClientMachine_TerminationCause.TC_standardError(61,_g1.get_message()))
                _gthis.lock.synchronized(_hx_local_0)
            com_lightstreamer_internal__Threads_Threads_Fields_.sessionThread.loop.call_soon_threadsafe(_hx_local_1)
        onText = _hx_local_2
        def _hx_local_5(client,error):
            def _hx_local_4():
                def _hx_local_3():
                    if client.isDisposed():
                        return
                    _gthis.evtTransportError()
                _gthis.lock.synchronized(_hx_local_3)
            com_lightstreamer_internal__Threads_Threads_Fields_.sessionThread.loop.call_soon_threadsafe(_hx_local_4)
        onError = _hx_local_5
        def _hx_local_7():
            def _hx_local_6(client):
                pass
            return self.httpFactory(url,req.getEncodedString(),headers,onText,onError,_hx_local_6)
        return _hx_local_7()

    def sendCreateHTTP(self):
        req = com_lightstreamer_internal_RequestBuilder()
        req.LS_polling(True)
        req.LS_polling_millis(0)
        req.LS_idle_millis(0)
        self.bw_requestedMaxBandwidth = self.options.requestedMaxBandwidth
        _g = self.bw_requestedMaxBandwidth
        if (_g is not None):
            if (_g.index == 0):
                req.LS_requested_max_bandwidth_Float(_g.params[0])
        if (self.details.adapterSet is not None):
            req.LS_adapter_set(self.details.adapterSet)
        if (self.details.user is not None):
            req.LS_user(self.details.user)
        req.LS_cid(com_lightstreamer_internal__Constants_Constants_Fields_.LS_CID)
        if (self.sessionId is not None):
            req.LS_old_session(self.sessionId)
        if (self.cause is not None):
            req.LS_cause(self.cause)
            self.cause = None
        if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.protocolLogger.isInfoEnabled():
            com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.protocolLogger.info(("Sending session create: " + Std.string(req)))
        if (self.details.password is not None):
            req.LS_password(self.details.password)
        self.connectTs = python_lib_Timeit.default_timer()
        self.serverInstanceAddress = self.getServerAddress()
        self.http = self.sendHttpRequest(com_lightstreamer_internal_Url.build(self.serverInstanceAddress,((("/lightstreamer" + HxOverrides.stringOrNull(com_lightstreamer_internal__Constants_Constants_Fields_.LS_CREATE_REALM)) + "/create_session.txt?LS_protocol=") + HxOverrides.stringOrNull(com_lightstreamer_internal__Constants_Constants_Fields_.TLCP_VERSION))),req,self.options.httpExtraHeaders)

    def sendBindHTTP_Streaming(self):
        req = com_lightstreamer_internal_RequestBuilder()
        req.LS_session(com_lightstreamer_internal_NullTools.sure(self.sessionId))
        req.LS_content_length(self.options.contentLength)
        if (self.options.keepaliveInterval > 0):
            req.LS_keepalive_millis(self.options.keepaliveInterval)
        self.rhb_grantedInterval = self.options.reverseHeartbeatInterval
        if (self.rhb_grantedInterval > 0):
            req.LS_inactivity_millis(self.rhb_grantedInterval)
        if (not self.options.slowingEnabled):
            req.LS_send_sync(False)
        if (self.cause is not None):
            req.LS_cause(self.cause)
            self.cause = None
        if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.protocolLogger.isInfoEnabled():
            com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.protocolLogger.info(("Sending session bind: " + Std.string(req)))
        self.connectTs = python_lib_Timeit.default_timer()
        self.http = self.sendHttpRequest(com_lightstreamer_internal_Url.build(com_lightstreamer_internal_NullTools.sure(self.serverInstanceAddress),("/lightstreamer/bind_session.txt?LS_protocol=" + HxOverrides.stringOrNull(com_lightstreamer_internal__Constants_Constants_Fields_.TLCP_VERSION))),req,self.getHeadersForRequestOtherThanCreate())

    def sendBindHTTP_Polling(self):
        req = com_lightstreamer_internal_RequestBuilder()
        req.LS_session(com_lightstreamer_internal_NullTools.sure(self.sessionId))
        req.LS_polling(True)
        req.LS_polling_millis(self.options.pollingInterval)
        self.idleTimeout = self.options.idleTimeout
        req.LS_idle_millis(self.idleTimeout)
        if (self.cause is not None):
            req.LS_cause(self.cause)
            self.cause = None
        self.rhb_grantedInterval = 0
        if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.protocolLogger.isInfoEnabled():
            com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.protocolLogger.info(("Sending session bind: " + Std.string(req)))
        self.connectTs = python_lib_Timeit.default_timer()
        self.http = self.sendHttpRequest(com_lightstreamer_internal_Url.build(com_lightstreamer_internal_NullTools.sure(self.serverInstanceAddress),("/lightstreamer/bind_session.txt?LS_protocol=" + HxOverrides.stringOrNull(com_lightstreamer_internal__Constants_Constants_Fields_.TLCP_VERSION))),req,self.getHeadersForRequestOtherThanCreate())

    def sendCreateTTL(self):
        req = com_lightstreamer_internal_RequestBuilder()
        req.LS_ttl_millis("unlimited")
        req.LS_polling(True)
        req.LS_polling_millis(0)
        req.LS_idle_millis(0)
        self.bw_requestedMaxBandwidth = self.options.requestedMaxBandwidth
        _g = self.bw_requestedMaxBandwidth
        if (_g is not None):
            if (_g.index == 0):
                req.LS_requested_max_bandwidth_Float(_g.params[0])
        if (self.details.adapterSet is not None):
            req.LS_adapter_set(self.details.adapterSet)
        if (self.details.user is not None):
            req.LS_user(self.details.user)
        req.LS_cid(com_lightstreamer_internal__Constants_Constants_Fields_.LS_CID)
        if (self.sessionId is not None):
            req.LS_old_session(self.sessionId)
        if (self.cause is not None):
            req.LS_cause(self.cause)
            self.cause = None
        if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.protocolLogger.isInfoEnabled():
            com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.protocolLogger.info(("Sending session create: " + Std.string(req)))
        if (self.details.password is not None):
            req.LS_password(self.details.password)
        self.connectTs = python_lib_Timeit.default_timer()
        self.serverInstanceAddress = self.getServerAddress()
        self.http = self.sendHttpRequest(com_lightstreamer_internal_Url.build(self.serverInstanceAddress,((("/lightstreamer" + HxOverrides.stringOrNull(com_lightstreamer_internal__Constants_Constants_Fields_.LS_CREATE_REALM)) + "/create_session.txt?LS_protocol=") + HxOverrides.stringOrNull(com_lightstreamer_internal__Constants_Constants_Fields_.TLCP_VERSION))),req,self.options.httpExtraHeaders)

    def sendRecovery(self):
        req = com_lightstreamer_internal_RequestBuilder()
        req.LS_session(com_lightstreamer_internal_NullTools.sure(self.sessionId))
        req.LS_recovery_from(self.rec_clientProg)
        req.LS_polling(True)
        req.LS_polling_millis(0)
        req.LS_idle_millis(0)
        if (self.cause is not None):
            req.LS_cause(self.cause)
            self.cause = None
        if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.protocolLogger.isInfoEnabled():
            com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.protocolLogger.info(("Sending session recovery: " + Std.string(req)))
        self.connectTs = python_lib_Timeit.default_timer()
        self.http = self.sendHttpRequest(com_lightstreamer_internal_Url.build(com_lightstreamer_internal_NullTools.sure(self.serverInstanceAddress),("/lightstreamer/bind_session.txt?LS_protocol=" + HxOverrides.stringOrNull(com_lightstreamer_internal__Constants_Constants_Fields_.TLCP_VERSION))),req,self.getHeadersForRequestOtherThanCreate())

    def disposeWS(self):
        if (self.ws is not None):
            self.ws.dispose()
            self.ws = None

    def closeWS(self):
        if (self.ws is not None):
            self.ws.dispose()
            self.ws = None

    def suspendWS_Streaming(self):
        if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.sessionLogger.isWarnEnabled():
            com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.sessionLogger.warn("Websocket suspended")
        self.suspendedTransports.insert("WS-STREAMING")

    def disableWS(self):
        if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.sessionLogger.isWarnEnabled():
            com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.sessionLogger.warn("Websocket disabled")
        self.disabledTransports = self.disabledTransports.union(["WS-STREAMING", "WS-POLLING"])

    def disableHTTP_Streaming(self):
        if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.sessionLogger.isWarnEnabled():
            com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.sessionLogger.warn("HTTP streaming disabled")
        self.disabledTransports = self.disabledTransports.union(["HTTP-STREAMING"])

    def disableStreaming(self):
        if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.sessionLogger.isWarnEnabled():
            com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.sessionLogger.warn("Streaming disabled")
        self.disabledTransports = self.disabledTransports.union(["WS-STREAMING", "HTTP-STREAMING"])

    def enableAllTransports(self):
        if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.sessionLogger.isInfoEnabled():
            if ((self.disabledTransports.count() > 0) or ((self.suspendedTransports.count() > 0))):
                if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.sessionLogger.isInfoEnabled():
                    com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.sessionLogger.info("Transports enabled again.")
        self.disabledTransports = com_lightstreamer_internal_Set()
        self.suspendedTransports = com_lightstreamer_internal_Set()

    def disposeHTTP(self):
        if (self.http is not None):
            self.http.dispose()
            self.http = None

    def closeHTTP(self):
        if (self.http is not None):
            self.http.dispose()
            self.http = None

    def disposeCtrl(self):
        if (self.ctrl_http is not None):
            self.ctrl_http.dispose()
            self.ctrl_http = None

    def closeCtrl(self):
        if (self.ctrl_http is not None):
            self.ctrl_http.dispose()
            self.ctrl_http = None

    def notifyStatus(self,newStatus):
        oldStatus = self.m_status
        self.m_status = newStatus
        if (oldStatus != newStatus):
            if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.sessionLogger.isInfoEnabled():
                com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.sessionLogger.info(("Status: " + Std.string(newStatus)))
            self.clientEventDispatcher.onStatusChange(newStatus)

    def getBestForCreating(self):
        if (self.getBestForBinding().index == 0):
            return com_lightstreamer_client_internal__ClientMachine_BestForCreatingEnum.BFC_none
        ft = self.options.forcedTransport
        blackList = self.suspendedTransports.union(self.disabledTransports.toArray())
        if (ft is None):
            if (not blackList.contains("WS-STREAMING")):
                return com_lightstreamer_client_internal__ClientMachine_BestForCreatingEnum.BFC_ws
            else:
                return com_lightstreamer_client_internal__ClientMachine_BestForCreatingEnum.BFC_http
        elif ((ft == "WS-STREAMING") or ((ft == "WS"))):
            if (not blackList.contains("WS-STREAMING")):
                return com_lightstreamer_client_internal__ClientMachine_BestForCreatingEnum.BFC_ws
            else:
                return com_lightstreamer_client_internal__ClientMachine_BestForCreatingEnum.BFC_http
        else:
            return com_lightstreamer_client_internal__ClientMachine_BestForCreatingEnum.BFC_http

    def getBestForBinding(self):
        ft = self.options.forcedTransport
        blackList = self.disabledTransports
        if (ft is None):
            if (not blackList.contains("WS-STREAMING")):
                return com_lightstreamer_client_internal__ClientMachine_BestForBindingEnum.BFB_ws_streaming
            elif (not blackList.contains("HTTP-STREAMING")):
                return com_lightstreamer_client_internal__ClientMachine_BestForBindingEnum.BFB_http_streaming
            elif (not blackList.contains("WS-POLLING")):
                return com_lightstreamer_client_internal__ClientMachine_BestForBindingEnum.BFB_ws_polling
            else:
                return com_lightstreamer_client_internal__ClientMachine_BestForBindingEnum.BFB_http_polling
        elif (ft == "HTTP"):
            if (not blackList.contains("HTTP-STREAMING")):
                return com_lightstreamer_client_internal__ClientMachine_BestForBindingEnum.BFB_http_streaming
            else:
                return com_lightstreamer_client_internal__ClientMachine_BestForBindingEnum.BFB_http_polling
        elif (ft == "HTTP-POLLING"):
            return com_lightstreamer_client_internal__ClientMachine_BestForBindingEnum.BFB_http_polling
        elif (ft == "HTTP-STREAMING"):
            if (not blackList.contains("HTTP-STREAMING")):
                return com_lightstreamer_client_internal__ClientMachine_BestForBindingEnum.BFB_http_streaming
            else:
                return com_lightstreamer_client_internal__ClientMachine_BestForBindingEnum.BFB_none
        elif (ft == "WS"):
            if (not blackList.contains("WS-STREAMING")):
                return com_lightstreamer_client_internal__ClientMachine_BestForBindingEnum.BFB_ws_streaming
            elif (not blackList.contains("WS-POLLING")):
                return com_lightstreamer_client_internal__ClientMachine_BestForBindingEnum.BFB_ws_polling
            else:
                return com_lightstreamer_client_internal__ClientMachine_BestForBindingEnum.BFB_none
        elif (ft == "WS-POLLING"):
            if (not blackList.contains("WS-POLLING")):
                return com_lightstreamer_client_internal__ClientMachine_BestForBindingEnum.BFB_ws_polling
            else:
                return com_lightstreamer_client_internal__ClientMachine_BestForBindingEnum.BFB_none
        elif (ft == "WS-STREAMING"):
            if (not blackList.contains("WS-STREAMING")):
                return com_lightstreamer_client_internal__ClientMachine_BestForBindingEnum.BFB_ws_streaming
            else:
                return com_lightstreamer_client_internal__ClientMachine_BestForBindingEnum.BFB_none
        else:
            pass

    def resetCurrentRetryDelay(self):
        self.delayCounter.reset(self.options.retryDelay)

    def notifyServerErrorIfCauseIsError(self,terminationCause):
        tmp = terminationCause.index
        if (tmp == 0):
            self.clientEventDispatcher.onServerError(terminationCause.params[0],terminationCause.params[1])
        elif (tmp == 1):
            self.clientEventDispatcher.onServerError(61,terminationCause.params[0])
        elif (tmp == 2):
            pass
        else:
            pass

    def notifyServerError_CONERR(self,code,msg):
        self.clientEventDispatcher.onServerError(code,msg)

    def notifyServerError_END(self,code,msg):
        if (((0 < code) and ((code < 30))) or ((code > 39))):
            self.clientEventDispatcher.onServerError(39,msg)
        else:
            self.clientEventDispatcher.onServerError(code,msg)

    def notifyServerError_ERROR(self,code,msg):
        self.clientEventDispatcher.onServerError(code,msg)

    def notifyServerError_REQERR(self,code,msg):
        if (code == 11):
            self.clientEventDispatcher.onServerError(21,msg)
        else:
            self.clientEventDispatcher.onServerError(code,msg)

    def doCONOK(self,sessionId,reqLimit,keepalive,idleTimeout,clink):
        self.sessionId = sessionId
        self.details.setSessionId(sessionId)
        self.requestLimit = reqLimit
        if (keepalive is not None):
            self.keepaliveInterval = keepalive
            self.options.setKeepaliveInterval(keepalive)
        elif (idleTimeout is not None):
            self.idleTimeout = idleTimeout
            self.options.setIdleTimeout(idleTimeout)
        if ((clink != "*") and (not self.options.serverInstanceAddressIgnored)):
            clink = com_lightstreamer_internal_Url.completeControlLink(clink,self.getServerAddress())
            self.serverInstanceAddress = clink
            self.details.setServerInstanceAddress(clink)

    def doCONOK_CreateWS(self,sessionId,reqLimit,keepalive,clink):
        self.doCONOK(sessionId,reqLimit,keepalive,None,clink)

    def doCONOK_BindWS_Streaming(self,sessionId,reqLimit,keepalive,clink):
        self.doCONOK(sessionId,reqLimit,keepalive,None,clink)

    def doCONOK_BindWS_Polling(self,sessionId,reqLimit,idleTimeout,clink):
        self.doCONOK(sessionId,reqLimit,None,idleTimeout,clink)

    def doCONOK_CreateHTTP(self,sessionId,reqLimit,keepalive,clink):
        self.doCONOK(sessionId,reqLimit,None,None,clink)

    def doCONOK_BindHTTP_Streaming(self,sessionId,reqLimit,keepalive,clink):
        self.doCONOK(sessionId,reqLimit,keepalive,None,clink)

    def doCONOK_BindHTTP_Polling(self,sessionId,reqLimit,idleTimeout,clink):
        self.doCONOK(sessionId,reqLimit,None,idleTimeout,clink)

    def doSERVNAME(self,serverName):
        self.details.setServerSocketName(serverName)

    def doCLIENTIP(self,clientIp):
        self.details.setClientIp(clientIp)
        lastIp = self.lastKnownClientIp
        if ((lastIp is not None) and ((lastIp != clientIp))):
            if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.sessionLogger.isInfoEnabled():
                com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.sessionLogger.info(((("Client IP changed: " + ("null" if lastIp is None else lastIp)) + " -> ") + ("null" if clientIp is None else clientIp)))
            self.enableAllTransports()
        self.lastKnownClientIp = clientIp

    def doCONS(self,bandwidth):
        self.options.setRealMaxBandwidth(bandwidth)

    def doLOOP(self,pollingMs):
        self.options.setPollingInterval(pollingMs)

    def doPROG(self,prog):
        if (prog > self.rec_clientProg):
            raise com_lightstreamer_internal_IllegalStateException(("Assertion failure: " + "prog <= rec_clientProg"))
        self.rec_serverProg = prog

    def doMSGDONE(self,sequence,prog,response):
        self.onFreshData()
        def _hx_local_0(msg):
            if (msg.sequence == sequence):
                return (msg.prog == prog)
            else:
                return False
        messages = self.messageManagers.filter(_hx_local_0)
        if ((len(messages.values) - messages.nRemoved) > 1):
            raise com_lightstreamer_internal_IllegalStateException(("Assertion failure: " + "messages.length <= 1"))
        msg = com_lightstreamer_internal__MyArray_MyArrayIterator(messages)
        while msg.hasNext():
            msg.next().evtMSGDONE(response)

    def doMSGFAIL(self,sequence,prog,errorCode,errorMsg):
        self.onFreshData()
        if (errorCode == 39):
            count = Std.parseInt(errorMsg)
            if (count is None):
                raise com_lightstreamer_internal_IllegalStateException(("Assertion failure: " + "count != null"))
            _g = ((prog - count) + 1)
            _g1 = (prog + 1)
            while (_g < _g1):
                p = _g
                _g = (_g + 1)
                def _hx_local_1(p):
                    def _hx_local_0(msg):
                        if (msg.sequence == sequence):
                            return (msg.prog == (p[0] if 0 < len(p) else None))
                        else:
                            return False
                    return _hx_local_0
                messages = self.messageManagers.filter(_hx_local_1([p]))
                if ((len(messages.values) - messages.nRemoved) > 1):
                    raise com_lightstreamer_internal_IllegalStateException(("Assertion failure: " + "messages.length <= 1"))
                msg = com_lightstreamer_internal__MyArray_MyArrayIterator(messages)
                while msg.hasNext():
                    msg.next().evtMSGFAIL(errorCode,errorMsg)
        else:
            def _hx_local_2(msg):
                if (msg.sequence == sequence):
                    return (msg.prog == prog)
                else:
                    return False
            messages = self.messageManagers.filter(_hx_local_2)
            if ((len(messages.values) - messages.nRemoved) > 1):
                raise com_lightstreamer_internal_IllegalStateException(("Assertion failure: " + "messages.length <= 1"))
            msg = com_lightstreamer_internal__MyArray_MyArrayIterator(messages)
            while msg.hasNext():
                msg.next().evtMSGFAIL(errorCode,errorMsg)

    def doU(self,subId,itemIdx,values):
        self.onFreshData()
        sub = self.subscriptionManagers._innerMap.h.get(subId,None)
        if (sub is not None):
            sub.evtU(itemIdx,values)
        else:
            com_lightstreamer_client_internal_SubscriptionManagerZombie(subId,self).evtU(itemIdx,values)

    def doSUBOK(self,subId,nItems,nFields):
        self.onFreshData()
        sub = self.subscriptionManagers._innerMap.h.get(subId,None)
        if (sub is not None):
            sub.evtSUBOK(nItems,nFields)
        else:
            com_lightstreamer_client_internal_SubscriptionManagerZombie(subId,self).evtSUBOK(nItems,nFields)

    def doSUBCMD(self,subId,nItems,nFields,keyIdx,cmdIdx):
        self.onFreshData()
        sub = self.subscriptionManagers._innerMap.h.get(subId,None)
        if (sub is not None):
            sub.evtSUBCMD(nItems,nFields,keyIdx,cmdIdx)
        else:
            com_lightstreamer_client_internal_SubscriptionManagerZombie(subId,self).evtSUBCMD(nItems,nFields,keyIdx,cmdIdx)

    def doUNSUB(self,subId):
        self.onFreshData()
        sub = self.subscriptionManagers._innerMap.h.get(subId,None)
        if (sub is not None):
            sub.evtUNSUB()

    def doEOS(self,subId,itemIdx):
        self.onFreshData()
        sub = self.subscriptionManagers._innerMap.h.get(subId,None)
        if (sub is not None):
            sub.evtEOS(itemIdx)
        else:
            com_lightstreamer_client_internal_SubscriptionManagerZombie(subId,self).evtEOS(itemIdx)

    def doCS(self,subId,itemIdx):
        self.onFreshData()
        sub = self.subscriptionManagers._innerMap.h.get(subId,None)
        if (sub is not None):
            sub.evtCS(itemIdx)
        else:
            com_lightstreamer_client_internal_SubscriptionManagerZombie(subId,self).evtCS(itemIdx)

    def doOV(self,subId,itemIdx,lostUpdates):
        self.onFreshData()
        sub = self.subscriptionManagers._innerMap.h.get(subId,None)
        if (sub is not None):
            sub.evtOV(itemIdx,lostUpdates)
        else:
            com_lightstreamer_client_internal_SubscriptionManagerZombie(subId,self).evtOV(itemIdx,lostUpdates)

    def doCONF(self,subId,freq):
        self.onFreshData()
        sub = self.subscriptionManagers._innerMap.h.get(subId,None)
        if (sub is not None):
            sub.evtCONF(freq)
        else:
            com_lightstreamer_client_internal_SubscriptionManagerZombie(subId,self).evtCONF(freq)

    def doREQOK(self,reqId):
        _hx_map = self.subscriptionManagers
        _g_keys = _hx_map.keys()
        while _g_keys.hasNext():
            _hx_map.get(_g_keys.next()).evtREQOK(reqId)
        self.subscriptionManagers._orderedKeys.compact()
        msg = com_lightstreamer_internal__MyArray_MyArrayIterator(self.messageManagers)
        while msg.hasNext():
            msg.next().evtREQOK(reqId)
        self.messageManagers.compact()

    def doREQERR(self,reqId,errorCode,errorMsg):
        _hx_map = self.subscriptionManagers
        _g_keys = _hx_map.keys()
        while _g_keys.hasNext():
            _hx_map.get(_g_keys.next()).evtREQERR(reqId,errorCode,errorMsg)
        self.subscriptionManagers._orderedKeys.compact()
        msg = com_lightstreamer_internal__MyArray_MyArrayIterator(self.messageManagers)
        while msg.hasNext():
            msg.next().evtREQERR(reqId,errorCode,errorMsg)
        self.messageManagers.compact()

    def doSYNC(self,syncMs):
        self.slw_refTime = python_lib_Timeit.default_timer()
        self.slw_avgDelayMs = -syncMs

    def doSYNC_G(self,syncMs):
        diffTime = self.diffTimeSync(syncMs)
        if ((diffTime > self.slw_hugeDelayMs) and ((diffTime > ((self.slw_avgDelayMs * 2))))):
            if ((self.slw_avgDelayMs > self.slw_maxAvgDelayMs) and self.options.slowingEnabled):
                return com_lightstreamer_client_internal__ClientMachine_SyncCheckResult.SCR_bad
            else:
                return com_lightstreamer_client_internal__ClientMachine_SyncCheckResult.SCR_not_good
        else:
            self.slw_avgDelayMs = self.slowAvg(diffTime)
            if ((self.slw_avgDelayMs > self.slw_maxAvgDelayMs) and self.options.slowingEnabled):
                return com_lightstreamer_client_internal__ClientMachine_SyncCheckResult.SCR_bad
            else:
                if (self.slw_avgDelayMs < 60):
                    self.slw_avgDelayMs = 0
                return com_lightstreamer_client_internal__ClientMachine_SyncCheckResult.SCR_good

    def doSYNC_NG(self,syncMs):
        diffTime = self.diffTimeSync(syncMs)
        if ((diffTime > self.slw_hugeDelayMs) and ((diffTime > ((self.slw_avgDelayMs * 2))))):
            self.slw_avgDelayMs = self.slowAvg(diffTime)
            if ((self.slw_avgDelayMs > self.slw_maxAvgDelayMs) and self.options.slowingEnabled):
                return com_lightstreamer_client_internal__ClientMachine_SyncCheckResult.SCR_bad
            else:
                if (self.slw_avgDelayMs < 60):
                    self.slw_avgDelayMs = 0
                return com_lightstreamer_client_internal__ClientMachine_SyncCheckResult.SCR_good
        else:
            self.slw_avgDelayMs = self.slowAvg(diffTime)
            if ((self.slw_avgDelayMs > self.slw_maxAvgDelayMs) and self.options.slowingEnabled):
                return com_lightstreamer_client_internal__ClientMachine_SyncCheckResult.SCR_bad
            else:
                if (self.slw_avgDelayMs < 60):
                    self.slw_avgDelayMs = 0
                return com_lightstreamer_client_internal__ClientMachine_SyncCheckResult.SCR_not_good

    def diffTimeSync(self,syncMs):
        diffMs = com_lightstreamer_internal__Timer_TimerStamp_Impl_.minus(python_lib_Timeit.default_timer(),self.slw_refTime)
        return (diffMs - syncMs)

    def slowAvg(self,diffTime):
        return ((self.slw_avgDelayMs * self.slw_m) + ((diffTime * ((1.0 - self.slw_m)))))

    def schedule_evtTransportTimeout(self,timeout):
        self.transportTimer = self.createTimer("transport.timeout",timeout,self.evtTransportTimeout)

    def schedule_evtRetryTimeout(self,timeout):
        self.retryTimer = self.createTimer("retry.timeout",timeout,self.evtRetryTimeout)

    def schedule_evtRecoveryTimeout(self,timeout):
        self.recoveryTimer = self.createTimer("recovery.timeout",timeout,self.evtRecoveryTimeout)

    def schedule_evtIdleTimeout(self,timeout):
        self.idleTimer = self.createTimer("idle.timeout",timeout,self.evtIdleTimeout)

    def schedule_evtPollingTimeout(self,timeout):
        self.pollingTimer = self.createTimer("polling.timeout",timeout,self.evtPollingTimeout)

    def schedule_evtCtrlTimeout(self,timeout):
        self.ctrlTimer = self.createTimer("ctrl.timeout",timeout,self.evtCtrlTimeout)

    def schedule_evtKeepaliveTimeout(self,timeout):
        self.keepaliveTimer = self.createTimer("keepalive.timeout",timeout,self.evtKeepaliveTimeout)

    def schedule_evtStalledTimeout(self,timeout):
        self.stalledTimer = self.createTimer("stalled.timeout",timeout,self.evtStalledTimeout)

    def schedule_evtReconnectTimeout(self,timeout):
        self.reconnectTimer = self.createTimer("reconnect.timeout",timeout,self.evtReconnectTimeout)

    def schedule_evtRhbTimeout(self,timeout):
        self.rhbTimer = self.createTimer("rhb.timeout",timeout,self.evtRhbTimeout)

    def createTimer(self,id,timeout,callback):
        _gthis = self
        def _hx_local_2():
            def _hx_local_1(timer):
                def _hx_local_0():
                    if timer.isCanceled():
                        return
                    callback()
                _gthis.lock.synchronized(_hx_local_0)
            return self.timerFactory(id,timeout,_hx_local_1)
        return _hx_local_2()

    def cancel_evtTransportTimeout(self):
        if (self.transportTimer is not None):
            self.transportTimer.cancel()
            self.transportTimer = None

    def cancel_evtRetryTimeout(self):
        if (self.retryTimer is not None):
            self.retryTimer.cancel()
            self.retryTimer = None

    def cancel_evtKeepaliveTimeout(self):
        if (self.keepaliveTimer is not None):
            self.keepaliveTimer.cancel()
            self.keepaliveTimer = None

    def cancel_evtStalledTimeout(self):
        if (self.stalledTimer is not None):
            self.stalledTimer.cancel()
            self.stalledTimer = None

    def cancel_evtReconnectTimeout(self):
        if (self.reconnectTimer is not None):
            self.reconnectTimer.cancel()
            self.reconnectTimer = None

    def cancel_evtRhbTimeout(self):
        if (self.rhbTimer is not None):
            self.rhbTimer.cancel()
            self.rhbTimer = None

    def cancel_evtIdleTimeout(self):
        if (self.idleTimer is not None):
            self.idleTimer.cancel()
            self.idleTimer = None

    def cancel_evtPollingTimeout(self):
        if (self.pollingTimer is not None):
            self.pollingTimer.cancel()
            self.pollingTimer = None

    def cancel_evtCtrlTimeout(self):
        if (self.ctrlTimer is not None):
            self.ctrlTimer.cancel()
            self.ctrlTimer = None

    def cancel_evtRecoveryTimeout(self):
        if (self.recoveryTimer is not None):
            self.recoveryTimer.cancel()
            self.recoveryTimer = None

    def waitingInterval(self,expectedMs,startTime):
        diffMs = com_lightstreamer_internal__Timer_TimerStamp_Impl_.minus(python_lib_Timeit.default_timer(),startTime)
        expected = expectedMs
        if (diffMs < expected):
            return (expected - diffMs)
        else:
            return 0

    def exit_tr(self):
        self.evtEndSession()

    def entry_m111(self,retryCause,timeout):
        self.evtRetry(retryCause,timeout)
        self.schedule_evtRetryTimeout(timeout)

    def entry_m112(self,retryCause):
        pauseMs = self.waitingInterval(self.delayCounter.get_currentRetryDelay(),self.connectTs)
        self.evtRetry(retryCause,pauseMs)
        self.schedule_evtRetryTimeout(pauseMs)

    def entry_m113(self,retryCause):
        pauseMs = self.randomPause(self.options.firstRetryMaxDelay)
        self.evtRetry(retryCause,pauseMs)
        self.schedule_evtRetryTimeout(pauseMs)

    def entry_m115(self,retryCause):
        self.evtRetry(retryCause)
        self.evtRetryTimeout()

    def entry_rec(self,pause,retryCause):
        if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.sessionLogger.isErrorEnabled():
            com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.sessionLogger.error(((("Recovering connection in " + Std.string(pause)) + " ms. Cause: ") + HxOverrides.stringOrNull(com_lightstreamer_client_internal__ClientMachine_ClientMachine_Fields_.asErrorMsg(retryCause))))
        self.evtStartRecovery()
        self.schedule_evtRecoveryTimeout(pause)

    def exit_w(self):
        self.cancel_evtKeepaliveTimeout()
        self.cancel_evtStalledTimeout()
        self.cancel_evtReconnectTimeout()
        self.cancel_evtRhbTimeout()

    def exit_ws(self):
        self.cancel_evtTransportTimeout()
        self.cancel_evtKeepaliveTimeout()
        self.cancel_evtStalledTimeout()
        self.cancel_evtReconnectTimeout()
        self.cancel_evtRhbTimeout()

    def exit_wp(self):
        self.cancel_evtTransportTimeout()
        self.cancel_evtIdleTimeout()
        self.cancel_evtPollingTimeout()

    def exit_hs(self):
        self.cancel_evtTransportTimeout()
        self.cancel_evtKeepaliveTimeout()
        self.cancel_evtStalledTimeout()
        self.cancel_evtReconnectTimeout()
        self.cancel_evtRhbTimeout()

    def exit_hp(self):
        self.cancel_evtIdleTimeout()
        self.cancel_evtPollingTimeout()
        self.cancel_evtRhbTimeout()

    def exit_ctrl(self):
        self.cancel_evtCtrlTimeout()
        self.evtDisposeCtrl()

    def exit_rec(self):
        self.cancel_evtRecoveryTimeout()
        self.cancel_evtTransportTimeout()
        self.cancel_evtRetryTimeout()

    def exit_keepalive_unit(self):
        self.cancel_evtKeepaliveTimeout()
        self.cancel_evtStalledTimeout()
        self.cancel_evtReconnectTimeout()

    def exit_w_to_m(self):
        self.exit_w()
        self.exit_tr()

    def exit_ws_to_m(self):
        self.exit_ws()
        self.exit_tr()

    def exit_wp_to_m(self):
        self.exit_wp()
        self.exit_tr()

    def exit_hs_to_m(self):
        self.exit_ctrl()
        self.exit_hs()
        self.exit_tr()

    def exit_hs_to_rec(self):
        self.exit_ctrl()
        self.exit_hs()

    def exit_hp_to_m(self):
        self.exit_ctrl()
        self.exit_hp()
        self.exit_tr()

    def exit_hp_to_rec(self):
        self.exit_ctrl()
        self.exit_hp()

    def exit_ctrl_to_m(self):
        self.exit_ctrl()
        self.exit_hs()
        self.exit_hp()
        self.exit_tr()

    def exit_rec_to_m(self):
        self.exit_rec()
        self.exit_tr()

    def randomPause(self,maxPause):
        return self.randomGenerator(maxPause)

    def generateFreshReqId(self):
        _gthis = self
        def _hx_local_2():
            def _hx_local_1():
                _gthis.m_nextReqId = (_gthis.m_nextReqId + 1)
                return _gthis.m_nextReqId
            return self.lock.synchronized(_hx_local_1)
        return _hx_local_2()

    def generateFreshSubId(self):
        _gthis = self
        def _hx_local_2():
            def _hx_local_1():
                _gthis.m_nextSubId = (_gthis.m_nextSubId + 1)
                return _gthis.m_nextSubId
            return self.lock.synchronized(_hx_local_1)
        return _hx_local_2()

    def genAbortSubscriptions(self):
        _hx_map = self.subscriptionManagers
        _g_keys = _hx_map.keys()
        while _g_keys.hasNext():
            _hx_map.get(_g_keys.next()).evtExtAbort()
        self.subscriptionManagers._orderedKeys.compact()

    def genAckMessagesWS(self):
        def _hx_local_0(msg):
            return msg.isPending()
        msg = com_lightstreamer_internal__MyArray_MyArrayIterator(self.messageManagers.filter(_hx_local_0))
        while msg.hasNext():
            msg.next().evtWSSent()

    def genAbortMessages(self):
        msg = com_lightstreamer_internal__MyArray_MyArrayIterator(self.messageManagers)
        while msg.hasNext():
            msg.next().evtAbort()
        self.messageManagers.compact()

    def resetSequenceMap(self):
        self.sequenceMap.h.clear()

    def isSwitching(self):
        if (self.state.s_m == 150):
            if (self.state.s_swt != 1302):
                return (self.state.s_swt == 1303)
            else:
                return True
        else:
            return False

    def encodeSwitch(self,isWS):
        _gthis = self
        def _hx_local_1():
            def _hx_local_0():
                req = com_lightstreamer_internal_RequestBuilder()
                _gthis.swt_lastReqId = _gthis.generateFreshReqId()
                req.LS_reqId(_gthis.swt_lastReqId)
                req.LS_op("force_rebind")
                if isWS:
                    req.LS_close_socket(True)
                if (_gthis.cause is not None):
                    req.LS_cause(_gthis.cause)
                    _gthis.cause = None
                if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.protocolLogger.isInfoEnabled():
                    com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.protocolLogger.info(("Sending transport switch: " + Std.string(req)))
                return req.getEncodedString()
            return self.lock.synchronized(_hx_local_0)
        return _hx_local_1()

    def encodeConstrain(self):
        _gthis = self
        def _hx_local_1():
            def _hx_local_0():
                req = com_lightstreamer_internal_RequestBuilder()
                _gthis.bw_lastReqId = _gthis.generateFreshReqId()
                req.LS_reqId(_gthis.bw_lastReqId)
                req.LS_op("constrain")
                _g = com_lightstreamer_internal_NullTools.sure(_gthis.bw_requestedMaxBandwidth)
                tmp = _g.index
                if (tmp == 0):
                    req.LS_requested_max_bandwidth_Float(_g.params[0])
                elif (tmp == 1):
                    req.LS_requested_max_bandwidth("unlimited")
                else:
                    pass
                if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.protocolLogger.isInfoEnabled():
                    com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.protocolLogger.info(("Sending bandwidth constrain: " + Std.string(req)))
                return req.getEncodedString()
            return self.lock.synchronized(_hx_local_0)
        return _hx_local_1()

    def getPendingControls(self):
        res = list()
        if com_lightstreamer_internal_NullTools.sure(self.switchRequest).isPending():
            x = com_lightstreamer_internal_NullTools.sure(self.switchRequest)
            res.append(x)
        if com_lightstreamer_internal_NullTools.sure(self.constrainRequest).isPending():
            x = com_lightstreamer_internal_NullTools.sure(self.constrainRequest)
            res.append(x)
        _hx_map = self.subscriptionManagers
        _g_keys = _hx_map.keys()
        while _g_keys.hasNext():
            _g_value = _hx_map.get(_g_keys.next())
            if _g_value.isPending():
                res.append(_g_value)
        return res

    def sendControlWS(self,request):
        com_lightstreamer_internal_NullTools.sure(self.ws).send(request.encodeWS())

    def sendMsgWS(self,msg):
        com_lightstreamer_internal_NullTools.sure(self.ws).send(msg.encodeWS())

    def sendPengingControlsWS(self,pendings):
        self.sendBatchWS(self.prepareBatchWS("control",pendings,com_lightstreamer_internal_NullTools.sure(self.requestLimit)))

    def sendPendingMessagesWS(self):
        _g = []
        msg = com_lightstreamer_internal__MyArray_MyArrayIterator(self.messageManagers)
        while msg.hasNext():
            msg1 = msg.next()
            if msg1.isPending():
                _g.append(msg1)
        self.sendBatchWS(self.prepareBatchWS("msg",_g,com_lightstreamer_internal_NullTools.sure(self.requestLimit)))

    def sendBatchWS(self,batches):
        _g = 0
        while (_g < len(batches)):
            def _hx_local_1():
                nonlocal _g
                _hx_local_0 = _g
                _g = (_g + 1)
                return _hx_local_0
            batch = python_internal_ArrayImpl._get(batches, _hx_local_1())
            com_lightstreamer_internal_NullTools.sure(self.ws).send(batch)

    def sendHeartbeatWS(self):
        if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.protocolLogger.isInfoEnabled():
            com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.protocolLogger.info("Heartbeat request")
        com_lightstreamer_internal_NullTools.sure(self.ws).send("heartbeat\r\n\r\n")

    def sendPendingControlsHTTP(self,pendings):
        self.sendBatchHTTP(self.prepareBatchHTTP(pendings,com_lightstreamer_internal_NullTools.sure(self.requestLimit)),"control")

    def sendPendingMessagesHTTP(self):
        _g = []
        msg = com_lightstreamer_internal__MyArray_MyArrayIterator(self.messageManagers)
        while msg.hasNext():
            msg1 = msg.next()
            if msg1.isPending():
                _g.append(msg1)
        self.sendBatchHTTP(self.prepareBatchHTTP(_g,com_lightstreamer_internal_NullTools.sure(self.requestLimit)),"msg")

    def sendHeartbeatHTTP(self):
        if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.protocolLogger.isInfoEnabled():
            com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.protocolLogger.info("Heartbeat request")
        self.sendBatchHTTP("\r\n","heartbeat")

    def sendBatchHTTP(self,body,reqType):
        _gthis = self
        self.ctrl_connectTs = python_lib_Timeit.default_timer()
        url = com_lightstreamer_internal_Url.build(com_lightstreamer_internal_NullTools.sure(self.serverInstanceAddress),((((("/lightstreamer/" + ("null" if reqType is None else reqType)) + ".txt?LS_protocol=") + HxOverrides.stringOrNull(com_lightstreamer_internal__Constants_Constants_Fields_.TLCP_VERSION)) + "&LS_session=") + HxOverrides.stringOrNull(self.sessionId)))
        headers = self.getHeadersForRequestOtherThanCreate()
        def _hx_local_2(client,line):
            def _hx_local_1():
                def _hx_local_0():
                    if client.isDisposed():
                        return
                    _gthis.evtCtrlMessage(line)
                _gthis.lock.synchronized(_hx_local_0)
            com_lightstreamer_internal__Threads_Threads_Fields_.sessionThread.loop.call_soon_threadsafe(_hx_local_1)
        onText = _hx_local_2
        def _hx_local_5(client,error):
            def _hx_local_4():
                def _hx_local_3():
                    if client.isDisposed():
                        return
                    _gthis.evtCtrlError()
                _gthis.lock.synchronized(_hx_local_3)
            com_lightstreamer_internal__Threads_Threads_Fields_.sessionThread.loop.call_soon_threadsafe(_hx_local_4)
        onError = _hx_local_5
        def _hx_local_8(client):
            def _hx_local_7():
                def _hx_local_6():
                    if client.isDisposed():
                        return
                    _gthis.evtCtrlDone()
                _gthis.lock.synchronized(_hx_local_6)
            com_lightstreamer_internal__Threads_Threads_Fields_.sessionThread.loop.call_soon_threadsafe(_hx_local_7)
        onDone = _hx_local_8
        self.ctrl_http = self.ctrlFactory(url,body,headers,onText,onError,onDone)

    def prepareBatchWS(self,reqType,pendings,requestLimit):
        if (len(pendings) <= 0):
            raise com_lightstreamer_internal_IllegalStateException(("Assertion failure: " + "pendings.length > 0"))
        out = []
        i = 0
        subReq = (pendings[0] if 0 < len(pendings) else None).encode(True)
        while (i < len(pendings)):
            mainReq = com_lightstreamer_client_internal_Request()
            mainReq.addSubRequest(reqType)
            mainReq.addSubRequest(subReq)
            i = (i + 1)
            while (i < len(pendings)):
                subReq = (pendings[i] if i >= 0 and i < len(pendings) else None).encode(True)
                if mainReq.addSubRequestOnlyIfBodyIsLessThan(subReq,requestLimit):
                    i = (i + 1)
                else:
                    break
            x = mainReq.getBody()
            out.append(x)
        return out

    def prepareBatchHTTP(self,pendings,requestLimit):
        if (len(pendings) <= 0):
            raise com_lightstreamer_internal_IllegalStateException(("Assertion failure: " + "pendings.length > 0"))
        mainReq = com_lightstreamer_client_internal_Request()
        i = 0
        subReq = (pendings[0] if 0 < len(pendings) else None).encode(False)
        mainReq.addSubRequest(subReq)
        i = 1
        while (i < len(pendings)):
            subReq = (pendings[i] if i >= 0 and i < len(pendings) else None).encode(False)
            if mainReq.addSubRequestOnlyIfBodyIsLessThan(subReq,requestLimit):
                i = (i + 1)
            else:
                break
        return mainReq.getBody()

    def getHeadersForRequestOtherThanCreate(self):
        if self.options.httpExtraHeadersOnSessionCreationOnly:
            return None
        else:
            return self.options.httpExtraHeaders

    def getServerAddress(self):
        addr = self.details.serverAddress
        if (addr is not None):
            return addr
        else:
            return com_lightstreamer_internal_NullTools.sure(self.defaultServerAddress)

    def relateSubManager(self,subManager):
        _gthis = self
        def _hx_local_0():
            if (_gthis.subscriptionManagers._innerMap.h.get(subManager.subId,None) is not None):
                raise com_lightstreamer_internal_IllegalStateException(("Assertion failure: " + "subscriptionManagers[subManager.subId] == null"))
            _gthis.subscriptionManagers.set(subManager.subId,subManager)
            return subManager
        self.lock.synchronized(_hx_local_0)

    def unrelateSubManager(self,subManager):
        _gthis = self
        def _hx_local_0():
            return _gthis.subscriptionManagers.remove(subManager.subId)
        self.lock.synchronized(_hx_local_0)

    def isRelatedWithSubManager(self,subManager):
        return Lambda.has(self.subscriptionManagers,subManager)

    def relateMsgManager(self,msgManager):
        _gthis = self
        def _hx_local_0():
            x = com_lightstreamer_internal__MyArray_Pair(msgManager)
            _gthis.messageManagers.values.append(x)
        self.lock.synchronized(_hx_local_0)

    def unrelateMsgManager(self,msgManager):
        _gthis = self
        def _hx_local_0():
            _gthis.messageManagers.remove(msgManager)
        self.lock.synchronized(_hx_local_0)

    def getAndSetNextMsgProg(self,sequence):
        _gthis = self
        def _hx_local_1():
            def _hx_local_0():
                prog = _gthis.sequenceMap.h.get(sequence,None)
                if (prog is None):
                    prog = 1
                _gthis.sequenceMap.h[sequence] = (prog + 1)
                return prog
            return self.lock.synchronized(_hx_local_0)
        return _hx_local_1()

    def onPropertyChange(self,property):
        _gthis = self
        def _hx_local_0():
            _gthis.clientEventDispatcher.onPropertyChange(property)
        self.lock.synchronized(_hx_local_0)

    def traceEvent(self,event):
        if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.internalLogger.isTraceEnabled():
            com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.internalLogger.trace(((("event: " + ("null" if event is None else event)) + " ") + HxOverrides.stringOrNull(self.state.toString())))

    def connect(self):
        _gthis = self
        def _hx_local_0():
            serverAddress = _gthis.details.getServerAddress()
            if (serverAddress is None):
                raise com_lightstreamer_internal_IllegalStateException("Configure the server address before trying to connect")
            if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.actionLogger.isInfoEnabled():
                com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.actionLogger.info(((((("Connection requested: details: " + Std.string(_gthis.details)) + " options: ") + Std.string(_gthis.options)) + " env: ") + Std.string(com_lightstreamer_internal_Globals.instance)))
            _gthis.defaultServerAddress = serverAddress
            _gthis.evtExtConnect()
        self.lock.synchronized(_hx_local_0)

    def disconnect(self):
        _gthis = self
        def _hx_local_0():
            if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.actionLogger.isInfoEnabled():
                com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.actionLogger.info("Disconnection requested")
            _gthis.evtExtDisconnect(com_lightstreamer_client_internal__ClientMachine_TerminationCause.TC_api)
        self.lock.synchronized(_hx_local_0)

    def getStatus(self):
        _gthis = self
        def _hx_local_1():
            def _hx_local_0():
                return _gthis.m_status
            return self.lock.synchronized(_hx_local_0)
        return _hx_local_1()

    def sendMessage(self,message,sequence,delayTimeout,listener,enqueueWhileDisconnected):
        _gthis = self
        def _hx_local_0():
            if ((not enqueueWhileDisconnected) and ((_gthis.state.inDisconnected() or _gthis.state.inRetryUnit()))):
                if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.actionLogger.isInfoEnabled():
                    _g = haxe_ds_StringMap()
                    _g.h["text"] = message
                    _g.h["sequence"] = (sequence if ((sequence is not None)) else "UNORDERED_MESSAGES")
                    value = Std.string(delayTimeout)
                    _g.h["timeout"] = value
                    value = Std.string(enqueueWhileDisconnected)
                    _g.h["enqueueWhileDisconnected"] = value
                    if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.actionLogger.isInfoEnabled():
                        com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.actionLogger.info(("Message sending requested: " + HxOverrides.stringOrNull((("null" if ((_g is None)) else _g.toString())))))
                if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.messageLogger.isWarnEnabled():
                    com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.messageLogger.warn((((("Message " + HxOverrides.stringOrNull(((sequence if ((sequence is not None)) else "UNORDERED_MESSAGES")))) + " ") + ("null" if message is None else message)) + " aborted"))
                if (listener is not None):
                    dispatcher = com_lightstreamer_client_internal_MessageEventDispatcher()
                    dispatcher.addListener(listener)
                    dispatcher.onAbort(message,False)
                return
            if (sequence is not None):
                _this = EReg("^[a-zA-Z0-9_]*$","")
                _this.matchObj = python_lib_Re.search(_this.pattern,sequence)
                if (_this.matchObj is None):
                    raise com_lightstreamer_internal_IllegalArgumentException("The given sequence name is not valid. Use only alphanumeric characters plus underscore or null")
                msg = com_lightstreamer_client_internal_MessageManager(message,sequence,delayTimeout,listener,enqueueWhileDisconnected,_gthis)
                if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.actionLogger.isInfoEnabled():
                    com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.actionLogger.info(("Message sending requested: " + Std.string(msg)))
                msg.evtExtSendMessage()
            else:
                msg = com_lightstreamer_client_internal_MessageManager(message,"UNORDERED_MESSAGES",delayTimeout,listener,enqueueWhileDisconnected,_gthis)
                if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.actionLogger.isInfoEnabled():
                    com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.actionLogger.info(("Message sending requested: " + Std.string(msg)))
                msg.evtExtSendMessage()
        self.lock.synchronized(_hx_local_0)

    def subscribeExt(self,subscription,isInternal = None):
        if (isInternal is None):
            isInternal = False
        _gthis = self
        def _hx_local_0():
            if subscription.isActive():
                raise com_lightstreamer_internal_IllegalStateException("Cannot subscribe to an active Subscription")
            if ((subscription.fetchItems() is None) and ((subscription.getItemGroup() is None))):
                raise com_lightstreamer_internal_IllegalArgumentException("Specify property 'items' or 'itemGroup'")
            if ((subscription.fetchFields() is None) and ((subscription.getFieldSchema() is None))):
                raise com_lightstreamer_internal_IllegalArgumentException("Specify property 'fields' or 'fieldSchema'")
            sm = com_lightstreamer_client_internal_SubscriptionManagerLiving(subscription,_gthis)
            if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.actionLogger.isInfoEnabled():
                com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.actionLogger.info(((((("" + HxOverrides.stringOrNull((("Internal subscription" if isInternal else "Subscription")))) + " requested: subId: ") + Std.string(sm.subId)) + " ") + Std.string(subscription)))
            sm.evtExtSubscribe()
        self.lock.synchronized(_hx_local_0)

    def unsubscribe(self,subscription):
        _gthis = self
        def _hx_local_0():
            sm = subscription.fetch_subManager()
            if (sm is not None):
                if (not _gthis.isRelatedWithSubManager(sm)):
                    raise com_lightstreamer_internal_IllegalArgumentException("The Subscription is not subscribed to this Client")
                if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.actionLogger.isInfoEnabled():
                    com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.actionLogger.info(((("Unsubscription requested: subId: " + Std.string(sm.subId)) + " ") + Std.string(subscription)))
                sm.evtExtUnsubscribe()
        self.lock.synchronized(_hx_local_0)

    def getSubscriptions(self):
        _gthis = self
        def _hx_local_1():
            def _hx_local_0():
                ls = list()
                _hx_map = _gthis.subscriptionManagers
                _g_keys = _hx_map.keys()
                while _g_keys.hasNext():
                    sml = Std.downcast(_hx_map.get(_g_keys.next()),com_lightstreamer_client_internal_SubscriptionManagerLiving)
                    if (sml is not None):
                        sub = sml.m_subscription
                        if (sub.isActive() and (not sub.isInternal())):
                            ls.append(sub)
                return ls
            return self.lock.synchronized(_hx_local_0)
        return _hx_local_1()

com_lightstreamer_client_internal_ClientMachine._hx_class = com_lightstreamer_client_internal_ClientMachine

class com_lightstreamer_client_internal__ClientMachine_BestForCreatingEnum(Enum):
    __slots__ = ()
    _hx_class_name = "com.lightstreamer.client.internal._ClientMachine.BestForCreatingEnum"
    _hx_constructs = ["BFC_ws", "BFC_http", "BFC_none"]
com_lightstreamer_client_internal__ClientMachine_BestForCreatingEnum.BFC_ws = com_lightstreamer_client_internal__ClientMachine_BestForCreatingEnum("BFC_ws", 0, ())
com_lightstreamer_client_internal__ClientMachine_BestForCreatingEnum.BFC_http = com_lightstreamer_client_internal__ClientMachine_BestForCreatingEnum("BFC_http", 1, ())
com_lightstreamer_client_internal__ClientMachine_BestForCreatingEnum.BFC_none = com_lightstreamer_client_internal__ClientMachine_BestForCreatingEnum("BFC_none", 2, ())
com_lightstreamer_client_internal__ClientMachine_BestForCreatingEnum._hx_class = com_lightstreamer_client_internal__ClientMachine_BestForCreatingEnum

class com_lightstreamer_client_internal__ClientMachine_BestForBindingEnum(Enum):
    __slots__ = ()
    _hx_class_name = "com.lightstreamer.client.internal._ClientMachine.BestForBindingEnum"
    _hx_constructs = ["BFB_none", "BFB_ws_streaming", "BFB_ws_polling", "BFB_http_streaming", "BFB_http_polling"]
com_lightstreamer_client_internal__ClientMachine_BestForBindingEnum.BFB_none = com_lightstreamer_client_internal__ClientMachine_BestForBindingEnum("BFB_none", 0, ())
com_lightstreamer_client_internal__ClientMachine_BestForBindingEnum.BFB_ws_streaming = com_lightstreamer_client_internal__ClientMachine_BestForBindingEnum("BFB_ws_streaming", 1, ())
com_lightstreamer_client_internal__ClientMachine_BestForBindingEnum.BFB_ws_polling = com_lightstreamer_client_internal__ClientMachine_BestForBindingEnum("BFB_ws_polling", 2, ())
com_lightstreamer_client_internal__ClientMachine_BestForBindingEnum.BFB_http_streaming = com_lightstreamer_client_internal__ClientMachine_BestForBindingEnum("BFB_http_streaming", 3, ())
com_lightstreamer_client_internal__ClientMachine_BestForBindingEnum.BFB_http_polling = com_lightstreamer_client_internal__ClientMachine_BestForBindingEnum("BFB_http_polling", 4, ())
com_lightstreamer_client_internal__ClientMachine_BestForBindingEnum._hx_class = com_lightstreamer_client_internal__ClientMachine_BestForBindingEnum

class com_lightstreamer_client_internal__ClientMachine_SyncCheckResult(Enum):
    __slots__ = ()
    _hx_class_name = "com.lightstreamer.client.internal._ClientMachine.SyncCheckResult"
    _hx_constructs = ["SCR_good", "SCR_not_good", "SCR_bad"]
com_lightstreamer_client_internal__ClientMachine_SyncCheckResult.SCR_good = com_lightstreamer_client_internal__ClientMachine_SyncCheckResult("SCR_good", 0, ())
com_lightstreamer_client_internal__ClientMachine_SyncCheckResult.SCR_not_good = com_lightstreamer_client_internal__ClientMachine_SyncCheckResult("SCR_not_good", 1, ())
com_lightstreamer_client_internal__ClientMachine_SyncCheckResult.SCR_bad = com_lightstreamer_client_internal__ClientMachine_SyncCheckResult("SCR_bad", 2, ())
com_lightstreamer_client_internal__ClientMachine_SyncCheckResult._hx_class = com_lightstreamer_client_internal__ClientMachine_SyncCheckResult

class com_lightstreamer_client_internal__ClientMachine_RetryCause(Enum):
    __slots__ = ()
    _hx_class_name = "com.lightstreamer.client.internal._ClientMachine.RetryCause"
    _hx_constructs = ["standardError", "ws_unavailable", "ws_error", "http_error", "idle_timeout", "stalled_timeout", "ws_timeout", "http_timeout", "recovery_timeout", "prog_mismatch", "page_frozen"]

    @staticmethod
    def standardError(code,msg):
        return com_lightstreamer_client_internal__ClientMachine_RetryCause("standardError", 0, (code,msg))

    @staticmethod
    def prog_mismatch(expected,actual):
        return com_lightstreamer_client_internal__ClientMachine_RetryCause("prog_mismatch", 9, (expected,actual))
com_lightstreamer_client_internal__ClientMachine_RetryCause.ws_unavailable = com_lightstreamer_client_internal__ClientMachine_RetryCause("ws_unavailable", 1, ())
com_lightstreamer_client_internal__ClientMachine_RetryCause.ws_error = com_lightstreamer_client_internal__ClientMachine_RetryCause("ws_error", 2, ())
com_lightstreamer_client_internal__ClientMachine_RetryCause.http_error = com_lightstreamer_client_internal__ClientMachine_RetryCause("http_error", 3, ())
com_lightstreamer_client_internal__ClientMachine_RetryCause.idle_timeout = com_lightstreamer_client_internal__ClientMachine_RetryCause("idle_timeout", 4, ())
com_lightstreamer_client_internal__ClientMachine_RetryCause.stalled_timeout = com_lightstreamer_client_internal__ClientMachine_RetryCause("stalled_timeout", 5, ())
com_lightstreamer_client_internal__ClientMachine_RetryCause.ws_timeout = com_lightstreamer_client_internal__ClientMachine_RetryCause("ws_timeout", 6, ())
com_lightstreamer_client_internal__ClientMachine_RetryCause.http_timeout = com_lightstreamer_client_internal__ClientMachine_RetryCause("http_timeout", 7, ())
com_lightstreamer_client_internal__ClientMachine_RetryCause.recovery_timeout = com_lightstreamer_client_internal__ClientMachine_RetryCause("recovery_timeout", 8, ())
com_lightstreamer_client_internal__ClientMachine_RetryCause.page_frozen = com_lightstreamer_client_internal__ClientMachine_RetryCause("page_frozen", 10, ())
com_lightstreamer_client_internal__ClientMachine_RetryCause._hx_class = com_lightstreamer_client_internal__ClientMachine_RetryCause

class com_lightstreamer_client_internal__ClientMachine_TerminationCause(Enum):
    __slots__ = ()
    _hx_class_name = "com.lightstreamer.client.internal._ClientMachine.TerminationCause"
    _hx_constructs = ["TC_standardError", "TC_otherError", "TC_api"]

    @staticmethod
    def TC_standardError(code,msg):
        return com_lightstreamer_client_internal__ClientMachine_TerminationCause("TC_standardError", 0, (code,msg))

    @staticmethod
    def TC_otherError(error):
        return com_lightstreamer_client_internal__ClientMachine_TerminationCause("TC_otherError", 1, (error,))
com_lightstreamer_client_internal__ClientMachine_TerminationCause.TC_api = com_lightstreamer_client_internal__ClientMachine_TerminationCause("TC_api", 2, ())
com_lightstreamer_client_internal__ClientMachine_TerminationCause._hx_class = com_lightstreamer_client_internal__ClientMachine_TerminationCause

class com_lightstreamer_client_internal__ClientMachine_RecoveryRetryCause(Enum):
    __slots__ = ()
    _hx_class_name = "com.lightstreamer.client.internal._ClientMachine.RecoveryRetryCause"
    _hx_constructs = ["RRC_transport_timeout", "RRC_transport_error"]
com_lightstreamer_client_internal__ClientMachine_RecoveryRetryCause.RRC_transport_timeout = com_lightstreamer_client_internal__ClientMachine_RecoveryRetryCause("RRC_transport_timeout", 0, ())
com_lightstreamer_client_internal__ClientMachine_RecoveryRetryCause.RRC_transport_error = com_lightstreamer_client_internal__ClientMachine_RecoveryRetryCause("RRC_transport_error", 1, ())
com_lightstreamer_client_internal__ClientMachine_RecoveryRetryCause._hx_class = com_lightstreamer_client_internal__ClientMachine_RecoveryRetryCause


class com_lightstreamer_client_internal__ClientMachine_ClientMachine_Fields_:
    _hx_class_name = "com.lightstreamer.client.internal._ClientMachine.ClientMachine_Fields_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["asErrorMsg"]

    @staticmethod
    def asErrorMsg(cause):
        tmp = cause.index
        if (tmp == 0):
            return ((("" + Std.string(cause.params[0])) + " - ") + HxOverrides.stringOrNull(cause.params[1]))
        elif (tmp == 1):
            return "Websocket transport not available"
        elif (tmp == 2):
            return "Websocket error"
        elif (tmp == 3):
            return "HTTP error"
        elif (tmp == 4):
            return "idleTimeout expired"
        elif (tmp == 5):
            return "stalledTimeout expired"
        elif (tmp == 6):
            return "Websocket connect timeout expired"
        elif (tmp == 7):
            return "HTTP connect timeout expired"
        elif (tmp == 8):
            return "sessionRecoveryTimeout expired"
        elif (tmp == 9):
            return ((("Recovery counter mismatch: expected " + Std.string(cause.params[0])) + " but found ") + Std.string(cause.params[1]))
        elif (tmp == 10):
            return "page frozen"
        else:
            pass
com_lightstreamer_client_internal__ClientMachine_ClientMachine_Fields_._hx_class = com_lightstreamer_client_internal__ClientMachine_ClientMachine_Fields_


class com_lightstreamer_client_internal_Encodable:
    _hx_class_name = "com.lightstreamer.client.internal.Encodable"
    _hx_is_interface = "True"
    __slots__ = ()
    _hx_methods = ["isPending", "encode", "encodeWS"]
com_lightstreamer_client_internal_Encodable._hx_class = com_lightstreamer_client_internal_Encodable


class com_lightstreamer_client_internal_SwitchRequest:
    _hx_class_name = "com.lightstreamer.client.internal.SwitchRequest"
    _hx_is_interface = "False"
    __slots__ = ("client",)
    _hx_fields = ["client"]
    _hx_methods = ["isPending", "encode", "encodeWS"]
    _hx_interfaces = [com_lightstreamer_client_internal_Encodable]

    def __init__(self,client):
        self.client = client

    def isPending(self):
        if (self.client.state.s_m == 150):
            return (self.client.state.s_swt == 1302)
        else:
            return False

    def encode(self,isWS):
        return self.client.encodeSwitch(isWS)

    def encodeWS(self):
        return ("control\r\n" + HxOverrides.stringOrNull(self.encode(True)))

com_lightstreamer_client_internal_SwitchRequest._hx_class = com_lightstreamer_client_internal_SwitchRequest


class com_lightstreamer_client_internal_ConstrainRequest:
    _hx_class_name = "com.lightstreamer.client.internal.ConstrainRequest"
    _hx_is_interface = "False"
    __slots__ = ("client",)
    _hx_fields = ["client"]
    _hx_methods = ["isPending", "encode", "encodeWS"]
    _hx_interfaces = [com_lightstreamer_client_internal_Encodable]

    def __init__(self,client):
        self.client = client

    def isPending(self):
        return (self.client.state.s_bw == 1202)

    def encode(self,isWS):
        return self.client.encodeConstrain()

    def encodeWS(self):
        return ("control\r\n" + HxOverrides.stringOrNull(self.encode(True)))

com_lightstreamer_client_internal_ConstrainRequest._hx_class = com_lightstreamer_client_internal_ConstrainRequest


class com_lightstreamer_client_internal_StateVar_w:
    _hx_class_name = "com.lightstreamer.client.internal.StateVar_w"
    _hx_is_interface = "False"
    __slots__ = ("p", "k", "s")
    _hx_fields = ["p", "k", "s"]
    _hx_methods = ["toString"]

    def __init__(self,p,k,s):
        self.p = p
        self.k = k
        self.s = s

    def toString(self):
        return (((((("<w_p=" + Std.string(self.p)) + " w_k=") + Std.string(self.k)) + " w_s=") + Std.string(self.s)) + ">")

com_lightstreamer_client_internal_StateVar_w._hx_class = com_lightstreamer_client_internal_StateVar_w


class com_lightstreamer_client_internal_StateVar_ws:
    _hx_class_name = "com.lightstreamer.client.internal.StateVar_ws"
    _hx_is_interface = "False"
    __slots__ = ("m", "p", "k", "s")
    _hx_fields = ["m", "p", "k", "s"]
    _hx_methods = ["toString"]

    def __init__(self,m):
        self.s = None
        self.k = None
        self.p = None
        self.m = m

    def toString(self):
        _hx_str = ("<ws_m=" + Std.string(self.m))
        if (self.p is not None):
            _hx_str = (("null" if _hx_str is None else _hx_str) + HxOverrides.stringOrNull(((" ws_p=" + Std.string(self.p)))))
        if (self.k is not None):
            _hx_str = (("null" if _hx_str is None else _hx_str) + HxOverrides.stringOrNull(((" ws_k=" + Std.string(self.k)))))
        if (self.s is not None):
            _hx_str = (("null" if _hx_str is None else _hx_str) + HxOverrides.stringOrNull(((" ws_s=" + Std.string(self.s)))))
        _hx_str = (("null" if _hx_str is None else _hx_str) + ">")
        return _hx_str

com_lightstreamer_client_internal_StateVar_ws._hx_class = com_lightstreamer_client_internal_StateVar_ws


class com_lightstreamer_client_internal_StateVar_wp:
    _hx_class_name = "com.lightstreamer.client.internal.StateVar_wp"
    _hx_is_interface = "False"
    __slots__ = ("m", "p", "c", "s")
    _hx_fields = ["m", "p", "c", "s"]
    _hx_methods = ["toString"]

    def __init__(self,m):
        self.s = None
        self.c = None
        self.p = None
        self.m = m

    def toString(self):
        _hx_str = ("<wp_m=" + Std.string(self.m))
        if (self.p is not None):
            _hx_str = (("null" if _hx_str is None else _hx_str) + HxOverrides.stringOrNull(((" wp_p=" + Std.string(self.p)))))
        if (self.c is not None):
            _hx_str = (("null" if _hx_str is None else _hx_str) + HxOverrides.stringOrNull(((" wp_c=" + Std.string(self.c)))))
        if (self.s is not None):
            _hx_str = (("null" if _hx_str is None else _hx_str) + HxOverrides.stringOrNull(((" wp_s=" + Std.string(self.s)))))
        _hx_str = (("null" if _hx_str is None else _hx_str) + ">")
        return _hx_str

com_lightstreamer_client_internal_StateVar_wp._hx_class = com_lightstreamer_client_internal_StateVar_wp


class com_lightstreamer_client_internal_StateVar_hs:
    _hx_class_name = "com.lightstreamer.client.internal.StateVar_hs"
    _hx_is_interface = "False"
    __slots__ = ("m", "p", "k")
    _hx_fields = ["m", "p", "k"]
    _hx_methods = ["toString"]

    def __init__(self,m):
        self.k = None
        self.p = None
        self.m = m

    def toString(self):
        _hx_str = ("<hs_m=" + Std.string(self.m))
        if (self.p is not None):
            _hx_str = (("null" if _hx_str is None else _hx_str) + HxOverrides.stringOrNull(((" hs_p=" + Std.string(self.p)))))
        if (self.k is not None):
            _hx_str = (("null" if _hx_str is None else _hx_str) + HxOverrides.stringOrNull(((" hs_k=" + Std.string(self.k)))))
        _hx_str = (("null" if _hx_str is None else _hx_str) + ">")
        return _hx_str

com_lightstreamer_client_internal_StateVar_hs._hx_class = com_lightstreamer_client_internal_StateVar_hs


class com_lightstreamer_client_internal_StateVar_hp:
    _hx_class_name = "com.lightstreamer.client.internal.StateVar_hp"
    _hx_is_interface = "False"
    __slots__ = ("m",)
    _hx_fields = ["m"]
    _hx_methods = ["toString"]

    def __init__(self,m):
        self.m = m

    def toString(self):
        return (("<hp_m=" + Std.string(self.m)) + ">")

com_lightstreamer_client_internal_StateVar_hp._hx_class = com_lightstreamer_client_internal_StateVar_hp


class com_lightstreamer_client_internal_State:
    _hx_class_name = "com.lightstreamer.client.internal.State"
    _hx_is_interface = "False"
    __slots__ = ("s_m", "s_du", "s_tr", "s_w", "s_ws", "s_wp", "s_hs", "s_hp", "s_rec", "s_h", "s_ctrl", "s_swt", "s_bw", "s_rhb", "s_slw", "s_nr")
    _hx_fields = ["s_m", "s_du", "s_tr", "s_w", "s_ws", "s_wp", "s_hs", "s_hp", "s_rec", "s_h", "s_ctrl", "s_swt", "s_bw", "s_rhb", "s_slw", "s_nr"]
    _hx_methods = ["goto_m_from_w", "goto_m_from_ws", "goto_rec_from_w", "goto_rec_from_ws", "goto_m_from_wp", "goto_rec_from_wp", "goto_m_from_hs", "goto_m_from_rec", "goto_rec_from_hs", "goto_m_from_hp", "goto_rec_from_hp", "goto_rec", "goto_m_from_session", "goto_m_from_ctrl", "goto_200_from_rec", "clear_w", "clear_ws", "clear_wp", "clear_hs", "clear_hp", "isSwitching", "inPushing", "inStreaming", "inPolling", "inRetryUnit", "inDisconnected", "toString", "traceState"]

    def __init__(self):
        self.s_slw = None
        self.s_rhb = None
        self.s_bw = None
        self.s_swt = None
        self.s_ctrl = None
        self.s_h = None
        self.s_rec = None
        self.s_hp = None
        self.s_hs = None
        self.s_wp = None
        self.s_ws = None
        self.s_w = None
        self.s_tr = None
        self.s_m = 100
        self.s_du = 20
        self.s_nr = 1400

    def goto_m_from_w(self,m):
        self.clear_w()
        self.goto_m_from_session(m)

    def goto_m_from_ws(self,m):
        self.clear_ws()
        self.goto_m_from_session(m)

    def goto_rec_from_w(self):
        self.clear_w()
        self.goto_rec()

    def goto_rec_from_ws(self):
        self.clear_ws()
        self.goto_rec()

    def goto_m_from_wp(self,m):
        self.clear_wp()
        self.goto_m_from_session(m)

    def goto_rec_from_wp(self):
        self.clear_wp()
        self.goto_rec()

    def goto_m_from_hs(self,m):
        self.clear_hs()
        self.s_ctrl = None
        self.s_h = None
        self.goto_m_from_session(m)

    def goto_m_from_rec(self,m):
        self.s_tr = None
        self.goto_m_from_session(m)

    def goto_rec_from_hs(self):
        self.clear_hs()
        self.s_ctrl = None
        self.s_h = None
        self.goto_rec()

    def goto_m_from_hp(self,m):
        self.clear_hp()
        self.s_ctrl = None
        self.s_h = None
        self.goto_m_from_session(m)

    def goto_rec_from_hp(self):
        self.clear_hp()
        self.s_ctrl = None
        self.s_h = None
        self.goto_rec()

    def goto_rec(self):
        self.s_tr = 260
        self.s_rec = 1000
        self.traceState()

    def goto_m_from_session(self,m):
        self.s_tr = None
        self.s_swt = None
        self.s_bw = None
        self.s_m = m
        self.traceState()

    def goto_m_from_ctrl(self,m):
        self.clear_hs()
        self.clear_hp()
        self.s_ctrl = None
        self.s_h = None
        self.goto_m_from_session(m)

    def goto_200_from_rec(self):
        self.s_rec = None
        self.s_tr = 200
        self.traceState()

    def clear_w(self):
        self.s_w = None
        self.s_rhb = None
        self.s_slw = None

    def clear_ws(self):
        self.s_ws = None
        self.s_rhb = None
        self.s_slw = None

    def clear_wp(self):
        self.s_wp = None

    def clear_hs(self):
        self.s_hs = None
        self.s_rhb = None
        self.s_slw = None

    def clear_hp(self):
        self.s_hp = None
        self.s_rhb = None

    def isSwitching(self):
        if (self.s_m == 150):
            if (self.s_swt != 1302):
                return (self.s_swt == 1303)
            else:
                return True
        else:
            return False

    def inPushing(self):
        if (not self.inStreaming()):
            return self.inPolling()
        else:
            return True

    def inStreaming(self):
        tmp = None
        tmp1 = self.s_w
        if (((tmp1.p if ((tmp1 is not None)) else None)) != 300):
            tmp1 = self.s_ws
            tmp = (((tmp1.p if ((tmp1 is not None)) else None)) == 510)
        else:
            tmp = True
        if (not tmp):
            tmp = self.s_hs
            return (((tmp.p if ((tmp is not None)) else None)) == 810)
        else:
            return True

    def inPolling(self):
        tmp = None
        tmp1 = None
        if (not (((self.s_tr == 220) or ((self.s_tr == 230))))):
            tmp2 = self.s_wp
            tmp1 = (((tmp2.p if ((tmp2 is not None)) else None)) == 611)
        else:
            tmp1 = True
        if (not tmp1):
            tmp1 = self.s_hp
            tmp = (((tmp1.m if ((tmp1 is not None)) else None)) == 901)
        else:
            tmp = True
        if (not tmp):
            return (self.s_rec == 1001)
        else:
            return True

    def inRetryUnit(self):
        _g = self.s_m
        if (((((((_g == 116) or ((_g == 115))) or ((_g == 114))) or ((_g == 113))) or ((_g == 112))) or ((_g == 111))) or ((_g == 110))):
            return True
        else:
            return False

    def inDisconnected(self):
        return (self.s_m == 100)

    def toString(self):
        _hx_str = ("<m=" + Std.string(self.s_m))
        _hx_str = (("null" if _hx_str is None else _hx_str) + HxOverrides.stringOrNull(((" du=" + Std.string(self.s_du)))))
        if (self.s_tr is not None):
            _hx_str = (("null" if _hx_str is None else _hx_str) + HxOverrides.stringOrNull(((" tr=" + Std.string(self.s_tr)))))
        if (self.s_w is not None):
            _hx_str = (("null" if _hx_str is None else _hx_str) + ((" " + Std.string(self.s_w))))
        if (self.s_ws is not None):
            _hx_str = (("null" if _hx_str is None else _hx_str) + ((" " + Std.string(self.s_ws))))
        if (self.s_wp is not None):
            _hx_str = (("null" if _hx_str is None else _hx_str) + ((" " + Std.string(self.s_wp))))
        if (self.s_hs is not None):
            _hx_str = (("null" if _hx_str is None else _hx_str) + ((" " + Std.string(self.s_hs))))
        if (self.s_hp is not None):
            _hx_str = (("null" if _hx_str is None else _hx_str) + ((" " + Std.string(self.s_hp))))
        if (self.s_rec is not None):
            _hx_str = (("null" if _hx_str is None else _hx_str) + HxOverrides.stringOrNull(((" rec=" + Std.string(self.s_rec)))))
        if (self.s_h is not None):
            _hx_str = (("null" if _hx_str is None else _hx_str) + HxOverrides.stringOrNull(((" h=" + Std.string(self.s_h)))))
        if (self.s_ctrl is not None):
            _hx_str = (("null" if _hx_str is None else _hx_str) + HxOverrides.stringOrNull(((" ctrl=" + Std.string(self.s_ctrl)))))
        if (self.s_swt is not None):
            _hx_str = (("null" if _hx_str is None else _hx_str) + HxOverrides.stringOrNull(((" swt=" + Std.string(self.s_swt)))))
        if (self.s_bw is not None):
            _hx_str = (("null" if _hx_str is None else _hx_str) + HxOverrides.stringOrNull(((" bw=" + Std.string(self.s_bw)))))
        if (self.s_rhb is not None):
            _hx_str = (("null" if _hx_str is None else _hx_str) + HxOverrides.stringOrNull(((" rhb=" + Std.string(self.s_rhb)))))
        if (self.s_slw is not None):
            _hx_str = (("null" if _hx_str is None else _hx_str) + HxOverrides.stringOrNull(((" slw=" + Std.string(self.s_slw)))))
        _hx_str = (("null" if _hx_str is None else _hx_str) + HxOverrides.stringOrNull(((" nr=" + Std.string(self.s_nr)))))
        _hx_str = (("null" if _hx_str is None else _hx_str) + ">")
        return _hx_str

    def traceState(self):
        if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.internalLogger.isTraceEnabled():
            com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.internalLogger.trace(("goto: " + HxOverrides.stringOrNull(self.toString())))

com_lightstreamer_client_internal_State._hx_class = com_lightstreamer_client_internal_State


class com_lightstreamer_client_internal_MessageEventDispatcher(com_lightstreamer_internal_EventDispatcher):
    _hx_class_name = "com.lightstreamer.client.internal.MessageEventDispatcher"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["onAbort", "onDeny", "onDiscarded", "onError", "onProcessed"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = com_lightstreamer_internal_EventDispatcher


    def __init__(self):
        super().__init__()

    def onAbort(self,originalMessage,sentOnNetwork):
        def _hx_local_0(listener):
            if (listener.onAbort is not None):
                listener.onAbort(originalMessage,sentOnNetwork)
        self.dispatchToAll(_hx_local_0)

    def onDeny(self,originalMessage,code,error):
        def _hx_local_0(listener):
            if (listener.onDeny is not None):
                listener.onDeny(originalMessage,code,error)
        self.dispatchToAll(_hx_local_0)

    def onDiscarded(self,originalMessage):
        def _hx_local_0(listener):
            if (listener.onDiscarded is not None):
                listener.onDiscarded(originalMessage)
        self.dispatchToAll(_hx_local_0)

    def onError(self,originalMessage):
        def _hx_local_0(listener):
            if (listener.onError is not None):
                listener.onError(originalMessage)
        self.dispatchToAll(_hx_local_0)

    def onProcessed(self,originalMessage,response):
        def _hx_local_0(listener):
            if (listener.onProcessed is not None):
                listener.onProcessed(originalMessage,response)
        self.dispatchToAll(_hx_local_0)

com_lightstreamer_client_internal_MessageEventDispatcher._hx_class = com_lightstreamer_client_internal_MessageEventDispatcher


class com_lightstreamer_client_internal_MessageManager:
    _hx_class_name = "com.lightstreamer.client.internal.MessageManager"
    _hx_is_interface = "False"
    __slots__ = ("eventDispatcher", "txt", "sequence", "prog", "maxWait", "delegate", "enqueueWhileDisconnected", "client", "lastReqId", "s_m")
    _hx_fields = ["eventDispatcher", "txt", "sequence", "prog", "maxWait", "delegate", "enqueueWhileDisconnected", "client", "lastReqId", "s_m"]
    _hx_methods = ["finalize", "evtExtSendMessage", "evtMSGFAIL", "evtMSGDONE", "evtREQOK", "evtREQERR", "evtAbort", "evtWSSent", "isPending", "encode", "encodeWS", "doMSGDONE", "doMSGFAIL", "doREQERR", "doAbort", "encodeMsg", "fireOnProcessed", "fireOnDiscarded", "fireOnDeny", "fireOnError", "fireOnAbort", "traceEvent", "goto", "toString"]
    _hx_interfaces = [com_lightstreamer_client_internal_Encodable]

    def __init__(self,txt,sequence,maxWait,delegate,enqueueWhileDisconnected,client):
        self.s_m = None
        self.lastReqId = None
        self.prog = None
        self.eventDispatcher = com_lightstreamer_client_internal_MessageEventDispatcher()
        self.txt = txt
        self.sequence = sequence
        if ((sequence != "UNORDERED_MESSAGES") or ((delegate is not None))):
            self.prog = client.getAndSetNextMsgProg(sequence)
        else:
            self.prog = -1
        self.maxWait = maxWait
        self.delegate = delegate
        if (delegate is not None):
            self.eventDispatcher.addListener(delegate)
        self.enqueueWhileDisconnected = enqueueWhileDisconnected
        self.client = client
        if (delegate is not None):
            self.s_m = 10
        elif (sequence != "UNORDERED_MESSAGES"):
            self.s_m = 20
        else:
            self.s_m = 30
        client.relateMsgManager(self)

    def finalize(self):
        self.client.unrelateMsgManager(self)

    def evtExtSendMessage(self):
        self.traceEvent("sendMessage")
        _g = self.s_m
        if (_g == 10):
            self.goto(11)
            self.client.evtSendMessage(self)
        elif (_g == 20):
            self.goto(21)
            self.client.evtSendMessage(self)
        elif (_g == 30):
            self.goto(31)
            self.client.evtSendMessage(self)
        else:
            pass

    def evtMSGFAIL(self,code,msg):
        self.traceEvent("MSGFAIL")
        _g = self.s_m
        if (_g == 10):
            self.finalize()
            self.goto(13)
        elif (_g == 11):
            self.doMSGFAIL(code,msg)
            self.finalize()
            self.goto(14)
        elif (_g == 12):
            self.doMSGFAIL(code,msg)
            self.finalize()
            self.goto(14)
        else:
            pass

    def evtMSGDONE(self,response):
        self.traceEvent("MSGDONE")
        _g = self.s_m
        if (_g == 10):
            self.finalize()
            self.goto(13)
        elif (_g == 11):
            self.doMSGDONE(response)
            self.finalize()
            self.goto(13)
        elif (_g == 12):
            self.doMSGDONE(response)
            self.finalize()
            self.goto(13)
        else:
            pass

    def evtREQOK(self,reqId):
        self.traceEvent("REQOK")
        _g = self.s_m
        if (_g == 11):
            if (reqId == self.lastReqId):
                self.goto(12)
        elif (_g == 21):
            if (reqId == self.lastReqId):
                self.finalize()
                self.goto(22)
        elif (_g == 31):
            if (reqId == self.lastReqId):
                self.finalize()
                self.goto(33)
        else:
            pass

    def evtREQERR(self,reqId,code,msg):
        self.traceEvent("REQERR")
        _g = self.s_m
        if (_g == 11):
            if (reqId == self.lastReqId):
                self.doREQERR(code,msg)
                self.finalize()
                self.goto(14)
        elif (_g == 21):
            if (reqId == self.lastReqId):
                self.finalize()
                self.goto(23)
        elif (_g == 31):
            if (reqId == self.lastReqId):
                self.finalize()
                self.goto(34)
        else:
            pass

    def evtAbort(self):
        self.traceEvent("abort")
        _g = self.s_m
        if (_g == 11):
            self.doAbort()
            self.finalize()
            self.goto(15)
        elif (_g == 12):
            self.doAbort()
            self.finalize()
            self.goto(15)
        elif (_g == 21):
            if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.messageLogger.isWarnEnabled():
                com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.messageLogger.warn((((("Message " + HxOverrides.stringOrNull(self.sequence)) + ":") + Std.string(self.prog)) + " aborted"))
            self.finalize()
            self.goto(24)
        elif (_g == 31):
            if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.messageLogger.isWarnEnabled():
                com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.messageLogger.warn((((("Message " + HxOverrides.stringOrNull(self.sequence)) + ":") + Std.string(self.prog)) + " aborted"))
            self.finalize()
            self.goto(35)
        else:
            pass

    def evtWSSent(self):
        self.traceEvent("ws.sent")
        if (self.s_m == 31):
            self.finalize()
            self.goto(32)

    def isPending(self):
        if (not (((self.s_m == 11) or ((self.s_m == 21))))):
            return (self.s_m == 31)
        else:
            return True

    def encode(self,isWS):
        return self.encodeMsg(isWS)

    def encodeWS(self):
        return ("msg\r\n" + HxOverrides.stringOrNull(self.encode(True)))

    def doMSGDONE(self,response):
        self.fireOnProcessed(response)

    def doMSGFAIL(self,code,msg):
        if ((code == 38) or ((code == 39))):
            self.fireOnDiscarded()
        elif (code <= 0):
            self.fireOnDeny(code,msg)
        elif ((code != 32) and ((code != 33))):
            self.fireOnError()

    def doREQERR(self,code,msg):
        if ((code != 32) and ((code != 33))):
            self.fireOnError()

    def doAbort(self):
        self.fireOnAbort()

    def encodeMsg(self,isWS):
        isOrdered = (self.sequence != "UNORDERED_MESSAGES")
        hasListener = (self.delegate is not None)
        req = com_lightstreamer_internal_RequestBuilder()
        self.lastReqId = self.client.generateFreshReqId()
        req.LS_reqId(self.lastReqId)
        req.LS_message(self.txt)
        if (isOrdered and hasListener):
            req.LS_sequence(self.sequence)
            req.LS_msg_prog(self.prog)
            if (self.maxWait >= 0):
                req.LS_max_wait(self.maxWait)
        elif ((not isOrdered) and hasListener):
            req.LS_msg_prog(self.prog)
        elif (isOrdered and (not hasListener)):
            req.LS_outcome(False)
            req.LS_sequence(self.sequence)
            req.LS_msg_prog(self.prog)
            if (self.maxWait >= 0):
                req.LS_max_wait(self.maxWait)
        elif ((not isOrdered) and (not hasListener)):
            req.LS_outcome(False)
            if isWS:
                req.LS_ack(False)
        if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.protocolLogger.isInfoEnabled():
            com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.protocolLogger.info(("Sending message: " + Std.string(req)))
        return req.getEncodedString()

    def fireOnProcessed(self,response):
        if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.messageLogger.isInfoEnabled():
            com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.messageLogger.info((((("Message " + HxOverrides.stringOrNull(self.sequence)) + ":") + Std.string(self.prog)) + " processed"))
        self.eventDispatcher.onProcessed(self.txt,response)

    def fireOnDiscarded(self):
        if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.messageLogger.isWarnEnabled():
            com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.messageLogger.warn((((("Message " + HxOverrides.stringOrNull(self.sequence)) + ":") + Std.string(self.prog)) + " discarded"))
        self.eventDispatcher.onDiscarded(self.txt)

    def fireOnDeny(self,code,msg):
        if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.messageLogger.isWarnEnabled():
            com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.messageLogger.warn(((((((("Message " + HxOverrides.stringOrNull(self.sequence)) + ":") + Std.string(self.prog)) + " denied: ") + Std.string(code)) + " - ") + ("null" if msg is None else msg)))
        self.eventDispatcher.onDeny(self.txt,code,msg)

    def fireOnError(self):
        if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.messageLogger.isWarnEnabled():
            com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.messageLogger.warn((((("Message " + HxOverrides.stringOrNull(self.sequence)) + ":") + Std.string(self.prog)) + " failed"))
        self.eventDispatcher.onError(self.txt)

    def fireOnAbort(self):
        if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.messageLogger.isWarnEnabled():
            com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.messageLogger.warn((((("Message " + HxOverrides.stringOrNull(self.sequence)) + ":") + Std.string(self.prog)) + " aborted"))
        self.eventDispatcher.onAbort(self.txt,False)

    def traceEvent(self,evt):
        if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.internalLogger.isTraceEnabled():
            com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.internalLogger.trace(((((((("msg#" + ("null" if evt is None else evt)) + "(") + HxOverrides.stringOrNull(self.sequence)) + ":") + Std.string(self.prog)) + ") in ") + Std.string(self.s_m)))

    def goto(self,target):
        self.s_m = target
        if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.internalLogger.isTraceEnabled():
            com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.internalLogger.trace(((((("msg#goto(" + HxOverrides.stringOrNull(self.sequence)) + ":") + Std.string(self.prog)) + ") ") + Std.string(self.s_m)))

    def toString(self):
        _hx_map = com_lightstreamer_internal__InfoMap_InfoMap_Impl_._new()
        com_lightstreamer_internal__InfoMap_InfoMap_Impl_.set(_hx_map,"text",self.txt)
        com_lightstreamer_internal__InfoMap_InfoMap_Impl_.set(_hx_map,"sequence",self.sequence)
        com_lightstreamer_internal__InfoMap_InfoMap_Impl_.set(_hx_map,"prog",self.prog)
        com_lightstreamer_internal__InfoMap_InfoMap_Impl_.set(_hx_map,"timeout",self.maxWait)
        com_lightstreamer_internal__InfoMap_InfoMap_Impl_.set(_hx_map,"enqueueWhileDisconnected",self.enqueueWhileDisconnected)
        return _hx_map.toString()

com_lightstreamer_client_internal_MessageManager._hx_class = com_lightstreamer_client_internal_MessageManager


class com_lightstreamer_client_internal_ModeStrategy:
    _hx_class_name = "com.lightstreamer.client.internal.ModeStrategy"
    _hx_is_interface = "False"
    __slots__ = ("subscription", "realMaxFrequency", "s_m", "items", "lock", "client", "m_subId")
    _hx_fields = ["subscription", "realMaxFrequency", "s_m", "items", "lock", "client", "m_subId"]
    _hx_methods = ["finalize", "evtAbort", "evtOnSUB", "evtOnCONF", "evtOnCS", "evtOnEOS", "evtUpdate", "evtUnsubscribe", "evtOnUNSUB", "evtDispose", "evtSetRequestedMaxFrequency", "getValue", "getCommandValue", "createItem", "doSUB", "doUpdate", "doEOS", "doCS", "doCONF", "doAbort", "genDisposeItems", "selectItem", "unrelate", "traceEvent", "goto"]

    def __init__(self,sub,client,subId):
        self.realMaxFrequency = None
        self.items = haxe_ds_IntMap()
        self.s_m = 1
        self.lock = client.lock
        self.client = client
        self.subscription = sub
        self.m_subId = subId

    def finalize(self):
        pass

    def evtAbort(self):
        _gthis = self
        def _hx_local_0():
            _gthis.traceEvent("abort")
            if (_gthis.s_m == 1):
                _gthis.doAbort()
                _gthis.goto(1)
            elif (_gthis.s_m == 2):
                _gthis.doAbort()
                _gthis.goto(1)
                _gthis.genDisposeItems()
        self.lock.synchronized(_hx_local_0)

    def evtOnSUB(self,nItems,nFields,cmdIdx,keyIdx,currentFreq):
        _gthis = self
        def _hx_local_0():
            _gthis.traceEvent("onSUB")
            if (_gthis.s_m == 1):
                _gthis.doSUB(nItems,nFields)
                _gthis.goto(2)
        self.lock.synchronized(_hx_local_0)

    def evtOnCONF(self,freq):
        _gthis = self
        def _hx_local_0():
            _gthis.traceEvent("onCONF")
            if (_gthis.s_m == 2):
                _gthis.doCONF(freq)
                _gthis.goto(2)
        self.lock.synchronized(_hx_local_0)

    def evtOnCS(self,itemIdx):
        _gthis = self
        def _hx_local_0():
            _gthis.traceEvent("onCS")
            if (_gthis.s_m == 2):
                _gthis.doCS(itemIdx)
                _gthis.goto(2)
        self.lock.synchronized(_hx_local_0)

    def evtOnEOS(self,itemIdx):
        _gthis = self
        def _hx_local_0():
            _gthis.traceEvent("onEOS")
            if (_gthis.s_m == 2):
                _gthis.doEOS(itemIdx)
                _gthis.goto(2)
        self.lock.synchronized(_hx_local_0)

    def evtUpdate(self,itemIdx,values):
        _gthis = self
        def _hx_local_0():
            _gthis.traceEvent("update")
            if (_gthis.s_m == 2):
                _gthis.doUpdate(itemIdx,values)
                _gthis.goto(2)
        self.lock.synchronized(_hx_local_0)

    def evtUnsubscribe(self):
        _gthis = self
        def _hx_local_0():
            _gthis.traceEvent("unsubscribe")
            if (_gthis.s_m == 1):
                _gthis.finalize()
                _gthis.goto(3)
            elif (_gthis.s_m == 2):
                _gthis.finalize()
                _gthis.goto(3)
                _gthis.genDisposeItems()
        self.lock.synchronized(_hx_local_0)

    def evtOnUNSUB(self):
        _gthis = self
        def _hx_local_0():
            _gthis.traceEvent("onUNSUB")
            if (_gthis.s_m == 2):
                _gthis.finalize()
                _gthis.goto(3)
                _gthis.genDisposeItems()
        self.lock.synchronized(_hx_local_0)

    def evtDispose(self):
        _gthis = self
        def _hx_local_0():
            _gthis.traceEvent("dispose")
            if ((_gthis.s_m == 1) or ((_gthis.s_m == 2))):
                _gthis.finalize()
                _gthis.goto(3)
                _gthis.genDisposeItems()
        self.lock.synchronized(_hx_local_0)

    def evtSetRequestedMaxFrequency(self,freq):
        def _hx_local_0():
            return
        self.lock.synchronized(_hx_local_0)

    def getValue(self,itemPos,fieldPos):
        _gthis = self
        def _hx_local_1():
            def _hx_local_0():
                item = _gthis.items.h.get(itemPos,None)
                if (item is not None):
                    return item.getValue(fieldPos)
                else:
                    return None
            return self.lock.synchronized(_hx_local_0)
        return _hx_local_1()

    def getCommandValue(self,itemPos,key,fieldPos):
        def _hx_local_1():
            def _hx_local_0():
                raise com_lightstreamer_internal_IllegalStateException("Unsupported operation")
            return self.lock.synchronized(_hx_local_0)
        return _hx_local_1()

    def createItem(self,itemIdx):
        def _hx_local_1():
            def _hx_local_0():
                raise com_lightstreamer_internal_IllegalStateException("Abstract method")
            return self.lock.synchronized(_hx_local_0)
        return _hx_local_1()

    def doSUB(self,nItems,nFields):
        items = self.subscription.fetchItems()
        fields = self.subscription.fetchFields()
        if (not (((nItems == len(items)) if ((items is not None)) else True))):
            raise com_lightstreamer_internal_IllegalStateException(("Assertion failure: " + "items != null ? nItems == items.length : true"))
        if (not (((nFields == len(fields)) if ((fields is not None)) else True))):
            raise com_lightstreamer_internal_IllegalStateException(("Assertion failure: " + "fields != null ? nFields == fields.length : true"))

    def doUpdate(self,itemIdx,values):
        self.selectItem(itemIdx).evtUpdate(values)

    def doEOS(self,itemIdx):
        self.selectItem(itemIdx).evtOnEOS()

    def doCS(self,itemIdx):
        self.selectItem(itemIdx).evtOnCS()

    def doCONF(self,freq):
        self.realMaxFrequency = freq
        self.subscription.fireOnRealMaxFrequency(freq,self.m_subId)

    def doAbort(self):
        self.realMaxFrequency = None

    def genDisposeItems(self):
        _hx_map = self.items.copy()
        _g_keys = _hx_map.keys()
        while _g_keys.hasNext():
            _hx_map.get(_g_keys.next()).evtDispose(self)

    def selectItem(self,itemIdx):
        item = self.items.h.get(itemIdx,None)
        if (item is None):
            item = self.createItem(itemIdx)
            self.items.set(itemIdx,item)
        return item

    def unrelate(self,itemIdx):
        _gthis = self
        def _hx_local_0():
            return _gthis.items.remove(itemIdx)
        self.lock.synchronized(_hx_local_0)

    def traceEvent(self,evt):
        if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.internalLogger.isTraceEnabled():
            com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.internalLogger.trace(((((("sub#mod#" + ("null" if evt is None else evt)) + "(") + Std.string(self.m_subId)) + ") in ") + Std.string(self.s_m)))

    def goto(self,to):
        self.s_m = to
        if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.internalLogger.isTraceEnabled():
            com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.internalLogger.trace(((("sub#mod#goto(" + Std.string(self.m_subId)) + ") ") + Std.string(self.s_m)))

com_lightstreamer_client_internal_ModeStrategy._hx_class = com_lightstreamer_client_internal_ModeStrategy


class com_lightstreamer_client_internal_ModeStrategyCommand(com_lightstreamer_client_internal_ModeStrategy):
    _hx_class_name = "com.lightstreamer.client.internal.ModeStrategyCommand"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["evtOnSUB", "getCommandValue", "doSUBCMD"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = com_lightstreamer_client_internal_ModeStrategy


    def __init__(self,sub,client,subId):
        super().__init__(sub,client,subId)

    def evtOnSUB(self,nItems,nFields,cmdIdx,keyIdx,currentFreq):
        _gthis = self
        def _hx_local_0():
            _gthis.traceEvent("onSUB")
            if (_gthis.s_m == 1):
                _gthis.doSUBCMD(nItems,nFields,cmdIdx,keyIdx)
                _gthis.goto(2)
        self.lock.synchronized(_hx_local_0)

    def getCommandValue(self,itemPos,key,fieldPos):
        _gthis = self
        def _hx_local_1():
            def _hx_local_0():
                item = _gthis.items.h.get(itemPos,None)
                if (item is not None):
                    return item.getCommandValue(key,fieldPos)
                else:
                    return None
            return self.lock.synchronized(_hx_local_0)
        return _hx_local_1()

    def doSUBCMD(self,nItems,nFields,cmdIdx,keyIdx):
        items = self.subscription.fetchItems()
        fields = self.subscription.fetchFields()
        if (not (((nItems == len(items)) if ((items is not None)) else True))):
            raise com_lightstreamer_internal_IllegalStateException(("Assertion failure: " + "items != null ? nItems == items.length : true"))
        if (not (((nFields == len(fields)) if ((fields is not None)) else True))):
            raise com_lightstreamer_internal_IllegalStateException(("Assertion failure: " + "fields != null ? nFields == fields.length : true"))
        if (not ((((cmdIdx - 1) == python_internal_ArrayImpl.indexOf(fields,"command",None)) if ((fields is not None)) else True))):
            raise com_lightstreamer_internal_IllegalStateException(("Assertion failure: " + "fields != null ? cmdIdx - 1 == fields.indexOf(\"command\") : true"))
        if (not ((((keyIdx - 1) == python_internal_ArrayImpl.indexOf(fields,"key",None)) if ((fields is not None)) else True))):
            raise com_lightstreamer_internal_IllegalStateException(("Assertion failure: " + "fields != null ? keyIdx - 1 == fields.indexOf(\"key\") : true"))

com_lightstreamer_client_internal_ModeStrategyCommand._hx_class = com_lightstreamer_client_internal_ModeStrategyCommand


class com_lightstreamer_client_internal_ModeStrategyCommand1Level(com_lightstreamer_client_internal_ModeStrategyCommand):
    _hx_class_name = "com.lightstreamer.client.internal.ModeStrategyCommand1Level"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["createItem"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = com_lightstreamer_client_internal_ModeStrategyCommand


    def __init__(self,sub,client,subId):
        super().__init__(sub,client,subId)

    def createItem(self,itemIdx):
        return com_lightstreamer_client_internal_update_ItemCommand1Level(itemIdx,self.subscription,self.client,self.m_subId)

com_lightstreamer_client_internal_ModeStrategyCommand1Level._hx_class = com_lightstreamer_client_internal_ModeStrategyCommand1Level


class com_lightstreamer_client_internal_ModeStrategyCommand2Level(com_lightstreamer_client_internal_ModeStrategyCommand):
    _hx_class_name = "com.lightstreamer.client.internal.ModeStrategyCommand2Level"
    _hx_is_interface = "False"
    __slots__ = ("requestedMaxFrequency", "aggregateRealMaxFrequency")
    _hx_fields = ["requestedMaxFrequency", "aggregateRealMaxFrequency"]
    _hx_methods = ["evtOnSUB", "evtSetRequestedMaxFrequency", "evtOnRealMaxFrequency2LevelAdded", "evtOnRealMaxFrequency2LevelRemoved", "evtOnCONF", "createItem", "doSUBCMD2Level", "doSetRequestedMaxFrequency", "genSetRequestedMaxFrequency", "doCONF2Level", "maxFreq", "doAggregateFrequenciesWhenFreqIsAdded", "doAggregateFrequenciesWhenFreqIsRemoved"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = com_lightstreamer_client_internal_ModeStrategyCommand


    def __init__(self,sub,client,subId):
        self.aggregateRealMaxFrequency = None
        self.requestedMaxFrequency = None
        super().__init__(sub,client,subId)

    def evtOnSUB(self,nItems,nFields,cmdIdx,keyIdx,currentFreq):
        _gthis = self
        def _hx_local_0():
            _gthis.traceEvent("onSUB")
            if (_gthis.s_m == 1):
                _gthis.doSUBCMD2Level(nItems,nFields,cmdIdx,keyIdx,currentFreq)
                _gthis.goto(2)
        self.lock.synchronized(_hx_local_0)

    def evtSetRequestedMaxFrequency(self,freq):
        _gthis = self
        def _hx_local_0():
            _gthis.traceEvent("setRequestedMaxFrequency")
            _g = _gthis.s_m
            if ((_g == 2) or ((_g == 1))):
                _gthis.doSetRequestedMaxFrequency(freq)
                _gthis.goto(_gthis.s_m)
                _gthis.genSetRequestedMaxFrequency()
            else:
                pass
        self.lock.synchronized(_hx_local_0)

    def evtOnRealMaxFrequency2LevelAdded(self,freq):
        _gthis = self
        def _hx_local_0():
            _gthis.traceEvent("onRealMaxFrequency2LevelAdded")
            if (_gthis.s_m == 2):
                _gthis.doAggregateFrequenciesWhenFreqIsAdded(freq)
                _gthis.goto(2)
        self.lock.synchronized(_hx_local_0)

    def evtOnRealMaxFrequency2LevelRemoved(self):
        _gthis = self
        def _hx_local_0():
            _gthis.traceEvent("onRealMaxFrequency2LevelRemoved")
            if (_gthis.s_m == 2):
                _gthis.doAggregateFrequenciesWhenFreqIsRemoved()
                _gthis.goto(2)
        self.lock.synchronized(_hx_local_0)

    def evtOnCONF(self,freq):
        _gthis = self
        def _hx_local_0():
            _gthis.traceEvent("onCONF")
            if (_gthis.s_m == 2):
                _gthis.doCONF2Level(freq)
                _gthis.doAggregateFrequenciesWhenFreqIsAdded(freq)
                _gthis.goto(2)
        self.lock.synchronized(_hx_local_0)

    def createItem(self,itemIdx):
        return com_lightstreamer_client_internal_update_ItemCommand2Level(itemIdx,self.subscription,self,self.client,self.m_subId)

    def doSUBCMD2Level(self,nItems,nFields,cmdIdx,keyIdx,currentFreq):
        items = self.subscription.fetchItems()
        fields = self.subscription.fetchFields()
        if (not (((nItems == len(items)) if ((items is not None)) else True))):
            raise com_lightstreamer_internal_IllegalStateException(("Assertion failure: " + "items != null ? nItems == items.length : true"))
        if (not (((nFields == len(fields)) if ((fields is not None)) else True))):
            raise com_lightstreamer_internal_IllegalStateException(("Assertion failure: " + "fields != null ? nFields == fields.length : true"))
        if (not ((((cmdIdx - 1) == python_internal_ArrayImpl.indexOf(fields,"command",None)) if ((fields is not None)) else True))):
            raise com_lightstreamer_internal_IllegalStateException(("Assertion failure: " + "fields != null ? cmdIdx - 1 == fields.indexOf(\"command\") : true"))
        if (not ((((keyIdx - 1) == python_internal_ArrayImpl.indexOf(fields,"key",None)) if ((fields is not None)) else True))):
            raise com_lightstreamer_internal_IllegalStateException(("Assertion failure: " + "fields != null ? keyIdx - 1 == fields.indexOf(\"key\") : true"))
        self.requestedMaxFrequency = currentFreq

    def doSetRequestedMaxFrequency(self,maxFrequency):
        self.requestedMaxFrequency = maxFrequency

    def genSetRequestedMaxFrequency(self):
        this1 = self.items
        _g_keys = this1.keys()
        while _g_keys.hasNext():
            def _hx_local_1():
                _hx_local_0 = this1.get(_g_keys.next())
                if (Std.isOfType(_hx_local_0,com_lightstreamer_client_internal_update_ItemCommand2Level) or ((_hx_local_0 is None))):
                    _hx_local_0
                else:
                    raise "Class cast error"
                return _hx_local_0
            (_hx_local_1()).evtSetRequestedMaxFrequency()

    def doCONF2Level(self,maxFrequency):
        self.realMaxFrequency = maxFrequency

    def maxFreq(self,cumulated,freq):
        newMax = None
        if (cumulated is None):
            newMax = freq
        else:
            tmp = cumulated.index
            if (tmp == 0):
                _g = cumulated.params[0]
                if (freq is None):
                    newMax = cumulated
                else:
                    tmp = freq.index
                    if (tmp == 0):
                        _g1 = freq.params[0]
                        newMax = com_lightstreamer_internal_RealMaxFrequency.RFreqLimited((_g if (python_lib_Math.isnan(_g)) else (_g1 if (python_lib_Math.isnan(_g1)) else max(_g,_g1))))
                    elif (tmp == 1):
                        newMax = freq
                    else:
                        pass
            elif (tmp == 1):
                newMax = cumulated
            else:
                pass
        return newMax

    def doAggregateFrequenciesWhenFreqIsAdded(self,freq):
        newMax = self.maxFreq(self.aggregateRealMaxFrequency,freq)
        prevMax = self.aggregateRealMaxFrequency
        self.aggregateRealMaxFrequency = newMax
        if (not com_lightstreamer_internal__Types_Types_Fields_.realFrequencyEquals(prevMax,newMax)):
            self.subscription.fireOnRealMaxFrequency(newMax,self.m_subId)

    def doAggregateFrequenciesWhenFreqIsRemoved(self):
        newMax = self.realMaxFrequency
        breakOuterLoop = False
        this1 = self.items
        _g_keys = this1.keys()
        while _g_keys.hasNext():
            def _hx_local_1():
                _hx_local_0 = this1.get(_g_keys.next())
                if (Std.isOfType(_hx_local_0,com_lightstreamer_client_internal_update_ItemCommand2Level) or ((_hx_local_0 is None))):
                    _hx_local_0
                else:
                    raise "Class cast error"
                return _hx_local_0
            this2 = (_hx_local_1()).keys
            _g_keys1 = this2.keys()
            while _g_keys1.hasNext():
                def _hx_local_3():
                    _hx_local_2 = this2.get(_g_keys1.next())
                    if (Std.isOfType(_hx_local_2,com_lightstreamer_client_internal_update_Key2Level) or ((_hx_local_2 is None))):
                        _hx_local_2
                    else:
                        raise "Class cast error"
                    return _hx_local_2
                newMax = self.maxFreq(newMax,(_hx_local_3()).realMaxFrequency)
                if (newMax == com_lightstreamer_internal_RealMaxFrequency.RFreqUnlimited):
                    breakOuterLoop = True
                    break
            if breakOuterLoop:
                break
        prevMax = self.aggregateRealMaxFrequency
        self.aggregateRealMaxFrequency = newMax
        if (not com_lightstreamer_internal__Types_Types_Fields_.realFrequencyEquals(prevMax,newMax)):
            self.subscription.fireOnRealMaxFrequency(newMax,self.m_subId)

com_lightstreamer_client_internal_ModeStrategyCommand2Level._hx_class = com_lightstreamer_client_internal_ModeStrategyCommand2Level


class com_lightstreamer_client_internal_ModeStrategyDistinct(com_lightstreamer_client_internal_ModeStrategy):
    _hx_class_name = "com.lightstreamer.client.internal.ModeStrategyDistinct"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["createItem"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = com_lightstreamer_client_internal_ModeStrategy


    def __init__(self,sub,client,subId):
        super().__init__(sub,client,subId)

    def createItem(self,itemIdx):
        _gthis = self
        def _hx_local_1():
            def _hx_local_0():
                return com_lightstreamer_client_internal_update_ItemDistinct(itemIdx,_gthis.subscription,_gthis.client,_gthis.m_subId)
            return self.lock.synchronized(_hx_local_0)
        return _hx_local_1()

com_lightstreamer_client_internal_ModeStrategyDistinct._hx_class = com_lightstreamer_client_internal_ModeStrategyDistinct


class com_lightstreamer_client_internal_ModeStrategyMerge(com_lightstreamer_client_internal_ModeStrategy):
    _hx_class_name = "com.lightstreamer.client.internal.ModeStrategyMerge"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["createItem"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = com_lightstreamer_client_internal_ModeStrategy


    def __init__(self,sub,client,subId):
        super().__init__(sub,client,subId)

    def createItem(self,itemIdx):
        _gthis = self
        def _hx_local_1():
            def _hx_local_0():
                return com_lightstreamer_client_internal_update_ItemMerge(itemIdx,_gthis.subscription,_gthis.client,_gthis.m_subId)
            return self.lock.synchronized(_hx_local_0)
        return _hx_local_1()

com_lightstreamer_client_internal_ModeStrategyMerge._hx_class = com_lightstreamer_client_internal_ModeStrategyMerge


class com_lightstreamer_client_internal_ModeStrategyRaw(com_lightstreamer_client_internal_ModeStrategy):
    _hx_class_name = "com.lightstreamer.client.internal.ModeStrategyRaw"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["createItem"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = com_lightstreamer_client_internal_ModeStrategy


    def __init__(self,sub,client,subId):
        super().__init__(sub,client,subId)

    def createItem(self,itemIdx):
        _gthis = self
        def _hx_local_1():
            def _hx_local_0():
                return com_lightstreamer_client_internal_update_ItemRaw(itemIdx,_gthis.subscription,_gthis.client,_gthis.m_subId)
            return self.lock.synchronized(_hx_local_0)
        return _hx_local_1()

com_lightstreamer_client_internal_ModeStrategyRaw._hx_class = com_lightstreamer_client_internal_ModeStrategyRaw


class com_lightstreamer_client_internal_UpdateInfo:
    _hx_class_name = "com.lightstreamer.client.internal.UpdateInfo"
    _hx_is_interface = "False"
    __slots__ = ("subId", "itemIdx", "values")
    _hx_fields = ["subId", "itemIdx", "values"]

    def __init__(self,subId,itemIdx,values):
        self.subId = subId
        self.itemIdx = itemIdx
        self.values = values

com_lightstreamer_client_internal_UpdateInfo._hx_class = com_lightstreamer_client_internal_UpdateInfo


class com_lightstreamer_client_internal__ParseTools_ParseTools_Fields_:
    _hx_class_name = "com.lightstreamer.client.internal._ParseTools.ParseTools_Fields_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["parseInt", "parseFloat", "parseLong", "parseUpdate", "checkedIndexOf", "unquote", "hexToNum"]

    @staticmethod
    def parseInt(s):
        return com_lightstreamer_internal_NullTools.sure(Std.parseInt(s))

    @staticmethod
    def parseFloat(s):
        return com_lightstreamer_internal_NullTools.sure(Std.parseFloat(s))

    @staticmethod
    def parseLong(s):
        return com_lightstreamer_client_internal__ParseTools_ParseTools_Fields_.parseInt(s)

    @staticmethod
    def parseUpdate(message):
        tableIndex = (com_lightstreamer_client_internal__ParseTools_ParseTools_Fields_.checkedIndexOf(message,",") + 1)
        itemIndex = (com_lightstreamer_client_internal__ParseTools_ParseTools_Fields_.checkedIndexOf(message,",",tableIndex) + 1)
        fieldsIndex = (com_lightstreamer_client_internal__ParseTools_ParseTools_Fields_.checkedIndexOf(message,",",itemIndex) + 1)
        table = com_lightstreamer_client_internal__ParseTools_ParseTools_Fields_.parseInt(HxString.substring(message,tableIndex,(itemIndex - 1)))
        item = com_lightstreamer_client_internal__ParseTools_ParseTools_Fields_.parseInt(HxString.substring(message,itemIndex,(fieldsIndex - 1)))
        values = haxe_ds_IntMap()
        fieldStart = (fieldsIndex - 1)
        nextFieldIndex = 1
        while (fieldStart < len(message)):
            startIndex = (fieldStart + 1)
            fieldEnd = (message.find("|") if ((startIndex is None)) else HxString.indexOfImpl(message,"|",startIndex))
            if (fieldEnd == -1):
                fieldEnd = len(message)
            value = HxString.substring(message,(fieldStart + 1),fieldEnd)
            if (value == ""):
                values.set(nextFieldIndex,com_lightstreamer_internal_FieldValue.unchanged)
                nextFieldIndex = (nextFieldIndex + 1)
            elif (value == "#"):
                values.set(nextFieldIndex,com_lightstreamer_internal_FieldValue.changed(None))
                nextFieldIndex = (nextFieldIndex + 1)
            elif (value == "$"):
                values.set(nextFieldIndex,com_lightstreamer_internal_FieldValue.changed(""))
                nextFieldIndex = (nextFieldIndex + 1)
            elif ((("" if ((0 >= len(value))) else value[0])) == "^"):
                if ((("" if ((1 >= len(value))) else value[1])) == "P"):
                    unquoted = com_lightstreamer_client_internal__ParseTools_ParseTools_Fields_.unquote(HxString.substring(value,2,None))
                    try:
                        values.set(nextFieldIndex,com_lightstreamer_internal_FieldValue.jsonPatch(com_lightstreamer_internal_patch__Json_Json_Impl_._new(unquoted)))
                        nextFieldIndex = (nextFieldIndex + 1)
                    except BaseException as _g:
                        _g1 = haxe_Exception.caught(_g)
                        if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.sessionLogger.isErrorEnabled():
                            com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.sessionLogger.error(((((("Invalid JSON patch " + ("null" if unquoted is None else unquoted)) + ": ") + HxOverrides.stringOrNull(_g1.get_message())) + "\n") + HxOverrides.stringOrNull(_g1.details())))
                        raise com_lightstreamer_internal_IllegalStateException((("The JSON Patch for the field " + Std.string(nextFieldIndex)) + " is not well-formed"))
                elif ((("" if ((1 >= len(value))) else value[1])) == "T"):
                    values.set(nextFieldIndex,com_lightstreamer_internal_FieldValue.diffPatch(com_lightstreamer_client_internal__ParseTools_ParseTools_Fields_.unquote(HxString.substring(value,2,None))))
                    nextFieldIndex = (nextFieldIndex + 1)
                else:
                    count = com_lightstreamer_client_internal__ParseTools_ParseTools_Fields_.parseInt(HxString.substring(value,1,None))
                    _g2 = 0
                    while (_g2 < count):
                        _g2 = (_g2 + 1)
                        values.set(nextFieldIndex,com_lightstreamer_internal_FieldValue.unchanged)
                        nextFieldIndex = (nextFieldIndex + 1)
            else:
                values.set(nextFieldIndex,com_lightstreamer_internal_FieldValue.changed(com_lightstreamer_client_internal__ParseTools_ParseTools_Fields_.unquote(value)))
                nextFieldIndex = (nextFieldIndex + 1)
            fieldStart = fieldEnd
        return com_lightstreamer_client_internal_UpdateInfo(table,item,values)

    @staticmethod
    def checkedIndexOf(s,needle,startIndex = None):
        i = (s.find(needle) if ((startIndex is None)) else HxString.indexOfImpl(s,needle,startIndex))
        if (i == -1):
            raise com_lightstreamer_internal_IllegalStateException("string not found")
        return i

    @staticmethod
    def unquote(s):
        bb = haxe_io_Bytes.ofString(s,haxe_io_Encoding.UTF8)
        i = 0
        j = 0
        while (i < bb.length):
            if (bb.b[i] == 37):
                firstHexDigit = com_lightstreamer_client_internal__ParseTools_ParseTools_Fields_.hexToNum(bb.b[(i + 1)])
                secondHexDigit = com_lightstreamer_client_internal__ParseTools_ParseTools_Fields_.hexToNum(bb.b[(i + 2)])
                pos = j
                j = (j + 1)
                bb.b[pos] = ((((firstHexDigit << 4)) + secondHexDigit) & 255)
                i = (i + 3)
            else:
                pos1 = j
                j = (j + 1)
                pos2 = i
                i = (i + 1)
                v = bb.b[pos2]
                bb.b[pos1] = (v & 255)
        return bb.getString(0,j,haxe_io_Encoding.UTF8)

    @staticmethod
    def hexToNum(ascii):
        hex = 0
        hex = ((ascii - 97) + 10)
        if (hex <= 9):
            hex = ((ascii - 65) + 10)
            if (hex <= 9):
                hex = (ascii - 48)
        return hex
com_lightstreamer_client_internal__ParseTools_ParseTools_Fields_._hx_class = com_lightstreamer_client_internal__ParseTools_ParseTools_Fields_


class haxe_io_Bytes:
    _hx_class_name = "haxe.io.Bytes"
    _hx_is_interface = "False"
    __slots__ = ("length", "b")
    _hx_fields = ["length", "b"]
    _hx_methods = ["getString"]
    _hx_statics = ["ofString"]

    def __init__(self,length,b):
        self.length = length
        self.b = b

    def getString(self,pos,_hx_len,encoding = None):
        if (((pos < 0) or ((_hx_len < 0))) or (((pos + _hx_len) > self.length))):
            raise haxe_Exception.thrown(haxe_io_Error.OutsideBounds)
        return self.b[pos:pos+_hx_len].decode('UTF-8','replace')

    @staticmethod
    def ofString(s,encoding = None):
        b = bytearray(s,"UTF-8")
        return haxe_io_Bytes(len(b),b)

haxe_io_Bytes._hx_class = haxe_io_Bytes

class haxe_io_Encoding(Enum):
    __slots__ = ()
    _hx_class_name = "haxe.io.Encoding"
    _hx_constructs = ["UTF8", "RawNative"]
haxe_io_Encoding.UTF8 = haxe_io_Encoding("UTF8", 0, ())
haxe_io_Encoding.RawNative = haxe_io_Encoding("RawNative", 1, ())
haxe_io_Encoding._hx_class = haxe_io_Encoding


class com_lightstreamer_client_internal_Request:
    _hx_class_name = "com.lightstreamer.client.internal.Request"
    _hx_is_interface = "False"
    __slots__ = ("body",)
    _hx_fields = ["body"]
    _hx_methods = ["getByteSize", "getBody", "addSubRequest", "addSubRequestOnlyIfBodyIsLessThan"]
    _hx_statics = ["EOL_LEN", "isEmpty", "lengthOfBytes"]

    def __init__(self):
        self.body = ""

    def getByteSize(self):
        return com_lightstreamer_client_internal_Request.lengthOfBytes(self.body)

    def getBody(self):
        return self.body

    def addSubRequest(self,req):
        if com_lightstreamer_client_internal_Request.isEmpty(self.body):
            self.body = req
        else:
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.body
            _hx_local_0.body = (("null" if _hx_local_1 is None else _hx_local_1) + HxOverrides.stringOrNull((("\r\n" + ("null" if req is None else req)))))
            _hx_local_0.body

    def addSubRequestOnlyIfBodyIsLessThan(self,req,requestLimit):
        if (com_lightstreamer_client_internal_Request.isEmpty(self.body) and ((com_lightstreamer_client_internal_Request.lengthOfBytes(req) <= requestLimit))):
            self.body = req
            return True
        elif (((com_lightstreamer_client_internal_Request.lengthOfBytes(self.body) + com_lightstreamer_client_internal_Request.EOL_LEN) + com_lightstreamer_client_internal_Request.lengthOfBytes(req)) <= requestLimit):
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.body
            _hx_local_0.body = (("null" if _hx_local_1 is None else _hx_local_1) + HxOverrides.stringOrNull((("\r\n" + ("null" if req is None else req)))))
            _hx_local_0.body
            return True
        return False

    @staticmethod
    def isEmpty(s):
        return (len(s) == 0)

    @staticmethod
    def lengthOfBytes(req):
        return haxe_io_Bytes.ofString(req,haxe_io_Encoding.UTF8).length

com_lightstreamer_client_internal_Request._hx_class = com_lightstreamer_client_internal_Request


class com_lightstreamer_client_internal_RetryDelayCounter:
    _hx_class_name = "com.lightstreamer.client.internal.RetryDelayCounter"
    _hx_is_interface = "False"
    __slots__ = ("attempt", "_currentRetryDelay")
    _hx_fields = ["attempt", "_currentRetryDelay"]
    _hx_methods = ["get_currentRetryDelay", "increase", "reset"]

    def __init__(self):
        self.attempt = 1
        self._currentRetryDelay = 0

    def get_currentRetryDelay(self):
        return self._currentRetryDelay

    def increase(self):
        if (self.attempt > 10):
            if (self._currentRetryDelay < 60000):
                if ((self._currentRetryDelay * 2) < 60000):
                    _hx_local_0 = self
                    _hx_local_1 = _hx_local_0._currentRetryDelay
                    _hx_local_0._currentRetryDelay = (_hx_local_1 * 2)
                    _hx_local_0._currentRetryDelay
                else:
                    self._currentRetryDelay = 60000
        else:
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.attempt
            _hx_local_2.attempt = (_hx_local_3 + 1)
            _hx_local_2.attempt

    def reset(self,retryDelay):
        self.attempt = 1
        self._currentRetryDelay = retryDelay

com_lightstreamer_client_internal_RetryDelayCounter._hx_class = com_lightstreamer_client_internal_RetryDelayCounter


class com_lightstreamer_client_internal_SubscriptionManager:
    _hx_class_name = "com.lightstreamer.client.internal.SubscriptionManager"
    _hx_is_interface = "True"
    __slots__ = ("subId",)
    _hx_fields = ["subId"]
    _hx_methods = ["evtU", "evtSUBOK", "evtSUBCMD", "evtUNSUB", "evtEOS", "evtCS", "evtOV", "evtCONF", "evtREQOK", "evtREQERR", "evtExtAbort", "isPending", "encode", "encodeWS"]
    _hx_interfaces = [com_lightstreamer_client_internal_Encodable]
com_lightstreamer_client_internal_SubscriptionManager._hx_class = com_lightstreamer_client_internal_SubscriptionManager


class com_lightstreamer_client_internal__SubscriptionManager_State:
    _hx_class_name = "com.lightstreamer.client.internal._SubscriptionManager.State"
    _hx_is_interface = "False"
    __slots__ = ("s_m", "s_s", "s_c", "subId")
    _hx_fields = ["s_m", "s_s", "s_c", "subId"]
    _hx_methods = ["toString", "traceState"]

    def __init__(self,subId):
        self.s_c = None
        self.s_s = None
        self.subId = subId
        self.s_m = 1

    def toString(self):
        s = ("<m=" + Std.string(self.s_m))
        if (self.s_s is not None):
            s = (("null" if s is None else s) + HxOverrides.stringOrNull(((" s=" + Std.string(self.s_s)))))
        if (self.s_c is not None):
            s = (("null" if s is None else s) + HxOverrides.stringOrNull(((" c=" + Std.string(self.s_c)))))
        s = (("null" if s is None else s) + ">")
        return s

    def traceState(self):
        if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.internalLogger.isTraceEnabled():
            com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.internalLogger.trace(((("sub#goto(" + Std.string(self.subId)) + ") ") + HxOverrides.stringOrNull(self.toString())))

com_lightstreamer_client_internal__SubscriptionManager_State._hx_class = com_lightstreamer_client_internal__SubscriptionManager_State


class com_lightstreamer_client_internal_SubscriptionManagerLiving:
    _hx_class_name = "com.lightstreamer.client.internal.SubscriptionManagerLiving"
    _hx_is_interface = "False"
    __slots__ = ("subId", "m_subscription", "m_strategy", "m_lastAddReqId", "m_lastDeleteReqId", "m_lastReconfReqId", "m_currentMaxFrequency", "m_reqMaxFrequency", "m_client", "lock", "state")
    _hx_fields = ["subId", "m_subscription", "m_strategy", "m_lastAddReqId", "m_lastDeleteReqId", "m_lastReconfReqId", "m_currentMaxFrequency", "m_reqMaxFrequency", "m_client", "lock", "state"]
    _hx_methods = ["finalize", "evtExtSubscribe", "evtExtUnsubscribe", "evtExtAbort", "evtREQERR", "evtREQOK", "checkItems", "checkFields", "checkItemsAndFields", "evtSUBOK", "evtSUBCMD", "evtUNSUB", "evtU", "evtEOS", "evtCS", "evtOV", "evtCONF", "evtCheckFrequency", "evtExtConfigure", "isPending", "encode", "encodeWS", "getValue", "getCommandValue", "encodeAdd", "encodeDelete", "encodeReconf", "doSetActive", "doSetInactive", "doSubscribe", "doUnsubscribe", "doAbort", "genSendControl", "notifyOnSubscription", "notifyOnUnsubscription", "notifyOnSubscriptionError", "notifyOnSubscriptionError_CountMismatch", "doConfigure", "doREQOKConfigure", "doSUBOK", "doSUBCMD", "doUNSUB", "doU", "doEOS", "doCS", "doOV", "doCONF", "traceEvent"]
    _hx_statics = ["is2LevelCommand"]
    _hx_interfaces = [com_lightstreamer_client_internal_SubscriptionManager]

    def __init__(self,sub,client):
        self.state = None
        self.m_client = None
        self.m_reqMaxFrequency = None
        self.m_currentMaxFrequency = None
        self.m_lastReconfReqId = None
        self.m_lastDeleteReqId = None
        self.m_lastAddReqId = None
        self.m_subscription = None
        self.lock = client.lock
        self.subId = client.generateFreshSubId()
        _g = sub.fetch_mode()
        tmp = None
        if (_g == "COMMAND"):
            tmp = (com_lightstreamer_client_internal_ModeStrategyCommand2Level(sub,client,self.subId) if (com_lightstreamer_client_internal_SubscriptionManagerLiving.is2LevelCommand(sub)) else com_lightstreamer_client_internal_ModeStrategyCommand1Level(sub,client,self.subId))
        elif (_g == "DISTINCT"):
            tmp = com_lightstreamer_client_internal_ModeStrategyDistinct(sub,client,self.subId)
        elif (_g == "MERGE"):
            tmp = com_lightstreamer_client_internal_ModeStrategyMerge(sub,client,self.subId)
        elif (_g == "RAW"):
            tmp = com_lightstreamer_client_internal_ModeStrategyRaw(sub,client,self.subId)
        else:
            pass
        self.m_strategy = tmp
        self.state = com_lightstreamer_client_internal__SubscriptionManager_State(self.subId)
        self.m_client = client
        self.m_subscription = sub
        self.m_client.relateSubManager(self)
        self.m_subscription.relate(self)

    def finalize(self):
        self.m_strategy.evtDispose()
        self.m_client.unrelateSubManager(self)
        self.m_subscription.unrelate(self)

    def evtExtSubscribe(self):
        _gthis = self
        def _hx_local_0():
            _gthis.traceEvent("subscribe")
            if (_gthis.state.s_m == 1):
                _gthis.doSetActive()
                _gthis.doSubscribe()
                _gthis.state.s_m = 2
                _gthis.state.traceState()
                _gthis.genSendControl()
        self.lock.synchronized(_hx_local_0)

    def evtExtUnsubscribe(self):
        _gthis = self
        def _hx_local_0():
            _gthis.traceEvent("unsubscribe")
            if (_gthis.state.s_m == 2):
                _gthis.doSetInactive()
                _gthis.finalize()
                _gthis.state.s_m = 30
                _gthis.state.traceState()
            elif (_gthis.state.s_m == 3):
                _gthis.doUnsubscribe()
                _gthis.doSetInactive()
                _gthis.state.s_m = 5
                _gthis.state.traceState()
                _gthis.genSendControl()
            elif (_gthis.state.s_s == 10):
                _gthis.doUnsubscribe()
                _gthis.m_subscription.setInactive()
                _gthis.notifyOnUnsubscription()
                _gthis.state.s_m = 5
                _gthis.state.s_s = None
                _gthis.state.s_c = None
                _gthis.state.traceState()
                _gthis.genSendControl()
        self.lock.synchronized(_hx_local_0)

    def evtExtAbort(self):
        _gthis = self
        def _hx_local_0():
            _gthis.traceEvent("abort")
            if (_gthis.state.s_m == 2):
                _gthis.state.s_m = 2
                _gthis.state.traceState()
            elif (_gthis.state.s_m == 3):
                _gthis.doAbort()
                _gthis.doSetActive()
                _gthis.state.s_m = 2
                _gthis.state.traceState()
            elif (_gthis.state.s_s == 10):
                _gthis.doAbort()
                _gthis.doSetActive()
                _gthis.notifyOnUnsubscription()
                _gthis.state.s_s = None
                _gthis.state.s_c = None
                _gthis.state.s_m = 2
                _gthis.state.traceState()
            elif (_gthis.state.s_m == 5):
                _gthis.finalize()
                _gthis.state.s_m = 32
                _gthis.state.traceState()
        self.lock.synchronized(_hx_local_0)

    def evtREQERR(self,reqId,code,msg):
        _gthis = self
        def _hx_local_0():
            _gthis.traceEvent("REQERR")
            if ((_gthis.state.s_m == 2) and ((reqId == _gthis.m_lastAddReqId))):
                _gthis.doSetInactive()
                _gthis.notifyOnSubscriptionError(code,msg)
                _gthis.finalize()
                _gthis.state.s_m = 30
                _gthis.state.traceState()
            elif ((_gthis.state.s_m == 5) and ((reqId == _gthis.m_lastDeleteReqId))):
                _gthis.finalize()
                _gthis.state.s_m = 32
                _gthis.state.traceState()
            elif ((_gthis.state.s_c == 22) and ((reqId == _gthis.m_lastReconfReqId))):
                if com_lightstreamer_internal_RequestedMaxFrequencyTools.extEquals(_gthis.m_reqMaxFrequency,_gthis.m_subscription.fetch_requestedMaxFrequency()):
                    _gthis.state.s_c = 21
                    _gthis.state.traceState()
                else:
                    _gthis.state.s_c = 20
                    _gthis.state.traceState()
                    _gthis.evtCheckFrequency()
        self.lock.synchronized(_hx_local_0)

    def evtREQOK(self,reqId):
        _gthis = self
        def _hx_local_0():
            _gthis.traceEvent("REQOK")
            if ((_gthis.state.s_m == 2) and ((reqId == _gthis.m_lastAddReqId))):
                _gthis.state.s_m = 3
                _gthis.state.traceState()
            elif ((_gthis.state.s_m == 5) and ((reqId == _gthis.m_lastDeleteReqId))):
                _gthis.finalize()
                _gthis.state.s_m = 32
                _gthis.state.traceState()
            elif ((_gthis.state.s_c == 22) and ((reqId == _gthis.m_lastReconfReqId))):
                _gthis.doREQOKConfigure()
                _gthis.state.s_c = 20
                _gthis.state.traceState()
                _gthis.evtCheckFrequency()
        self.lock.synchronized(_hx_local_0)

    def checkItems(self,expItems,nItems):
        if (expItems is not None):
            return (expItems == nItems)
        else:
            return True

    def checkFields(self,expFields,nFields):
        if (expFields is not None):
            return (expFields == nFields)
        else:
            return True

    def checkItemsAndFields(self,expItems,expFields,nItems,nFields):
        if self.checkItems(expItems,nItems):
            return self.checkFields(expFields,nFields)
        else:
            return False

    def evtSUBOK(self,nItems,nFields):
        _gthis = self
        def _hx_local_0():
            _gthis.traceEvent("SUBOK")
            if ((_gthis.state.s_m == 2) or ((_gthis.state.s_m == 3))):
                tmp = _gthis.m_subscription.fetch_items()
                expItems = (len(tmp) if ((tmp is not None)) else None)
                tmp = _gthis.m_subscription.fetch_fields()
                expFields = (len(tmp) if ((tmp is not None)) else None)
                if _gthis.checkItemsAndFields(expItems,expFields,nItems,nFields):
                    _gthis.doSUBOK(nItems,nFields)
                    _gthis.notifyOnSubscription()
                    _gthis.state.s_m = 4
                    _gthis.state.s_s = 10
                    _gthis.state.s_c = 20
                    _gthis.state.traceState()
                    _gthis.evtCheckFrequency()
                else:
                    _gthis.doUnsubscribe()
                    _gthis.doSetInactive()
                    _gthis.notifyOnSubscriptionError_CountMismatch(expItems,expFields,nItems,nFields)
                    _gthis.state.s_m = 5
                    _gthis.state.traceState()
                    _gthis.genSendControl()
        self.lock.synchronized(_hx_local_0)

    def evtSUBCMD(self,nItems,nFields,keyIdx,cmdIdx):
        _gthis = self
        def _hx_local_0():
            _gthis.traceEvent("SUBCMD")
            if ((_gthis.state.s_m == 2) or ((_gthis.state.s_m == 3))):
                tmp = _gthis.m_subscription.fetch_items()
                expItems = (len(tmp) if ((tmp is not None)) else None)
                tmp = _gthis.m_subscription.fetch_fields()
                expFields = (len(tmp) if ((tmp is not None)) else None)
                if _gthis.checkItemsAndFields(expItems,expFields,nItems,nFields):
                    _gthis.doSUBCMD(nItems,nFields,cmdIdx,keyIdx)
                    _gthis.notifyOnSubscription()
                    _gthis.state.s_m = 4
                    _gthis.state.s_s = 10
                    _gthis.state.s_c = 20
                    _gthis.state.traceState()
                    _gthis.evtCheckFrequency()
                else:
                    _gthis.doUnsubscribe()
                    _gthis.doSetInactive()
                    _gthis.notifyOnSubscriptionError_CountMismatch(expItems,expFields,nItems,nFields)
                    _gthis.state.s_m = 5
                    _gthis.state.traceState()
                    _gthis.genSendControl()
        self.lock.synchronized(_hx_local_0)

    def evtUNSUB(self):
        _gthis = self
        def _hx_local_0():
            _gthis.traceEvent("UNSUB")
            if (_gthis.state.s_s == 10):
                _gthis.doUNSUB()
                _gthis.doSetInactive()
                _gthis.notifyOnUnsubscription()
                _gthis.finalize()
                _gthis.state.s_m = 31
                _gthis.state.s_s = None
                _gthis.state.s_c = None
                _gthis.state.traceState()
            elif (_gthis.state.s_m == 5):
                _gthis.finalize()
                _gthis.state.s_m = 32
                _gthis.state.traceState()
        self.lock.synchronized(_hx_local_0)

    def evtU(self,itemIdx,values):
        _gthis = self
        def _hx_local_0():
            _gthis.traceEvent("U")
            if (_gthis.state.s_s == 10):
                _gthis.doU(itemIdx,values)
                _gthis.state.s_s = 10
                _gthis.state.traceState()
        self.lock.synchronized(_hx_local_0)

    def evtEOS(self,itemIdx):
        _gthis = self
        def _hx_local_0():
            _gthis.traceEvent("EOS")
            if (_gthis.state.s_s == 10):
                _gthis.doEOS(itemIdx)
                _gthis.state.s_s = 10
                _gthis.state.traceState()
        self.lock.synchronized(_hx_local_0)

    def evtCS(self,itemIdx):
        _gthis = self
        def _hx_local_0():
            _gthis.traceEvent("CS")
            if (_gthis.state.s_s == 10):
                _gthis.doCS(itemIdx)
                _gthis.state.s_s = 10
                _gthis.state.traceState()
        self.lock.synchronized(_hx_local_0)

    def evtOV(self,itemIdx,lostUpdates):
        _gthis = self
        def _hx_local_0():
            _gthis.traceEvent("OV")
            if (_gthis.state.s_s == 10):
                _gthis.doOV(itemIdx,lostUpdates)
                _gthis.state.s_s = 10
                _gthis.state.traceState()
        self.lock.synchronized(_hx_local_0)

    def evtCONF(self,freq):
        _gthis = self
        def _hx_local_0():
            _gthis.traceEvent("CONF")
            if (_gthis.state.s_s == 10):
                _gthis.doCONF(freq)
                _gthis.state.s_s = 10
                _gthis.state.traceState()
        self.lock.synchronized(_hx_local_0)

    def evtCheckFrequency(self):
        _gthis = self
        def _hx_local_0():
            _gthis.traceEvent("check.frequency")
            if (_gthis.state.s_c == 20):
                if (not com_lightstreamer_internal_RequestedMaxFrequencyTools.extEquals(_gthis.m_subscription.fetch_requestedMaxFrequency(),_gthis.m_currentMaxFrequency)):
                    _gthis.doConfigure()
                    _gthis.state.s_c = 22
                    _gthis.state.traceState()
                    _gthis.genSendControl()
                else:
                    _gthis.state.s_c = 21
                    _gthis.state.traceState()
        self.lock.synchronized(_hx_local_0)

    def evtExtConfigure(self):
        _gthis = self
        def _hx_local_0():
            _gthis.traceEvent("configure")
            if (_gthis.state.s_c == 21):
                _gthis.state.s_c = 20
                _gthis.state.traceState()
                _gthis.evtCheckFrequency()
        self.lock.synchronized(_hx_local_0)

    def isPending(self):
        _gthis = self
        def _hx_local_1():
            def _hx_local_0():
                if (not (((_gthis.state.s_m == 2) or ((_gthis.state.s_m == 5))))):
                    return (_gthis.state.s_c == 22)
                else:
                    return True
            return self.lock.synchronized(_hx_local_0)
        return _hx_local_1()

    def encode(self,isWS):
        _gthis = self
        def _hx_local_1():
            def _hx_local_0():
                if (_gthis.state.s_m == 2):
                    return _gthis.encodeAdd(isWS)
                elif (_gthis.state.s_m == 5):
                    return _gthis.encodeDelete(isWS)
                elif (_gthis.state.s_c == 22):
                    return _gthis.encodeReconf(isWS)
                else:
                    raise com_lightstreamer_internal_IllegalStateException("Can't encode request")
            return self.lock.synchronized(_hx_local_0)
        return _hx_local_1()

    def encodeWS(self):
        _gthis = self
        def _hx_local_1():
            def _hx_local_0():
                return ("control\r\n" + HxOverrides.stringOrNull(_gthis.encode(True)))
            return self.lock.synchronized(_hx_local_0)
        return _hx_local_1()

    def getValue(self,itemPos,fieldPos):
        _gthis = self
        def _hx_local_1():
            def _hx_local_0():
                return _gthis.m_strategy.getValue(itemPos,fieldPos)
            return self.lock.synchronized(_hx_local_0)
        return _hx_local_1()

    def getCommandValue(self,itemPos,key,fieldPos):
        _gthis = self
        def _hx_local_1():
            def _hx_local_0():
                return _gthis.m_strategy.getCommandValue(itemPos,key,fieldPos)
            return self.lock.synchronized(_hx_local_0)
        return _hx_local_1()

    def encodeAdd(self,isWS):
        req = com_lightstreamer_internal_RequestBuilder()
        self.m_lastAddReqId = self.m_client.generateFreshReqId()
        req.LS_reqId(self.m_lastAddReqId)
        req.LS_op("add")
        req.LS_subId(self.subId)
        req.LS_mode(self.m_subscription.fetch_mode())
        group = self.m_subscription.getItemGroup()
        items = self.m_subscription.fetchItems()
        if (group is not None):
            req.LS_group(group)
        elif (items is not None):
            req.LS_group(" ".join([python_Boot.toString1(x1,'') for x1 in items]))
        schema = self.m_subscription.getFieldSchema()
        fields = self.m_subscription.fetchFields()
        if (schema is not None):
            req.LS_schema(schema)
        elif (fields is not None):
            req.LS_schema(" ".join([python_Boot.toString1(x1,'') for x1 in fields]))
        adapter = self.m_subscription.getDataAdapter()
        if (adapter is not None):
            req.LS_data_adapter(adapter)
        selector = self.m_subscription.getSelector()
        if (selector is not None):
            req.LS_selector(selector)
        snapshot = self.m_subscription.fetch_requestedSnapshot()
        if (snapshot is not None):
            tmp = snapshot.index
            if (tmp == 0):
                req.LS_snapshot(True)
            elif (tmp == 1):
                req.LS_snapshot(False)
            elif (tmp == 2):
                req.LS_snapshot_Int(snapshot.params[0])
            else:
                pass
        freq = self.m_currentMaxFrequency
        if (freq is not None):
            tmp = freq.index
            if (tmp == 0):
                req.LS_requested_max_frequency_Float(freq.params[0])
            elif (tmp == 1):
                req.LS_requested_max_frequency("unlimited")
            elif (tmp == 2):
                req.LS_requested_max_frequency("unfiltered")
            else:
                pass
        buff = self.m_subscription.fetch_requestedBufferSize()
        if (buff is not None):
            tmp = buff.index
            if (tmp == 0):
                req.LS_requested_buffer_size_Int(buff.params[0])
            elif (tmp == 1):
                req.LS_requested_buffer_size("unlimited")
            else:
                pass
        if isWS:
            req.LS_ack(False)
        if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.protocolLogger.isInfoEnabled():
            com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.protocolLogger.info(("Sending Subscription add: " + Std.string(req)))
        return req.getEncodedString()

    def encodeDelete(self,isWS):
        req = com_lightstreamer_internal_RequestBuilder()
        self.m_lastDeleteReqId = self.m_client.generateFreshReqId()
        req.LS_reqId(self.m_lastDeleteReqId)
        req.LS_subId(self.subId)
        req.LS_op("delete")
        if isWS:
            req.LS_ack(False)
        if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.protocolLogger.isInfoEnabled():
            com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.protocolLogger.info(("Sending Subscription delete: " + Std.string(req)))
        return req.getEncodedString()

    def encodeReconf(self,isWS):
        req = com_lightstreamer_internal_RequestBuilder()
        self.m_lastReconfReqId = self.m_client.generateFreshReqId()
        req.LS_reqId(self.m_lastReconfReqId)
        req.LS_subId(self.subId)
        req.LS_op("reconf")
        freq = self.m_reqMaxFrequency
        if (freq is not None):
            tmp = freq.index
            if (tmp == 0):
                req.LS_requested_max_frequency_Float(freq.params[0])
            elif (tmp == 1):
                req.LS_requested_max_frequency("unlimited")
            elif (tmp == 2):
                req.LS_requested_max_frequency("unfiltered")
            else:
                pass
        if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.protocolLogger.isInfoEnabled():
            com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.protocolLogger.info(("Sending Subscription configuration: " + Std.string(req)))
        return req.getEncodedString()

    def doSetActive(self):
        self.m_subscription.setActive()

    def doSetInactive(self):
        self.m_subscription.setInactive()

    def doSubscribe(self):
        self.m_currentMaxFrequency = self.m_subscription.fetch_requestedMaxFrequency()

    def doUnsubscribe(self):
        self.m_strategy.evtUnsubscribe()
        self.m_subscription.unrelate(self)

    def doAbort(self):
        self.m_lastAddReqId = None
        self.m_lastDeleteReqId = None
        self.m_lastReconfReqId = None
        self.m_reqMaxFrequency = None
        self.m_currentMaxFrequency = self.m_subscription.fetch_requestedMaxFrequency()
        self.m_strategy.evtAbort()

    def genSendControl(self):
        self.m_client.evtSendControl(self)

    def notifyOnSubscription(self):
        self.m_subscription.fireOnSubscription(self.subId)

    def notifyOnUnsubscription(self):
        self.m_subscription.fireOnUnsubscription(self.subId)

    def notifyOnSubscriptionError(self,code,msg):
        self.m_subscription.fireOnSubscriptionError(self.subId,code,msg)

    def notifyOnSubscriptionError_CountMismatch(self,expItems,expFields,nItems,nFields):
        if (not self.checkItems(expItems,nItems)):
            self.m_subscription.fireOnSubscriptionError(self.subId,61,((("Expected " + Std.string(expItems)) + " items but got ") + Std.string(nItems)))
        else:
            self.m_subscription.fireOnSubscriptionError(self.subId,61,((("Expected " + Std.string(expFields)) + " fields but got ") + Std.string(nFields)))

    def doConfigure(self):
        self.m_reqMaxFrequency = self.m_subscription.fetch_requestedMaxFrequency()
        self.m_strategy.evtSetRequestedMaxFrequency(self.m_reqMaxFrequency)

    def doREQOKConfigure(self):
        self.m_currentMaxFrequency = self.m_reqMaxFrequency

    def doSUBOK(self,nItems,nFields):
        self.m_subscription.setSubscribed(self.subId,nItems,nFields)
        self.m_strategy.evtOnSUB(nItems,nFields,None,None,None)

    def doSUBCMD(self,nItems,nFields,cmdIdx,keyIdx):
        self.m_subscription.setSubscribedCMD(self.subId,nItems,nFields,cmdIdx,keyIdx)
        self.m_strategy.evtOnSUB(nItems,nFields,cmdIdx,keyIdx,self.m_currentMaxFrequency)

    def doUNSUB(self):
        self.m_strategy.evtOnUNSUB()

    def doU(self,itemIdx,values):
        if (itemIdx > com_lightstreamer_internal_NullTools.sure(self.m_subscription.fetch_nItems())):
            raise com_lightstreamer_internal_IllegalStateException(("Assertion failure: " + "itemIdx <= m_subscription.fetch_nItems().sure()"))
        self.m_strategy.evtUpdate(itemIdx,values)

    def doEOS(self,itemIdx):
        self.m_strategy.evtOnEOS(itemIdx)
        self.m_subscription.fireOnEndOfSnapshot(itemIdx,self.subId)

    def doCS(self,itemIdx):
        self.m_strategy.evtOnCS(itemIdx)
        self.m_subscription.fireOnClearSnapshot(itemIdx,self.subId)

    def doOV(self,itemIdx,lostUpdates):
        self.m_subscription.fireOnLostUpdates(itemIdx,lostUpdates,self.subId)

    def doCONF(self,freq):
        self.m_strategy.evtOnCONF(freq)

    def traceEvent(self,evt):
        if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.internalLogger.isTraceEnabled():
            com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.internalLogger.trace(((((("sub#" + ("null" if evt is None else evt)) + "(") + Std.string(self.subId)) + ") in ") + Std.string(self.state)))

    @staticmethod
    def is2LevelCommand(sub):
        if (sub.fetch_mode() == "COMMAND"):
            if (sub.getCommandSecondLevelFields() is None):
                return (sub.getCommandSecondLevelFieldSchema() is not None)
            else:
                return True
        else:
            return False

com_lightstreamer_client_internal_SubscriptionManagerLiving._hx_class = com_lightstreamer_client_internal_SubscriptionManagerLiving


class com_lightstreamer_client_internal_SubscriptionManagerZombie:
    _hx_class_name = "com.lightstreamer.client.internal.SubscriptionManagerZombie"
    _hx_is_interface = "False"
    __slots__ = ("subId", "s_m", "lock", "m_lastDeleteReqId", "m_client")
    _hx_fields = ["subId", "s_m", "lock", "m_lastDeleteReqId", "m_client"]
    _hx_methods = ["finalize", "evtExtAbort", "evtREQERR", "evtREQOK", "evtSUBOK", "evtSUBCMD", "evtUNSUB", "evtU", "evtEOS", "evtCS", "evtOV", "evtCONF", "isPending", "encode", "encodeWS", "genSendControl", "encodeDelete", "traceEvent", "goto"]
    _hx_interfaces = [com_lightstreamer_client_internal_SubscriptionManager]

    def __init__(self,subId,client):
        self.m_lastDeleteReqId = None
        self.s_m = 1
        self.subId = subId
        self.lock = client.lock
        self.m_client = client
        client.relateSubManager(self)

    def finalize(self):
        self.m_client.unrelateSubManager(self)

    def evtExtAbort(self):
        _gthis = self
        def _hx_local_0():
            _gthis.traceEvent("abort")
            if (_gthis.s_m == 2):
                _gthis.finalize()
                _gthis.goto(3)
        self.lock.synchronized(_hx_local_0)

    def evtREQERR(self,reqId,code,msg):
        _gthis = self
        def _hx_local_0():
            _gthis.traceEvent("REQERR")
            if ((_gthis.s_m == 2) and ((reqId == _gthis.m_lastDeleteReqId))):
                _gthis.finalize()
                _gthis.goto(3)
        self.lock.synchronized(_hx_local_0)

    def evtREQOK(self,reqId):
        _gthis = self
        def _hx_local_0():
            _gthis.traceEvent("REQOK")
            if ((_gthis.s_m == 2) and ((reqId == _gthis.m_lastDeleteReqId))):
                _gthis.finalize()
                _gthis.goto(3)
        self.lock.synchronized(_hx_local_0)

    def evtSUBOK(self,nItems,nFields):
        _gthis = self
        def _hx_local_0():
            _gthis.traceEvent("SUBOK")
            if (_gthis.s_m == 1):
                _gthis.goto(2)
                _gthis.genSendControl()
        self.lock.synchronized(_hx_local_0)

    def evtSUBCMD(self,nItems,nFields,keyIdx,cmdIdx):
        _gthis = self
        def _hx_local_0():
            _gthis.traceEvent("SUBCMD")
            if (_gthis.s_m == 1):
                _gthis.goto(2)
                _gthis.genSendControl()
        self.lock.synchronized(_hx_local_0)

    def evtUNSUB(self):
        _gthis = self
        def _hx_local_0():
            _gthis.traceEvent("UNSUB")
            if (_gthis.s_m == 2):
                _gthis.finalize()
                _gthis.goto(3)
        self.lock.synchronized(_hx_local_0)

    def evtU(self,itemIdx,values):
        _gthis = self
        def _hx_local_0():
            _gthis.traceEvent("U")
            if (_gthis.s_m == 1):
                _gthis.goto(2)
                _gthis.genSendControl()
        self.lock.synchronized(_hx_local_0)

    def evtEOS(self,itemIdx):
        _gthis = self
        def _hx_local_0():
            _gthis.traceEvent("EOS")
            if (_gthis.s_m == 1):
                _gthis.goto(2)
                _gthis.genSendControl()
        self.lock.synchronized(_hx_local_0)

    def evtCS(self,itemIdx):
        _gthis = self
        def _hx_local_0():
            _gthis.traceEvent("CS")
            if (_gthis.s_m == 1):
                _gthis.goto(2)
                _gthis.genSendControl()
        self.lock.synchronized(_hx_local_0)

    def evtOV(self,itemIdx,lostUpdates):
        _gthis = self
        def _hx_local_0():
            _gthis.traceEvent("OV")
            if (_gthis.s_m == 1):
                _gthis.goto(2)
                _gthis.genSendControl()
        self.lock.synchronized(_hx_local_0)

    def evtCONF(self,freq):
        _gthis = self
        def _hx_local_0():
            _gthis.traceEvent("CONF")
            if (_gthis.s_m == 1):
                _gthis.goto(2)
                _gthis.genSendControl()
        self.lock.synchronized(_hx_local_0)

    def isPending(self):
        _gthis = self
        def _hx_local_1():
            def _hx_local_0():
                return (_gthis.s_m == 2)
            return self.lock.synchronized(_hx_local_0)
        return _hx_local_1()

    def encode(self,isWS):
        _gthis = self
        def _hx_local_1():
            def _hx_local_0():
                if _gthis.isPending():
                    return _gthis.encodeDelete(isWS)
                else:
                    raise com_lightstreamer_internal_IllegalStateException("Can't encode unsubscription request")
            return self.lock.synchronized(_hx_local_0)
        return _hx_local_1()

    def encodeWS(self):
        _gthis = self
        def _hx_local_1():
            def _hx_local_0():
                return ("control\r\n" + HxOverrides.stringOrNull(_gthis.encode(True)))
            return self.lock.synchronized(_hx_local_0)
        return _hx_local_1()

    def genSendControl(self):
        self.m_client.evtSendControl(self)

    def encodeDelete(self,isWS):
        req = com_lightstreamer_internal_RequestBuilder()
        self.m_lastDeleteReqId = self.m_client.generateFreshReqId()
        req.LS_reqId(self.m_lastDeleteReqId)
        req.LS_subId(self.subId)
        req.LS_op("delete")
        if isWS:
            req.LS_ack(False)
        req.LS_cause("zombie")
        if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.protocolLogger.isInfoEnabled():
            com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.protocolLogger.info(("Sending Subscription delete: " + Std.string(req)))
        return req.getEncodedString()

    def traceEvent(self,evt):
        if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.internalLogger.isTraceEnabled():
            com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.internalLogger.trace(((((("zsub#" + ("null" if evt is None else evt)) + "(") + Std.string(self.subId)) + ") in ") + Std.string(self.s_m)))

    def goto(self,target):
        self.s_m = target
        if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.internalLogger.isTraceEnabled():
            com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.internalLogger.trace(((("zsub#goto(" + Std.string(self.subId)) + ") ") + Std.string(self.s_m)))

com_lightstreamer_client_internal_SubscriptionManagerZombie._hx_class = com_lightstreamer_client_internal_SubscriptionManagerZombie


class com_lightstreamer_client_internal_update_AbstractItemUpdate:
    _hx_class_name = "com.lightstreamer.client.internal.update.AbstractItemUpdate"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_methods = ["isValueChanged", "isSnapshot", "getValueAsJSONPatchIfAvailable", "getValue", "getItemPos", "getItemName", "getFieldsByPosition", "getFields", "getChangedFieldsByPosition", "getChangedFields"]
    _hx_interfaces = [com_lightstreamer_client_ItemUpdate]

com_lightstreamer_client_internal_update_AbstractItemUpdate._hx_class = com_lightstreamer_client_internal_update_AbstractItemUpdate


class com_lightstreamer_client_internal_update_ItemBase:
    _hx_class_name = "com.lightstreamer.client.internal.update.ItemBase"
    _hx_is_interface = "False"
    __slots__ = ("m_subId", "itemIdx", "currValues", "subscription", "client", "lock")
    _hx_fields = ["m_subId", "itemIdx", "currValues", "subscription", "client", "lock"]
    _hx_methods = ["finalize", "evtUpdate", "evtOnEOS", "evtOnCS", "evtDispose", "getValue", "getCommandValue", "fatalError", "doFirstUpdate", "doUpdate0", "doFirstSnapshot", "doSnapshot", "doUpdate"]

    def __init__(self,itemIdx,sub,client,subId):
        self.currValues = None
        self.m_subId = subId
        self.itemIdx = itemIdx
        self.subscription = sub
        self.client = client
        self.lock = client.lock

    def finalize(self):
        def _hx_local_0():
            return
        self.lock.synchronized(_hx_local_0)

    def evtUpdate(self,values):
        _gthis = self
        def _hx_local_0():
            _gthis.fatalError()
        self.lock.synchronized(_hx_local_0)

    def evtOnEOS(self):
        _gthis = self
        def _hx_local_0():
            _gthis.fatalError()
        self.lock.synchronized(_hx_local_0)

    def evtOnCS(self):
        _gthis = self
        def _hx_local_0():
            _gthis.fatalError()
        self.lock.synchronized(_hx_local_0)

    def evtDispose(self,strategy):
        _gthis = self
        def _hx_local_0():
            _gthis.fatalError()
        self.lock.synchronized(_hx_local_0)

    def getValue(self,fieldIdx):
        _gthis = self
        def _hx_local_1():
            def _hx_local_0():
                if (_gthis.currValues is not None):
                    return com_lightstreamer_client_internal_update_CurrFieldValTools.toString(_gthis.currValues.h.get(fieldIdx,None))
                else:
                    return None
            return self.lock.synchronized(_hx_local_0)
        return _hx_local_1()

    def getCommandValue(self,keyName,fieldIdx):
        def _hx_local_1():
            def _hx_local_0():
                raise com_lightstreamer_internal_IllegalStateException("Unsupported operation")
            return self.lock.synchronized(_hx_local_0)
        return _hx_local_1()

    def fatalError(self):
        raise com_lightstreamer_internal_IllegalStateException("Unsupported operation")

    def doFirstUpdate(self,values):
        self.doUpdate(values,False)

    def doUpdate0(self,values):
        self.doUpdate(values,False)

    def doFirstSnapshot(self,values):
        self.doUpdate(values,True)

    def doSnapshot(self,values):
        self.doUpdate(values,True)

    def doUpdate(self,values,snapshot):
        prevValues = self.currValues
        self.currValues = com_lightstreamer_client_internal_update__UpdateUtils_UpdateUtils_Fields_.applyUpatesToCurrentFields(prevValues,values)
        changedFields = com_lightstreamer_client_internal_update__UpdateUtils_UpdateUtils_Fields_.findChangedFields(prevValues,self.currValues)
        jsonPatches = com_lightstreamer_client_internal_update__UpdateUtils_UpdateUtils_Fields_.computeJsonPatches(prevValues,values)
        update = com_lightstreamer_client_internal_update_ItemUpdateBase(self.itemIdx,self.subscription,self.currValues,changedFields,snapshot,jsonPatches)
        self.subscription.fireOnItemUpdate(update,self.m_subId)

com_lightstreamer_client_internal_update_ItemBase._hx_class = com_lightstreamer_client_internal_update_ItemBase


class com_lightstreamer_client_internal_update_ItemCommand(com_lightstreamer_client_internal_update_ItemBase):
    _hx_class_name = "com.lightstreamer.client.internal.update.ItemCommand"
    _hx_is_interface = "False"
    __slots__ = ("keys", "s_m")
    _hx_fields = ["keys", "s_m"]
    _hx_methods = ["finalize", "unrelate", "evtUpdate", "evtOnEOS", "evtOnCS", "evtDispose", "getCommandValue", "createKey", "doUpdate", "genDisposeKeys", "selectKey", "goto", "traceEvent"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = com_lightstreamer_client_internal_update_ItemBase


    def __init__(self,itemIdx,sub,client,subId):
        self.s_m = None
        self.keys = haxe_ds_StringMap()
        super().__init__(itemIdx,sub,client,subId)
        self.s_m = (3 if (sub.hasSnapshot()) else 1)

    def finalize(self):
        pass

    def unrelate(self,keyName):
        _gthis = self
        def _hx_local_0():
            return _gthis.keys.remove(keyName)
        self.lock.synchronized(_hx_local_0)

    def evtUpdate(self,values):
        _gthis = self
        def _hx_local_0():
            _gthis.traceEvent("update")
            _g = _gthis.s_m
            if (_g == 1):
                _gthis.doFirstUpdate(values)
                _gthis.goto(2)
            elif (_g == 2):
                _gthis.doUpdate0(values)
                _gthis.goto(2)
            elif (_g == 3):
                _gthis.doFirstSnapshot(values)
                _gthis.goto(4)
            elif (_g == 4):
                _gthis.doSnapshot(values)
                _gthis.goto(4)
            else:
                pass
        self.lock.synchronized(_hx_local_0)

    def evtOnEOS(self):
        _gthis = self
        def _hx_local_0():
            _gthis.traceEvent("onEOS")
            _g = _gthis.s_m
            if (_g == 3):
                _gthis.goto(1)
            elif (_g == 4):
                _gthis.goto(2)
            else:
                pass
        self.lock.synchronized(_hx_local_0)

    def evtOnCS(self):
        def _hx_local_0():
            raise com_lightstreamer_internal_IllegalStateException("Unsupported method")
        self.lock.synchronized(_hx_local_0)

    def evtDispose(self,strategy):
        _gthis = self
        def _hx_local_0():
            _gthis.traceEvent("dispose")
            _g = _gthis.s_m
            if ((((_g == 4) or ((_g == 3))) or ((_g == 2))) or ((_g == 1))):
                _gthis.finalize()
                _gthis.goto(5)
                _gthis.genDisposeKeys()
                strategy.unrelate(_gthis.itemIdx)
            else:
                pass
        self.lock.synchronized(_hx_local_0)

    def getCommandValue(self,keyName,fieldIdx):
        _gthis = self
        def _hx_local_1():
            def _hx_local_0():
                key = _gthis.keys.h.get(keyName,None)
                if (key is not None):
                    return key.getCommandValue(fieldIdx)
                else:
                    return None
            return self.lock.synchronized(_hx_local_0)
        return _hx_local_1()

    def createKey(self,keyName):
        raise com_lightstreamer_internal_IllegalStateException("Abstract method")

    def doUpdate(self,values,snapshot):
        self.currValues = com_lightstreamer_client_internal_update__UpdateUtils_UpdateUtils_Fields_.applyUpatesToCurrentFields(self.currValues,values)
        self.selectKey().evtUpdate(self.currValues,snapshot)

    def genDisposeKeys(self):
        _hx_map = self.keys.copy()
        _g_keys = _hx_map.keys()
        while _g_keys.hasNext():
            _hx_map.get(_g_keys.next()).evtDispose()

    def selectKey(self):
        this1 = self.currValues
        key = self.subscription.getKeyPosition()
        keyName = com_lightstreamer_client_internal_update_CurrFieldValTools.toString(this1.h.get(key,None))
        key = self.keys.h.get(keyName,None)
        if (key is None):
            key = self.createKey(keyName)
            self.keys.h[keyName] = key
        return key

    def goto(self,to):
        self.s_m = to
        if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.internalLogger.isTraceEnabled():
            com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.internalLogger.trace(((((("sub#itm#goto(" + Std.string(self.m_subId)) + ":") + Std.string(self.itemIdx)) + ") in ") + Std.string(self.s_m)))

    def traceEvent(self,evt):
        if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.internalLogger.isTraceEnabled():
            com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.internalLogger.trace(((((((("sub#itm#" + ("null" if evt is None else evt)) + "(") + Std.string(self.m_subId)) + ":") + Std.string(self.itemIdx)) + ") in ") + Std.string(self.s_m)))

com_lightstreamer_client_internal_update_ItemCommand._hx_class = com_lightstreamer_client_internal_update_ItemCommand


class com_lightstreamer_client_internal_update_ItemCommand1Level(com_lightstreamer_client_internal_update_ItemCommand):
    _hx_class_name = "com.lightstreamer.client.internal.update.ItemCommand1Level"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["evtOnCS", "createKey"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = com_lightstreamer_client_internal_update_ItemCommand


    def __init__(self,itemIdx,sub,client,subId):
        super().__init__(itemIdx,sub,client,subId)

    def evtOnCS(self):
        _gthis = self
        def _hx_local_0():
            _gthis.traceEvent("onCS")
            _g = _gthis.s_m
            if ((((_g == 4) or ((_g == 3))) or ((_g == 2))) or ((_g == 1))):
                _gthis.goto(_gthis.s_m)
                _gthis.genDisposeKeys()
            else:
                pass
        self.lock.synchronized(_hx_local_0)

    def createKey(self,keyName):
        return com_lightstreamer_client_internal_update_Key1Level(keyName,self)

com_lightstreamer_client_internal_update_ItemCommand1Level._hx_class = com_lightstreamer_client_internal_update_ItemCommand1Level


class com_lightstreamer_client_internal_update_ItemCommand2Level(com_lightstreamer_client_internal_update_ItemCommand):
    _hx_class_name = "com.lightstreamer.client.internal.update.ItemCommand2Level"
    _hx_is_interface = "False"
    __slots__ = ("strategy",)
    _hx_fields = ["strategy"]
    _hx_methods = ["evtOnCS", "evtSetRequestedMaxFrequency", "createKey", "genSetRequestedMaxFrequency", "genOnRealMaxFrequency2LevelRemoved"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = com_lightstreamer_client_internal_update_ItemCommand


    def __init__(self,itemIdx,sub,strategy,client,subId):
        self.strategy = None
        super().__init__(itemIdx,sub,client,subId)
        self.strategy = strategy

    def evtOnCS(self):
        _gthis = self
        def _hx_local_0():
            _gthis.traceEvent("onCS")
            _g = _gthis.s_m
            if ((((_g == 4) or ((_g == 3))) or ((_g == 2))) or ((_g == 1))):
                _gthis.goto(_gthis.s_m)
                _gthis.genDisposeKeys()
                _gthis.genOnRealMaxFrequency2LevelRemoved()
            else:
                pass
        self.lock.synchronized(_hx_local_0)

    def evtSetRequestedMaxFrequency(self):
        _gthis = self
        def _hx_local_0():
            _gthis.traceEvent("setRequestedMaxFrequency")
            _g = _gthis.s_m
            if ((((_g == 4) or ((_g == 3))) or ((_g == 2))) or ((_g == 1))):
                _gthis.goto(_gthis.s_m)
                _gthis.genSetRequestedMaxFrequency()
            else:
                pass
        self.lock.synchronized(_hx_local_0)

    def createKey(self,keyName):
        return com_lightstreamer_client_internal_update_Key2Level(keyName,self)

    def genSetRequestedMaxFrequency(self):
        this1 = self.keys
        _g_keys = this1.keys()
        while _g_keys.hasNext():
            this1.get(_g_keys.next()).evtSetRequestedMaxFrequency()

    def genOnRealMaxFrequency2LevelRemoved(self):
        self.strategy.evtOnRealMaxFrequency2LevelRemoved()

com_lightstreamer_client_internal_update_ItemCommand2Level._hx_class = com_lightstreamer_client_internal_update_ItemCommand2Level


class com_lightstreamer_client_internal_update_ItemDistinct(com_lightstreamer_client_internal_update_ItemBase):
    _hx_class_name = "com.lightstreamer.client.internal.update.ItemDistinct"
    _hx_is_interface = "False"
    __slots__ = ("s_m",)
    _hx_fields = ["s_m"]
    _hx_methods = ["evtUpdate", "evtOnEOS", "evtOnCS", "evtDispose", "goto", "traceEvent"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = com_lightstreamer_client_internal_update_ItemBase


    def __init__(self,itemIdx,sub,client,subId):
        self.s_m = None
        super().__init__(itemIdx,sub,client,subId)
        self.s_m = (3 if (sub.hasSnapshot()) else 1)

    def evtUpdate(self,values):
        _gthis = self
        def _hx_local_0():
            _gthis.traceEvent("update")
            _g = _gthis.s_m
            if (_g == 1):
                _gthis.doFirstUpdate(values)
                _gthis.goto(2)
            elif (_g == 2):
                _gthis.doUpdate0(values)
                _gthis.goto(2)
            elif (_g == 3):
                _gthis.doFirstSnapshot(values)
                _gthis.goto(4)
            elif (_g == 4):
                _gthis.doSnapshot(values)
                _gthis.goto(4)
            else:
                pass
        self.lock.synchronized(_hx_local_0)

    def evtOnEOS(self):
        _gthis = self
        def _hx_local_0():
            _gthis.traceEvent("onEOS")
            _g = _gthis.s_m
            if (_g == 3):
                _gthis.goto(1)
            elif (_g == 4):
                _gthis.goto(2)
            else:
                pass
        self.lock.synchronized(_hx_local_0)

    def evtOnCS(self):
        def _hx_local_0():
            return
        self.lock.synchronized(_hx_local_0)

    def evtDispose(self,strategy):
        _gthis = self
        def _hx_local_0():
            _gthis.traceEvent("dispose")
            _g = _gthis.s_m
            if ((((_g == 4) or ((_g == 3))) or ((_g == 2))) or ((_g == 1))):
                _gthis.finalize()
                _gthis.goto(5)
                strategy.unrelate(_gthis.itemIdx)
            else:
                pass
        self.lock.synchronized(_hx_local_0)

    def goto(self,to):
        self.s_m = to
        if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.internalLogger.isTraceEnabled():
            com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.internalLogger.trace(((((("sub#itm#goto(" + Std.string(self.m_subId)) + ":") + Std.string(self.itemIdx)) + ") ") + Std.string(self.s_m)))

    def traceEvent(self,evt):
        if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.internalLogger.isTraceEnabled():
            com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.internalLogger.trace(((((((("sub#itm#" + ("null" if evt is None else evt)) + "(") + Std.string(self.m_subId)) + ":") + Std.string(self.itemIdx)) + ") in ") + Std.string(self.s_m)))

com_lightstreamer_client_internal_update_ItemDistinct._hx_class = com_lightstreamer_client_internal_update_ItemDistinct


class com_lightstreamer_client_internal_update_ItemKey:
    _hx_class_name = "com.lightstreamer.client.internal.update.ItemKey"
    _hx_is_interface = "True"
    __slots__ = ()
    _hx_methods = ["evtUpdate", "evtSetRequestedMaxFrequency", "evtDispose", "getCommandValue"]
com_lightstreamer_client_internal_update_ItemKey._hx_class = com_lightstreamer_client_internal_update_ItemKey


class com_lightstreamer_client_internal_update_ItemMerge(com_lightstreamer_client_internal_update_ItemBase):
    _hx_class_name = "com.lightstreamer.client.internal.update.ItemMerge"
    _hx_is_interface = "False"
    __slots__ = ("s_m",)
    _hx_fields = ["s_m"]
    _hx_methods = ["evtUpdate", "evtDispose", "goto", "traceEvent"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = com_lightstreamer_client_internal_update_ItemBase


    def __init__(self,itemIdx,sub,client,subId):
        self.s_m = 1
        super().__init__(itemIdx,sub,client,subId)

    def evtUpdate(self,values):
        _gthis = self
        def _hx_local_0():
            _gthis.traceEvent("update")
            _g = _gthis.s_m
            if (_g == 1):
                if _gthis.subscription.hasSnapshot():
                    _gthis.doSnapshot(values)
                    _gthis.goto(2)
                else:
                    _gthis.doFirstUpdate(values)
                    _gthis.goto(3)
            elif (_g == 2):
                _gthis.doUpdate0(values)
                _gthis.goto(3)
            elif (_g == 3):
                _gthis.doUpdate0(values)
                _gthis.goto(3)
            else:
                pass
        self.lock.synchronized(_hx_local_0)

    def evtDispose(self,strategy):
        _gthis = self
        def _hx_local_0():
            _gthis.traceEvent("dispose")
            _g = _gthis.s_m
            if (((_g == 3) or ((_g == 2))) or ((_g == 1))):
                _gthis.finalize()
                _gthis.goto(4)
                strategy.unrelate(_gthis.itemIdx)
            else:
                pass
        self.lock.synchronized(_hx_local_0)

    def goto(self,to):
        self.s_m = to
        if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.internalLogger.isTraceEnabled():
            com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.internalLogger.trace(((((("sub#itm#goto(" + Std.string(self.m_subId)) + ":") + Std.string(self.itemIdx)) + ") ") + Std.string(self.s_m)))

    def traceEvent(self,evt):
        if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.internalLogger.isTraceEnabled():
            com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.internalLogger.trace(((((((("sub#itm#" + ("null" if evt is None else evt)) + "(") + Std.string(self.m_subId)) + ":") + Std.string(self.itemIdx)) + ") in ") + Std.string(self.s_m)))

com_lightstreamer_client_internal_update_ItemMerge._hx_class = com_lightstreamer_client_internal_update_ItemMerge


class com_lightstreamer_client_internal_update_ItemRaw(com_lightstreamer_client_internal_update_ItemBase):
    _hx_class_name = "com.lightstreamer.client.internal.update.ItemRaw"
    _hx_is_interface = "False"
    __slots__ = ("s_m",)
    _hx_fields = ["s_m"]
    _hx_methods = ["evtUpdate", "evtDispose", "goto", "traceEvent"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = com_lightstreamer_client_internal_update_ItemBase


    def __init__(self,itemIdx,sub,client,subId):
        self.s_m = 1
        super().__init__(itemIdx,sub,client,subId)

    def evtUpdate(self,values):
        _gthis = self
        def _hx_local_0():
            _gthis.traceEvent("update")
            _g = _gthis.s_m
            if (_g == 1):
                _gthis.doFirstUpdate(values)
                _gthis.goto(2)
            elif (_g == 2):
                _gthis.doUpdate0(values)
                _gthis.goto(2)
            else:
                pass
        self.lock.synchronized(_hx_local_0)

    def evtDispose(self,strategy):
        _gthis = self
        def _hx_local_0():
            _gthis.traceEvent("dispose")
            _g = _gthis.s_m
            if ((_g == 2) or ((_g == 1))):
                _gthis.finalize()
                _gthis.goto(3)
                strategy.unrelate(_gthis.itemIdx)
            else:
                pass
        self.lock.synchronized(_hx_local_0)

    def goto(self,to):
        self.s_m = to
        if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.internalLogger.isTraceEnabled():
            com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.internalLogger.trace(((((("sub#itm#goto(" + Std.string(self.m_subId)) + ":") + Std.string(self.itemIdx)) + ") ") + Std.string(self.s_m)))

    def traceEvent(self,evt):
        if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.internalLogger.isTraceEnabled():
            com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.internalLogger.trace(((((((("sub#itm#" + ("null" if evt is None else evt)) + "(") + Std.string(self.m_subId)) + ":") + Std.string(self.itemIdx)) + ") in ") + Std.string(self.s_m)))

com_lightstreamer_client_internal_update_ItemRaw._hx_class = com_lightstreamer_client_internal_update_ItemRaw


class com_lightstreamer_client_internal_update_ItemUpdate2Level(com_lightstreamer_client_internal_update_AbstractItemUpdate):
    _hx_class_name = "com.lightstreamer.client.internal.update.ItemUpdate2Level"
    _hx_is_interface = "False"
    __slots__ = ("m_itemIdx", "m_items", "m_nFields", "m_fields", "m_fields2", "m_newValues", "m_changedFields", "m_isSnapshot", "m_jsonPatches")
    _hx_fields = ["m_itemIdx", "m_items", "m_nFields", "m_fields", "m_fields2", "m_newValues", "m_changedFields", "m_isSnapshot", "m_jsonPatches"]
    _hx_methods = ["getItemName", "getItemPos", "isSnapshot", "getValue", "isValueChanged", "_getValueAsJSONPatchIfAvailable", "getValueAsJSONPatchIfAvailable", "getChangedFields", "getChangedFieldsByPosition", "getFields", "getFieldsByPosition", "getValuePos", "getValueName", "isValueChangedPos", "isValueChangedName", "getFieldNameFromIdx", "getFieldIdxFromName", "toString"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = com_lightstreamer_client_internal_update_AbstractItemUpdate


    def __init__(self,itemIdx,sub,newValues,changedFields,isSnapshot,jsonPatches):
        items = sub.fetch_items()
        fields = sub.fetch_fields()
        fields2 = sub.fetch_fields2()
        self.m_itemIdx = itemIdx
        self.m_items = com_lightstreamer_client_internal_update__UpdateUtils_UpdateUtils_Fields_.toMap(items)
        self.m_nFields = com_lightstreamer_internal_NullTools.sure(sub.fetch_nFields())
        self.m_fields = com_lightstreamer_client_internal_update__UpdateUtils_UpdateUtils_Fields_.toMap(fields)
        self.m_fields2 = com_lightstreamer_client_internal_update__UpdateUtils_UpdateUtils_Fields_.toMap(fields2)
        self.m_newValues = newValues.copy()
        self.m_changedFields = changedFields.copy()
        self.m_isSnapshot = isSnapshot
        self.m_jsonPatches = jsonPatches

    def getItemName(self):
        if (self.m_items is not None):
            return self.m_items.h.get(self.m_itemIdx,None)
        else:
            return None

    def getItemPos(self):
        return self.m_itemIdx

    def isSnapshot(self):
        return self.m_isSnapshot

    def getValue(self,fieldNameOrPos):
        if Std.isOfType(fieldNameOrPos,Int):
            return self.getValuePos(fieldNameOrPos)
        else:
            return self.getValueName(Std.string(fieldNameOrPos))

    def isValueChanged(self,fieldNameOrPos):
        if Std.isOfType(fieldNameOrPos,Int):
            return self.isValueChangedPos(fieldNameOrPos)
        else:
            return self.isValueChangedName(Std.string(fieldNameOrPos))

    def _getValueAsJSONPatchIfAvailable(self,fieldNameOrPos):
        if Std.isOfType(fieldNameOrPos,Int):
            return self.m_jsonPatches.h.get(fieldNameOrPos,None)
        else:
            fieldPos = self.getFieldIdxFromName(Std.string(fieldNameOrPos))
            if (fieldPos is not None):
                return self.m_jsonPatches.h.get(fieldPos,None)
            else:
                return None

    def getValueAsJSONPatchIfAvailable(self,fieldNameOrPos):
        val = self._getValueAsJSONPatchIfAvailable(fieldNameOrPos)
        if (val is not None):
            return val
        else:
            return None

    def getChangedFields(self):
        if ((self.m_fields is None) or ((self.m_fields2 is None))):
            raise com_lightstreamer_internal_IllegalStateException(com_lightstreamer_client_internal_update__ItemUpdateBase_ItemUpdateBase_Fields_.NO_FIELDS)
        res = haxe_ds_StringMap()
        _g = self.m_changedFields.iterator()
        while (_g.current < len(_g.array)):
            def _hx_local_1():
                _hx_local_0 = _g.current
                _g.current = (_g.current + 1)
                return _hx_local_0
            fieldPos = python_internal_ArrayImpl._get(_g.array, _hx_local_1())
            fieldName = self.getFieldNameFromIdx(fieldPos)
            if (fieldName is not None):
                v = com_lightstreamer_client_internal_update_CurrFieldValTools.toString(self.m_newValues.h.get(fieldPos,None))
                res.h[fieldName] = v
        return com_lightstreamer_internal__NativeTypes_NativeStringMap_Impl_._new(res)

    def getChangedFieldsByPosition(self):
        res = haxe_ds_IntMap()
        _g = self.m_changedFields.iterator()
        while (_g.current < len(_g.array)):
            def _hx_local_1():
                _hx_local_0 = _g.current
                _g.current = (_g.current + 1)
                return _hx_local_0
            fieldPos = python_internal_ArrayImpl._get(_g.array, _hx_local_1())
            v = com_lightstreamer_client_internal_update_CurrFieldValTools.toString(self.m_newValues.h.get(fieldPos,None))
            res.set(fieldPos,v)
        return com_lightstreamer_internal__NativeTypes_NativeIntMap_Impl_._new(res)

    def getFields(self):
        if ((self.m_fields is None) or ((self.m_fields2 is None))):
            raise com_lightstreamer_internal_IllegalStateException(com_lightstreamer_client_internal_update__ItemUpdateBase_ItemUpdateBase_Fields_.NO_FIELDS)
        res = haxe_ds_StringMap()
        this1 = self.m_newValues
        _g_keys = this1.keys()
        while _g_keys.hasNext():
            key = _g_keys.next()
            _g_value = this1.get(key)
            fieldName = self.getFieldNameFromIdx(key)
            if (fieldName is not None):
                v = com_lightstreamer_client_internal_update_CurrFieldValTools.toString(_g_value)
                res.h[fieldName] = v
        return com_lightstreamer_internal__NativeTypes_NativeStringMap_Impl_._new(res)

    def getFieldsByPosition(self):
        _g = haxe_ds_IntMap()
        this1 = self.m_newValues
        _g_keys = this1.keys()
        while _g_keys.hasNext():
            key = _g_keys.next()
            _g.set(key,com_lightstreamer_client_internal_update_CurrFieldValTools.toString(this1.get(key)))
        return com_lightstreamer_internal__NativeTypes_NativeIntMap_Impl_._new(_g)

    def getValuePos(self,fieldPos):
        return com_lightstreamer_client_internal_update_CurrFieldValTools.toString(self.m_newValues.h.get(fieldPos,None))

    def getValueName(self,fieldName):
        if ((self.m_fields is None) and ((self.m_fields2 is None))):
            raise com_lightstreamer_internal_IllegalStateException(com_lightstreamer_client_internal_update__ItemUpdateBase_ItemUpdateBase_Fields_.NO_FIELDS)
        fieldPos = self.getFieldIdxFromName(fieldName)
        if (fieldPos is None):
            raise com_lightstreamer_internal_IllegalArgumentException(com_lightstreamer_client_internal_update__ItemUpdateBase_ItemUpdateBase_Fields_.UNKNOWN_FIELD_NAME)
        return com_lightstreamer_client_internal_update_CurrFieldValTools.toString(self.m_newValues.h.get(fieldPos,None))

    def isValueChangedPos(self,fieldPos):
        return self.m_changedFields.contains(fieldPos)

    def isValueChangedName(self,fieldName):
        if ((self.m_fields is None) and ((self.m_fields2 is None))):
            raise com_lightstreamer_internal_IllegalStateException(com_lightstreamer_client_internal_update__ItemUpdateBase_ItemUpdateBase_Fields_.NO_FIELDS)
        fieldPos = self.getFieldIdxFromName(fieldName)
        if (fieldPos is None):
            raise com_lightstreamer_internal_IllegalArgumentException(com_lightstreamer_client_internal_update__ItemUpdateBase_ItemUpdateBase_Fields_.UNKNOWN_FIELD_NAME)
        return self.m_changedFields.contains(fieldPos)

    def getFieldNameFromIdx(self,fieldIdx):
        if (fieldIdx <= self.m_nFields):
            if (self.m_fields is not None):
                return self.m_fields.h.get(fieldIdx,None)
            else:
                return None
        elif (self.m_fields2 is not None):
            return self.m_fields2.h.get((fieldIdx - self.m_nFields),None)
        else:
            return None

    def getFieldIdxFromName(self,fieldName):
        fields2 = None
        fieldPos = None
        tmp = None
        fields = self.m_fields
        if (fields is not None):
            fieldPos = com_lightstreamer_client_internal_update__UpdateUtils_UpdateUtils_Fields_.findFirstIndex(com_lightstreamer_internal_NullTools.sure(fields),fieldName)
            tmp = (fieldPos is not None)
        else:
            tmp = False
        if tmp:
            return fieldPos
        else:
            tmp = None
            fields2 = self.m_fields2
            if (fields2 is not None):
                fieldPos = com_lightstreamer_client_internal_update__UpdateUtils_UpdateUtils_Fields_.findFirstIndex(com_lightstreamer_internal_NullTools.sure(fields2),fieldName)
                tmp = (fieldPos is not None)
            else:
                tmp = False
            if tmp:
                return (self.m_nFields + com_lightstreamer_internal_NullTools.sure(fieldPos))
            else:
                return None

    def toString(self):
        s_b = python_lib_io_StringIO()
        s_b.write("[")
        this1 = self.m_newValues
        _g_keys = this1.keys()
        while _g_keys.hasNext():
            key = _g_keys.next()
            _g_value = this1.get(key)
            tmp = self.getFieldNameFromIdx(key)
            fieldName = (tmp if ((tmp is not None)) else Std.string(key))
            fieldVal = Std.string(_g_value)
            if (key > 1):
                s_b.write(",")
            s_b.write(Std.string(fieldName))
            s_b.write(":")
            s_b.write(Std.string(fieldVal))
        s_b.write("]")
        return s_b.getvalue()

com_lightstreamer_client_internal_update_ItemUpdate2Level._hx_class = com_lightstreamer_client_internal_update_ItemUpdate2Level


class com_lightstreamer_client_internal_update_ItemUpdateBase(com_lightstreamer_client_internal_update_AbstractItemUpdate):
    _hx_class_name = "com.lightstreamer.client.internal.update.ItemUpdateBase"
    _hx_is_interface = "False"
    __slots__ = ("m_itemIdx", "m_items", "m_nFields", "m_fields", "m_newValues", "m_changedFields", "m_isSnapshot", "m_jsonPatches")
    _hx_fields = ["m_itemIdx", "m_items", "m_nFields", "m_fields", "m_newValues", "m_changedFields", "m_isSnapshot", "m_jsonPatches"]
    _hx_methods = ["getItemName", "getItemPos", "isSnapshot", "getValue", "isValueChanged", "_getValueAsJSONPatchIfAvailable", "getValueAsJSONPatchIfAvailable", "getChangedFields", "getChangedFieldsByPosition", "getFields", "getFieldsByPosition", "getValuePos", "getValueName", "isValueChangedPos", "isValueChangedName", "getFieldNameOrNullFromIdx", "getFieldIdxFromName", "toString"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = com_lightstreamer_client_internal_update_AbstractItemUpdate


    def __init__(self,itemIdx,sub,newValues,changedFields,isSnapshot,jsonPatches):
        self.m_jsonPatches = None
        self.m_isSnapshot = None
        self.m_changedFields = None
        self.m_newValues = None
        items = sub.fetch_items()
        fields = sub.fetch_fields()
        self.m_itemIdx = itemIdx
        self.m_items = com_lightstreamer_client_internal_update__UpdateUtils_UpdateUtils_Fields_.toMap(items)
        self.m_nFields = com_lightstreamer_internal_NullTools.sure(sub.fetch_nFields())
        self.m_fields = com_lightstreamer_client_internal_update__UpdateUtils_UpdateUtils_Fields_.toMap(fields)
        if ((fields is not None) and ((len(fields) != self.m_nFields))):
            if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.subscriptionLogger.isErrorEnabled():
                com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.subscriptionLogger.error(((((("Expected " + Std.string(self.m_nFields)) + " field names but got ") + Std.string(len(fields))) + ": ") + Std.string(fields)))
        self.m_newValues = newValues.copy()
        self.m_changedFields = changedFields.copy()
        self.m_isSnapshot = isSnapshot
        self.m_jsonPatches = jsonPatches

    def getItemName(self):
        if (self.m_items is not None):
            return self.m_items.h.get(self.m_itemIdx,None)
        else:
            return None

    def getItemPos(self):
        return self.m_itemIdx

    def isSnapshot(self):
        return self.m_isSnapshot

    def getValue(self,fieldNameOrPos):
        if Std.isOfType(fieldNameOrPos,Int):
            return self.getValuePos(fieldNameOrPos)
        else:
            return self.getValueName(Std.string(fieldNameOrPos))

    def isValueChanged(self,fieldNameOrPos):
        if Std.isOfType(fieldNameOrPos,Int):
            return self.isValueChangedPos(fieldNameOrPos)
        else:
            return self.isValueChangedName(Std.string(fieldNameOrPos))

    def _getValueAsJSONPatchIfAvailable(self,fieldNameOrPos):
        if Std.isOfType(fieldNameOrPos,Int):
            return self.m_jsonPatches.h.get(fieldNameOrPos,None)
        else:
            fieldPos = self.getFieldIdxFromName(Std.string(fieldNameOrPos))
            return self.m_jsonPatches.h.get(fieldPos,None)

    def getValueAsJSONPatchIfAvailable(self,fieldNameOrPos):
        val = self._getValueAsJSONPatchIfAvailable(fieldNameOrPos)
        if (val is not None):
            return com_lightstreamer_internal_patch__Json_Json_Impl_.toString(val)
        else:
            return None

    def getChangedFields(self):
        if (self.m_fields is None):
            raise com_lightstreamer_internal_IllegalStateException(com_lightstreamer_client_internal_update__ItemUpdateBase_ItemUpdateBase_Fields_.NO_FIELDS)
        res = haxe_ds_StringMap()
        _g = self.m_changedFields.iterator()
        while (_g.current < len(_g.array)):
            def _hx_local_1():
                _hx_local_0 = _g.current
                _g.current = (_g.current + 1)
                return _hx_local_0
            fieldPos = python_internal_ArrayImpl._get(_g.array, _hx_local_1())
            fieldName = self.m_fields.h.get(fieldPos,None)
            if (fieldName is not None):
                v = com_lightstreamer_client_internal_update_CurrFieldValTools.toString(self.m_newValues.h.get(fieldPos,None))
                res.h[fieldName] = v
        return com_lightstreamer_internal__NativeTypes_NativeStringMap_Impl_._new(res)

    def getChangedFieldsByPosition(self):
        res = haxe_ds_IntMap()
        _g = self.m_changedFields.iterator()
        while (_g.current < len(_g.array)):
            def _hx_local_1():
                _hx_local_0 = _g.current
                _g.current = (_g.current + 1)
                return _hx_local_0
            fieldPos = python_internal_ArrayImpl._get(_g.array, _hx_local_1())
            v = com_lightstreamer_client_internal_update_CurrFieldValTools.toString(self.m_newValues.h.get(fieldPos,None))
            res.set(fieldPos,v)
        return com_lightstreamer_internal__NativeTypes_NativeIntMap_Impl_._new(res)

    def getFields(self):
        if (self.m_fields is None):
            raise com_lightstreamer_internal_IllegalStateException(com_lightstreamer_client_internal_update__ItemUpdateBase_ItemUpdateBase_Fields_.NO_FIELDS)
        res = haxe_ds_StringMap()
        this1 = self.m_fields
        _g_keys = this1.keys()
        while _g_keys.hasNext():
            key = _g_keys.next()
            _g_value = this1.get(key)
            v = com_lightstreamer_client_internal_update_CurrFieldValTools.toString(self.m_newValues.h.get(key,None))
            res.h[_g_value] = v
        return com_lightstreamer_internal__NativeTypes_NativeStringMap_Impl_._new(res)

    def getFieldsByPosition(self):
        _g = haxe_ds_IntMap()
        this1 = self.m_newValues
        _g_keys = this1.keys()
        while _g_keys.hasNext():
            key = _g_keys.next()
            _g.set(key,com_lightstreamer_client_internal_update_CurrFieldValTools.toString(this1.get(key)))
        return com_lightstreamer_internal__NativeTypes_NativeIntMap_Impl_._new(_g)

    def getValuePos(self,fieldPos):
        if (not (((1 <= fieldPos) and ((fieldPos <= self.m_nFields))))):
            raise com_lightstreamer_internal_IllegalArgumentException(com_lightstreamer_client_internal_update__ItemUpdateBase_ItemUpdateBase_Fields_.POS_OUT_BOUNDS)
        return com_lightstreamer_client_internal_update_CurrFieldValTools.toString(self.m_newValues.h.get(fieldPos,None))

    def getValueName(self,fieldName):
        fieldPos = self.getFieldIdxFromName(fieldName)
        return com_lightstreamer_client_internal_update_CurrFieldValTools.toString(self.m_newValues.h.get(fieldPos,None))

    def isValueChangedPos(self,fieldPos):
        if (not (((1 <= fieldPos) and ((fieldPos <= self.m_nFields))))):
            raise com_lightstreamer_internal_IllegalArgumentException(com_lightstreamer_client_internal_update__ItemUpdateBase_ItemUpdateBase_Fields_.POS_OUT_BOUNDS)
        return self.m_changedFields.contains(fieldPos)

    def isValueChangedName(self,fieldName):
        fieldPos = self.getFieldIdxFromName(fieldName)
        return self.m_changedFields.contains(fieldPos)

    def getFieldNameOrNullFromIdx(self,fieldIdx):
        if (self.m_fields is not None):
            return self.m_fields.h.get(fieldIdx,None)
        else:
            return None

    def getFieldIdxFromName(self,fieldName):
        if (self.m_fields is None):
            raise com_lightstreamer_internal_IllegalStateException(com_lightstreamer_client_internal_update__ItemUpdateBase_ItemUpdateBase_Fields_.NO_FIELDS)
        fieldPos = com_lightstreamer_client_internal_update__UpdateUtils_UpdateUtils_Fields_.findFirstIndex(self.m_fields,fieldName)
        if (fieldPos is None):
            raise com_lightstreamer_internal_IllegalArgumentException(com_lightstreamer_client_internal_update__ItemUpdateBase_ItemUpdateBase_Fields_.UNKNOWN_FIELD_NAME)
        return fieldPos

    def toString(self):
        s_b = python_lib_io_StringIO()
        s_b.write("[")
        this1 = self.m_newValues
        _g_keys = this1.keys()
        while _g_keys.hasNext():
            key = _g_keys.next()
            _g_value = this1.get(key)
            tmp = self.getFieldNameOrNullFromIdx(key)
            fieldName = (tmp if ((tmp is not None)) else Std.string(key))
            fieldVal = Std.string(_g_value)
            if (key > 1):
                s_b.write(",")
            s_b.write(Std.string(fieldName))
            s_b.write(":")
            s_b.write(Std.string(fieldVal))
        s_b.write("]")
        return s_b.getvalue()

com_lightstreamer_client_internal_update_ItemUpdateBase._hx_class = com_lightstreamer_client_internal_update_ItemUpdateBase


class com_lightstreamer_client_internal_update__ItemUpdateBase_ItemUpdateBase_Fields_:
    _hx_class_name = "com.lightstreamer.client.internal.update._ItemUpdateBase.ItemUpdateBase_Fields_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["NO_FIELDS", "POS_OUT_BOUNDS", "UNKNOWN_FIELD_NAME"]
com_lightstreamer_client_internal_update__ItemUpdateBase_ItemUpdateBase_Fields_._hx_class = com_lightstreamer_client_internal_update__ItemUpdateBase_ItemUpdateBase_Fields_


class com_lightstreamer_client_internal_update_Key1Level:
    _hx_class_name = "com.lightstreamer.client.internal.update.Key1Level"
    _hx_is_interface = "False"
    __slots__ = ("keyName", "item", "currKeyValues", "s_m", "lock")
    _hx_fields = ["keyName", "item", "currKeyValues", "s_m", "lock"]
    _hx_methods = ["finalize", "evtUpdate", "evtDispose", "evtSetRequestedMaxFrequency", "getCommandValue", "doFirstUpdate", "doUpdate", "doLightDelete", "doDelete", "nullify", "isDelete", "fireOnItemUpdate", "goto", "traceEvent"]
    _hx_interfaces = [com_lightstreamer_client_internal_update_ItemKey]

    def __init__(self,keyName,item):
        self.currKeyValues = None
        self.s_m = 1
        self.keyName = keyName
        self.item = item
        self.lock = item.lock

    def finalize(self):
        self.currKeyValues = None
        self.item.unrelate(self.keyName)

    def evtUpdate(self,keyValues,snapshot):
        _gthis = self
        def _hx_local_0():
            _gthis.traceEvent("update")
            _g = _gthis.s_m
            if (_g == 1):
                if (not _gthis.isDelete(keyValues)):
                    _gthis.doFirstUpdate(keyValues,snapshot)
                    _gthis.goto(2)
                else:
                    _gthis.doLightDelete(keyValues,snapshot)
                    _gthis.finalize()
                    _gthis.goto(3)
            elif (_g == 2):
                if (not _gthis.isDelete(keyValues)):
                    _gthis.doUpdate(keyValues,snapshot)
                    _gthis.goto(2)
                else:
                    _gthis.doDelete(keyValues,snapshot)
                    _gthis.finalize()
                    _gthis.goto(3)
            else:
                pass
        self.lock.synchronized(_hx_local_0)

    def evtDispose(self):
        _gthis = self
        def _hx_local_0():
            _gthis.traceEvent("dispose")
            _g = _gthis.s_m
            if ((_g == 2) or ((_g == 1))):
                _gthis.finalize()
                _gthis.goto(3)
            else:
                pass
        self.lock.synchronized(_hx_local_0)

    def evtSetRequestedMaxFrequency(self):
        def _hx_local_0():
            return
        self.lock.synchronized(_hx_local_0)

    def getCommandValue(self,fieldIdx):
        _gthis = self
        def _hx_local_1():
            def _hx_local_0():
                if (_gthis.currKeyValues is not None):
                    return com_lightstreamer_client_internal_update_CurrFieldValTools.toString(_gthis.currKeyValues.h.get(fieldIdx,None))
                else:
                    return None
            return self.lock.synchronized(_hx_local_0)
        return _hx_local_1()

    def doFirstUpdate(self,keyValues,snapshot):
        nFields = com_lightstreamer_internal_NullTools.sure(self.item.subscription.fetch_nFields())
        cmdIdx = self.item.subscription.getCommandPosition()
        self.currKeyValues = keyValues
        self.currKeyValues.set(cmdIdx,com_lightstreamer_client_internal_update_CurrFieldVal.StringVal("ADD"))
        changedFields = com_lightstreamer_internal_Set(IntIterator(1,(nFields + 1)))
        self.fireOnItemUpdate(com_lightstreamer_client_internal_update_ItemUpdateBase(self.item.itemIdx,self.item.subscription,self.currKeyValues,changedFields,snapshot,haxe_ds_IntMap()))

    def doUpdate(self,keyValues,snapshot):
        cmdIdx = self.item.subscription.getCommandPosition()
        prevKeyValues = self.currKeyValues
        self.currKeyValues = keyValues
        self.currKeyValues.set(cmdIdx,com_lightstreamer_client_internal_update_CurrFieldVal.StringVal("UPDATE"))
        changedFields = com_lightstreamer_client_internal_update__UpdateUtils_UpdateUtils_Fields_.findChangedFields(prevKeyValues,self.currKeyValues)
        self.fireOnItemUpdate(com_lightstreamer_client_internal_update_ItemUpdateBase(self.item.itemIdx,self.item.subscription,self.currKeyValues,changedFields,snapshot,haxe_ds_IntMap()))

    def doLightDelete(self,keyValues,snapshot):
        self.currKeyValues = None
        changedFields = com_lightstreamer_internal_Set(keyValues.keys())
        update = com_lightstreamer_client_internal_update_ItemUpdateBase(self.item.itemIdx,self.item.subscription,self.nullify(keyValues),changedFields,snapshot,haxe_ds_IntMap())
        self.item.unrelate(self.keyName)
        self.fireOnItemUpdate(update)

    def doDelete(self,keyValues,snapshot):
        self.currKeyValues = None
        changedFields = com_lightstreamer_internal_Set(keyValues.keys()).subtracting([self.item.subscription.getKeyPosition()])
        update = com_lightstreamer_client_internal_update_ItemUpdateBase(self.item.itemIdx,self.item.subscription,self.nullify(keyValues),changedFields,snapshot,haxe_ds_IntMap())
        self.item.unrelate(self.keyName)
        self.fireOnItemUpdate(update)

    def nullify(self,keyValues):
        values = haxe_ds_IntMap()
        _hx_map = keyValues
        _g_keys = _hx_map.keys()
        while _g_keys.hasNext():
            key = _g_keys.next()
            _g_value = _hx_map.get(key)
            values.set(key,(_g_value if (((key == self.item.subscription.getCommandPosition()) or ((key == self.item.subscription.getKeyPosition())))) else None))
        return values

    def isDelete(self,keyValues):
        key = self.item.subscription.getCommandPosition()
        return (com_lightstreamer_client_internal_update_CurrFieldValTools.toString(keyValues.h.get(key,None)) == "DELETE")

    def fireOnItemUpdate(self,update):
        self.item.subscription.fireOnItemUpdate(update,self.item.m_subId)

    def goto(self,to):
        self.s_m = to
        self.traceEvent("goto")

    def traceEvent(self,evt):
        if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.internalLogger.isTraceEnabled():
            subId = self.item.m_subId
            itemIdx = self.item.itemIdx
            if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.internalLogger.isTraceEnabled():
                com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.internalLogger.trace(((((((((("sub#key#" + ("null" if evt is None else evt)) + "(") + Std.string(subId)) + ":") + Std.string(itemIdx)) + ":") + HxOverrides.stringOrNull(self.keyName)) + ") in ") + Std.string(self.s_m)))

com_lightstreamer_client_internal_update_Key1Level._hx_class = com_lightstreamer_client_internal_update_Key1Level


class com_lightstreamer_client_internal_update_Key2Level:
    _hx_class_name = "com.lightstreamer.client.internal.update.Key2Level"
    _hx_is_interface = "False"
    __slots__ = ("keyName", "item", "currKeyValues", "currKey2Values", "listener2Level", "subscription2Level", "s_m", "lock", "realMaxFrequency")
    _hx_fields = ["keyName", "item", "currKeyValues", "currKey2Values", "listener2Level", "subscription2Level", "s_m", "lock", "realMaxFrequency"]
    _hx_methods = ["finalize", "evtUpdate", "evtDispose", "evtOnSubscriptionError2Level", "evtUpdate2Level", "evtOnUnsubscription2Level", "evtOnItemLostUpdates2Level", "evtOnRealMaxFrequency2Level", "evtSetRequestedMaxFrequency", "getCommandValue", "doFirstUpdate", "doUpdate", "doUpdate2Level", "doUpdate1Level", "doDelete", "doDeleteExt", "doLightDelete", "doDelete1LevelOnly", "doChangeRequestedMaxFrequency", "doSetRealMaxFrequency", "doUnsetRealMaxFrequency", "genOnRealMaxFrequency2LevelAdded", "genOnRealMaxFrequency2LevelRemoved", "doUnsubscribe", "notify2LevelIllegalArgument", "notify2LevelSubscriptionError", "notify2LevelLostUpdates", "fireOnItemUpdate", "create2LevelSubscription", "isDelete", "goto", "traceEvent"]
    _hx_interfaces = [com_lightstreamer_client_internal_update_ItemKey]

    def __init__(self,keyName,item):
        self.realMaxFrequency = None
        self.subscription2Level = None
        self.listener2Level = None
        self.currKey2Values = None
        self.currKeyValues = None
        self.s_m = 1
        self.keyName = keyName
        self.item = item
        self.lock = item.lock

    def finalize(self):
        self.currKeyValues = None
        self.currKey2Values = None
        self.item.unrelate(self.keyName)

    def evtUpdate(self,keyValues,snapshot):
        _gthis = self
        def _hx_local_0():
            _gthis.traceEvent("update")
            _g = _gthis.s_m
            if (_g == 1):
                if (not _gthis.isDelete(keyValues)):
                    sub = _gthis.create2LevelSubscription()
                    if (sub is not None):
                        _gthis.doFirstUpdate(keyValues,snapshot)
                        _gthis.subscription2Level = sub
                        _gthis.goto(4)
                        _gthis.item.strategy.client.subscribeExt(sub,True)
                    else:
                        _gthis.doFirstUpdate(keyValues,snapshot)
                        _gthis.notify2LevelIllegalArgument()
                        _gthis.goto(3)
                else:
                    _gthis.doLightDelete(keyValues,snapshot)
                    _gthis.finalize()
                    _gthis.goto(11)
                    _gthis.genOnRealMaxFrequency2LevelRemoved()
            elif (_g == 3):
                if (not _gthis.isDelete(keyValues)):
                    _gthis.doUpdate(keyValues,snapshot)
                    _gthis.goto(3)
                else:
                    _gthis.doDelete1LevelOnly(keyValues,snapshot)
                    _gthis.finalize()
                    _gthis.goto(11)
                    _gthis.genOnRealMaxFrequency2LevelRemoved()
            elif (_g == 4):
                if (not _gthis.isDelete(keyValues)):
                    _gthis.doUpdate(keyValues,snapshot)
                    _gthis.goto(4)
                else:
                    _gthis.doDelete(keyValues,snapshot)
                    _gthis.finalize()
                    _gthis.goto(11)
                    _gthis.genOnRealMaxFrequency2LevelRemoved()
            elif (_g == 5):
                if (not _gthis.isDelete(keyValues)):
                    _gthis.doUpdate1Level(keyValues,snapshot)
                    _gthis.goto(5)
                else:
                    _gthis.doDeleteExt(keyValues,snapshot)
                    _gthis.finalize()
                    _gthis.goto(11)
                    _gthis.genOnRealMaxFrequency2LevelRemoved()
            else:
                pass
        self.lock.synchronized(_hx_local_0)

    def evtDispose(self):
        _gthis = self
        def _hx_local_0():
            _gthis.traceEvent("dispose")
            _g = _gthis.s_m
            if (((_g == 3) or ((_g == 2))) or ((_g == 1))):
                _gthis.finalize()
                _gthis.goto(10)
            elif ((_g == 5) or ((_g == 4))):
                _gthis.doUnsubscribe()
                _gthis.finalize()
                _gthis.goto(12)
            else:
                pass
        self.lock.synchronized(_hx_local_0)

    def evtOnSubscriptionError2Level(self,code,msg):
        _gthis = self
        def _hx_local_0():
            _gthis.traceEvent("onSubscriptionError2Level")
            if (_gthis.s_m == 4):
                _gthis.notify2LevelSubscriptionError(code,msg)
                _gthis.goto(3)
        self.lock.synchronized(_hx_local_0)

    def evtUpdate2Level(self,update):
        _gthis = self
        def _hx_local_0():
            _gthis.traceEvent("update2Level")
            _g = _gthis.s_m
            if (_g == 4):
                _gthis.doUpdate2Level(update)
                _gthis.goto(5)
            elif (_g == 5):
                _gthis.doUpdate2Level(update)
                _gthis.goto(5)
            else:
                pass
        self.lock.synchronized(_hx_local_0)

    def evtOnUnsubscription2Level(self):
        _gthis = self
        def _hx_local_0():
            _gthis.traceEvent("onUnsubscription2Level")
            _g = _gthis.s_m
            if ((_g == 5) or ((_g == 4))):
                _gthis.doUnsetRealMaxFrequency()
                _gthis.goto(_gthis.s_m)
                _gthis.genOnRealMaxFrequency2LevelRemoved()
            else:
                pass
        self.lock.synchronized(_hx_local_0)

    def evtOnItemLostUpdates2Level(self,lostUpdates):
        _gthis = self
        def _hx_local_0():
            _gthis.traceEvent("onItemLostUpdates2Level")
            _g = _gthis.s_m
            if ((_g == 5) or ((_g == 4))):
                _gthis.goto(_gthis.s_m)
                _gthis.notify2LevelLostUpdates(lostUpdates)
            else:
                pass
        self.lock.synchronized(_hx_local_0)

    def evtOnRealMaxFrequency2Level(self,maxFrequency):
        _gthis = self
        def _hx_local_0():
            _gthis.traceEvent("onRealMaxFrequency2Level")
            _g = _gthis.s_m
            if ((_g == 5) or ((_g == 4))):
                _gthis.doSetRealMaxFrequency(maxFrequency)
                _gthis.goto(_gthis.s_m)
                _gthis.genOnRealMaxFrequency2LevelAdded()
            else:
                pass
        self.lock.synchronized(_hx_local_0)

    def evtSetRequestedMaxFrequency(self):
        _gthis = self
        def _hx_local_0():
            _gthis.traceEvent("setRequestedMaxFrequency")
            _g = _gthis.s_m
            if ((_g == 5) or ((_g == 4))):
                _gthis.doChangeRequestedMaxFrequency()
                _gthis.goto(_gthis.s_m)
            else:
                pass
        self.lock.synchronized(_hx_local_0)

    def getCommandValue(self,fieldIdx):
        _gthis = self
        def _hx_local_1():
            def _hx_local_0():
                values = _gthis.currKeyValues
                if ((values is not None) and ((values.h.get(fieldIdx,None) is not None))):
                    return com_lightstreamer_client_internal_update_CurrFieldValTools.toString(values.h.get(fieldIdx,None))
                else:
                    values = _gthis.currKey2Values
                    nFields = _gthis.item.subscription.fetch_nFields()
                    if ((values is not None) and ((nFields is not None))):
                        return values.h.get((fieldIdx - nFields),None)
                    else:
                        return None
            return self.lock.synchronized(_hx_local_0)
        return _hx_local_1()

    def doFirstUpdate(self,keyValues,snapshot):
        cmdIdx = self.item.subscription.getCommandPosition()
        self.currKeyValues = keyValues
        self.currKeyValues.set(cmdIdx,com_lightstreamer_client_internal_update_CurrFieldVal.StringVal("ADD"))
        changedFields = com_lightstreamer_client_internal_update__UpdateUtils_UpdateUtils_Fields_.findChangedFields(None,self.currKeyValues)
        self.fireOnItemUpdate(com_lightstreamer_client_internal_update_ItemUpdate2Level(self.item.itemIdx,self.item.subscription,self.currKeyValues,changedFields,snapshot,haxe_ds_IntMap()))

    def doUpdate(self,keyValues,snapshot):
        cmdIdx = self.item.subscription.getCommandPosition()
        prevKeyValues = self.currKeyValues
        self.currKeyValues = keyValues
        self.currKeyValues.set(cmdIdx,com_lightstreamer_client_internal_update_CurrFieldVal.StringVal("UPDATE"))
        changedFields = com_lightstreamer_client_internal_update__UpdateUtils_UpdateUtils_Fields_.findChangedFields(prevKeyValues,self.currKeyValues)
        self.fireOnItemUpdate(com_lightstreamer_client_internal_update_ItemUpdate2Level(self.item.itemIdx,self.item.subscription,self.currKeyValues,changedFields,snapshot,haxe_ds_IntMap()))

    def doUpdate2Level(self,update):
        cmdIdx = self.item.subscription.getCommandPosition()
        nFields = com_lightstreamer_internal_NullTools.sure(self.item.subscription.fetch_nFields())
        prevKeyValues = com_lightstreamer_internal_NullTools.sure(self.currKeyValues).copy()
        self.currKeyValues.set(cmdIdx,com_lightstreamer_client_internal_update_CurrFieldVal.StringVal("UPDATE"))
        self.currKey2Values = com_lightstreamer_internal__NativeTypes_NativeIntMap_Impl_.toHaxe(update.getFieldsByPosition())
        extKeyValues = com_lightstreamer_internal_NullTools.sure(self.currKeyValues).copy()
        this1 = self.currKey2Values
        _g_keys = this1.keys()
        while _g_keys.hasNext():
            key = _g_keys.next()
            _g_value = this1.get(key)
            extKeyValues.set((key + nFields),(None if ((_g_value is None)) else com_lightstreamer_client_internal_update_CurrFieldVal.StringVal(_g_value)))
        changedFields = com_lightstreamer_internal_Set()
        if (com_lightstreamer_client_internal_update_CurrFieldValTools.toString(prevKeyValues.h.get(cmdIdx,None)) != com_lightstreamer_client_internal_update_CurrFieldValTools.toString(self.currKeyValues.h.get(cmdIdx,None))):
            changedFields.insert(cmdIdx)
        this1 = com_lightstreamer_internal__NativeTypes_NativeIntMap_Impl_.toHaxe(update.getChangedFieldsByPosition())
        _g_keys = this1.keys()
        while _g_keys.hasNext():
            key = _g_keys.next()
            this1.get(key)
            changedFields.insert((key + nFields))
        snapshot = update.isSnapshot()
        jsonPatches = haxe_ds_IntMap()
        this1 = self.currKey2Values
        _g_keys = this1.keys()
        while _g_keys.hasNext():
            key = _g_keys.next()
            this1.get(key)
            u = update.getValueAsJSONPatchIfAvailable(key)
            if (u is not None):
                jsonPatches.set((key + nFields),u)
        self.fireOnItemUpdate(com_lightstreamer_client_internal_update_ItemUpdate2Level(self.item.itemIdx,self.item.subscription,extKeyValues,changedFields,snapshot,jsonPatches))

    def doUpdate1Level(self,keyValues,snapshot):
        cmdIdx = self.item.subscription.getCommandPosition()
        nFields = com_lightstreamer_internal_NullTools.sure(self.item.subscription.fetch_nFields())
        prevKeyValues = com_lightstreamer_internal_NullTools.sure(self.currKeyValues)
        self.currKeyValues = keyValues
        self.currKeyValues.set(cmdIdx,com_lightstreamer_client_internal_update_CurrFieldVal.StringVal("UPDATE"))
        extKeyValues = com_lightstreamer_internal_NullTools.sure(self.currKeyValues).copy()
        this1 = com_lightstreamer_internal_NullTools.sure(self.currKey2Values)
        _g_keys = this1.keys()
        while _g_keys.hasNext():
            key = _g_keys.next()
            _g_value = this1.get(key)
            extKeyValues.set((key + nFields),(None if ((_g_value is None)) else com_lightstreamer_client_internal_update_CurrFieldVal.StringVal(_g_value)))
        changedFields = com_lightstreamer_internal_Set()
        _g = 1
        _g1 = (nFields + 1)
        while (_g < _g1):
            f = _g
            _g = (_g + 1)
            if (com_lightstreamer_client_internal_update_CurrFieldValTools.toString(prevKeyValues.h.get(f,None)) != com_lightstreamer_client_internal_update_CurrFieldValTools.toString(extKeyValues.h.get(f,None))):
                changedFields.insert(f)
        self.fireOnItemUpdate(com_lightstreamer_client_internal_update_ItemUpdate2Level(self.item.itemIdx,self.item.subscription,extKeyValues,changedFields,snapshot,haxe_ds_IntMap()))

    def doDelete(self,keyValues,snapshot):
        n = com_lightstreamer_internal_NullTools.sure(self.item.subscription.fetch_nFields())
        keyIdx = self.item.subscription.getKeyPosition()
        cmdIdx = self.item.subscription.getCommandPosition()
        self.currKeyValues = None
        changedFields = com_lightstreamer_internal_Set(IntIterator(1,(n + 1))).subtracting([keyIdx])
        extKeyValues = haxe_ds_IntMap()
        _g = 1
        _g1 = (n + 1)
        while (_g < _g1):
            f = _g
            _g = (_g + 1)
            extKeyValues.set(f,None)
        extKeyValues.set(keyIdx,com_lightstreamer_client_internal_update_CurrFieldVal.StringVal(self.keyName))
        extKeyValues.set(cmdIdx,com_lightstreamer_client_internal_update_CurrFieldVal.StringVal("DELETE"))
        update = com_lightstreamer_client_internal_update_ItemUpdate2Level(self.item.itemIdx,self.item.subscription,extKeyValues,changedFields,snapshot,haxe_ds_IntMap())
        self.item.unrelate(self.keyName)
        sub = com_lightstreamer_internal_NullTools.sure(self.subscription2Level)
        sub.removeListener(com_lightstreamer_internal_NullTools.sure(self.listener2Level))
        com_lightstreamer_internal_NullTools.sure(self.listener2Level).disable()
        self.subscription2Level = None
        self.listener2Level = None
        self.item.strategy.client.unsubscribe(sub)
        self.fireOnItemUpdate(update)

    def doDeleteExt(self,keyValues,snapshot):
        nFields = com_lightstreamer_internal_NullTools.sure(self.item.subscription.fetch_nFields())
        keyIdx = self.item.subscription.getKeyPosition()
        cmdIdx = self.item.subscription.getCommandPosition()
        n = (nFields + Lambda.count(com_lightstreamer_internal_NullTools.sure(self.currKey2Values)))
        self.currKeyValues = None
        self.currKey2Values = None
        changedFields = com_lightstreamer_internal_Set(IntIterator(1,(n + 1))).subtracting([keyIdx])
        extKeyValues = haxe_ds_IntMap()
        _g = 1
        _g1 = (n + 1)
        while (_g < _g1):
            f = _g
            _g = (_g + 1)
            extKeyValues.set(f,None)
        extKeyValues.set(keyIdx,com_lightstreamer_client_internal_update_CurrFieldVal.StringVal(self.keyName))
        extKeyValues.set(cmdIdx,com_lightstreamer_client_internal_update_CurrFieldVal.StringVal("DELETE"))
        update = com_lightstreamer_client_internal_update_ItemUpdate2Level(self.item.itemIdx,self.item.subscription,extKeyValues,changedFields,snapshot,haxe_ds_IntMap())
        self.item.unrelate(self.keyName)
        sub = com_lightstreamer_internal_NullTools.sure(self.subscription2Level)
        sub.removeListener(com_lightstreamer_internal_NullTools.sure(self.listener2Level))
        com_lightstreamer_internal_NullTools.sure(self.listener2Level).disable()
        self.subscription2Level = None
        self.listener2Level = None
        self.item.strategy.client.unsubscribe(sub)
        self.fireOnItemUpdate(update)

    def doLightDelete(self,keyValues,snapshot):
        nFields = com_lightstreamer_internal_NullTools.sure(self.item.subscription.fetch_nFields())
        keyIdx = self.item.subscription.getKeyPosition()
        cmdIdx = self.item.subscription.getCommandPosition()
        self.currKeyValues = None
        changedFields = com_lightstreamer_internal_Set(IntIterator(1,(nFields + 1)))
        values = haxe_ds_IntMap()
        _g = 1
        _g1 = (nFields + 1)
        while (_g < _g1):
            f = _g
            _g = (_g + 1)
            values.set(f,None)
        v = keyValues.h.get(keyIdx,None)
        values.set(keyIdx,v)
        v = keyValues.h.get(cmdIdx,None)
        values.set(cmdIdx,v)
        self.fireOnItemUpdate(com_lightstreamer_client_internal_update_ItemUpdate2Level(self.item.itemIdx,self.item.subscription,values,changedFields,snapshot,haxe_ds_IntMap()))

    def doDelete1LevelOnly(self,keyValues,snapshot):
        nFields = com_lightstreamer_internal_NullTools.sure(self.item.subscription.fetch_nFields())
        keyIdx = self.item.subscription.getKeyPosition()
        cmdIdx = self.item.subscription.getCommandPosition()
        self.currKeyValues = None
        changedFields = com_lightstreamer_internal_Set(IntIterator(1,(nFields + 1))).subtracting([keyIdx])
        values = haxe_ds_IntMap()
        _g = 1
        _g1 = (nFields + 1)
        while (_g < _g1):
            f = _g
            _g = (_g + 1)
            values.set(f,None)
        v = keyValues.h.get(keyIdx,None)
        values.set(keyIdx,v)
        v = keyValues.h.get(cmdIdx,None)
        values.set(cmdIdx,v)
        self.fireOnItemUpdate(com_lightstreamer_client_internal_update_ItemUpdate2Level(self.item.itemIdx,self.item.subscription,values,changedFields,snapshot,haxe_ds_IntMap()))

    def doChangeRequestedMaxFrequency(self):
        com_lightstreamer_internal_NullTools.sure(self.subscription2Level).setRequestedMaxFrequency(com_lightstreamer_internal_RequestedMaxFrequencyTools.toString(self.item.strategy.requestedMaxFrequency))

    def doSetRealMaxFrequency(self,maxFrequency):
        self.realMaxFrequency = maxFrequency

    def doUnsetRealMaxFrequency(self):
        self.realMaxFrequency = None

    def genOnRealMaxFrequency2LevelAdded(self):
        self.item.strategy.evtOnRealMaxFrequency2LevelAdded(self.realMaxFrequency)

    def genOnRealMaxFrequency2LevelRemoved(self):
        self.item.strategy.evtOnRealMaxFrequency2LevelRemoved()

    def doUnsubscribe(self):
        if (self.subscription2Level is None):
            raise com_lightstreamer_internal_IllegalStateException(("Assertion failure: " + "subscription2Level != null"))
        if (self.listener2Level is None):
            raise com_lightstreamer_internal_IllegalStateException(("Assertion failure: " + "listener2Level != null"))
        sub = self.subscription2Level
        sub.removeListener(self.listener2Level)
        self.listener2Level.disable()
        self.subscription2Level = None
        self.listener2Level = None
        self.item.strategy.client.unsubscribe(sub)

    def notify2LevelIllegalArgument(self):
        self.listener2Level = None
        self.subscription2Level = None
        self.item.subscription.fireOnSubscriptionError2Level(self.keyName,14,"The received key value is not a valid name for an Item",self.item.m_subId,self.item.itemIdx)

    def notify2LevelSubscriptionError(self,code,msg):
        self.listener2Level = None
        self.subscription2Level = None
        self.item.subscription.fireOnSubscriptionError2Level(self.keyName,code,msg,self.item.m_subId,self.item.itemIdx)

    def notify2LevelLostUpdates(self,lostUpdates):
        self.item.subscription.fireOnLostUpdates2Level(self.keyName,lostUpdates,self.item.m_subId,self.item.itemIdx)

    def fireOnItemUpdate(self,update):
        self.item.subscription.fireOnItemUpdate(update,self.item.m_subId)

    def create2LevelSubscription(self):
        self.listener2Level = com_lightstreamer_client_internal_update__Key2Level_Sub2LevelDelegate(self)
        sub = self.item.subscription
        sub2 = LSSubscription("MERGE",None,None)
        items = [self.keyName]
        if (not com_lightstreamer_internal__Types_Items_Impl_.allValidNames(items)):
            return None
        sub2.setItems(list(items))
        fields2 = sub.getCommandSecondLevelFields()
        if (fields2 is not None):
            sub2.setFields(fields2)
        else:
            sub2.setFieldSchema(sub.getCommandSecondLevelFieldSchema())
        sub2.setDataAdapter(sub.getCommandSecondLevelDataAdapter())
        sub2.setRequestedSnapshot(com_lightstreamer_internal_RequestedSnapshotTools.toString(com_lightstreamer_internal_RequestedSnapshot.SnpYes))
        sub2.setRequestedMaxFrequency(com_lightstreamer_internal_RequestedMaxFrequencyTools.toString(self.item.strategy.requestedMaxFrequency))
        sub2.addListener(com_lightstreamer_internal_NullTools.sure(self.listener2Level))
        sub2.setInternal()
        return sub2

    def isDelete(self,keyValues):
        key = self.item.subscription.getCommandPosition()
        return (com_lightstreamer_client_internal_update_CurrFieldValTools.toString(keyValues.h.get(key,None)) == "DELETE")

    def goto(self,to):
        self.s_m = to
        self.traceEvent("goto")

    def traceEvent(self,evt):
        if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.internalLogger.isTraceEnabled():
            subId = self.item.m_subId
            itemIdx = self.item.itemIdx
            if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.internalLogger.isTraceEnabled():
                com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.internalLogger.trace(((((((((("sub#key#" + ("null" if evt is None else evt)) + "(") + Std.string(subId)) + ":") + Std.string(itemIdx)) + ":") + HxOverrides.stringOrNull(self.keyName)) + ") in ") + Std.string(self.s_m)))

com_lightstreamer_client_internal_update_Key2Level._hx_class = com_lightstreamer_client_internal_update_Key2Level


class com_lightstreamer_client_internal_update__Key2Level_Sub2LevelDelegate:
    _hx_class_name = "com.lightstreamer.client.internal.update._Key2Level.Sub2LevelDelegate"
    _hx_is_interface = "False"
    __slots__ = ("key", "m_disabled")
    _hx_fields = ["key", "m_disabled"]
    _hx_methods = ["disable", "synchronized", "onSubscriptionError", "onItemUpdate", "onItemLostUpdates", "onRealMaxFrequency", "onUnsubscription", "onClearSnapshot", "onCommandSecondLevelItemLostUpdates", "onCommandSecondLevelSubscriptionError", "onEndOfSnapshot", "onListenEnd", "onListenStart", "onSubscription"]
    _hx_interfaces = [com_lightstreamer_client_SubscriptionListener]

    def __init__(self,key):
        self.m_disabled = False
        self.key = key

    def disable(self):
        _gthis = self
        def _hx_local_2():
            def _hx_local_1():
                def _hx_local_0():
                    _gthis.m_disabled = True
                    return _gthis.m_disabled
                return _hx_local_0()
            return _hx_local_1()
        self.key.lock.synchronized(_hx_local_2)

    def synchronized(self,block):
        _gthis = self
        def _hx_local_0():
            if (not _gthis.m_disabled):
                block()
        self.key.lock.synchronized(_hx_local_0)

    def onSubscriptionError(self,code,message):
        _gthis = self
        def _hx_local_0():
            _gthis.key.evtOnSubscriptionError2Level(code,message)
        self.synchronized(_hx_local_0)

    def onItemUpdate(self,itemUpdate):
        _gthis = self
        def _hx_local_0():
            _gthis.key.evtUpdate2Level(itemUpdate)
        self.synchronized(_hx_local_0)

    def onItemLostUpdates(self,itemName,itemPos,lostUpdates):
        _gthis = self
        def _hx_local_0():
            _gthis.key.evtOnItemLostUpdates2Level(lostUpdates)
        self.synchronized(_hx_local_0)

    def onRealMaxFrequency(self,frequency):
        _gthis = self
        def _hx_local_0():
            _gthis1 = _gthis.key
            tmp = None
            if (frequency is None):
                tmp = None
            else:
                _hx_tmp = None
                if (frequency is None):
                    _hx_tmp = Std.parseFloat(frequency)
                    _hx_max = _hx_tmp
                    tmp = (com_lightstreamer_internal_RealMaxFrequency.RFreqLimited(_hx_max) if ((not python_lib_Math.isnan(_hx_max))) else None)
                elif (frequency == "unlimited"):
                    tmp = com_lightstreamer_internal_RealMaxFrequency.RFreqUnlimited
                else:
                    _hx_tmp = Std.parseFloat(frequency)
                    _hx_max = _hx_tmp
                    tmp = (com_lightstreamer_internal_RealMaxFrequency.RFreqLimited(_hx_max) if ((not python_lib_Math.isnan(_hx_max))) else None)
            _gthis1.evtOnRealMaxFrequency2Level(tmp)
        self.synchronized(_hx_local_0)

    def onUnsubscription(self):
        _gthis = self
        def _hx_local_0():
            _gthis.key.evtOnUnsubscription2Level()
        self.synchronized(_hx_local_0)

    def onClearSnapshot(self,itemName,itemPos):
        pass

    def onCommandSecondLevelItemLostUpdates(self,lostUpdates,key):
        pass

    def onCommandSecondLevelSubscriptionError(self,code,message,key):
        pass

    def onEndOfSnapshot(self,itemName,itemPos):
        pass

    def onListenEnd(self):
        pass

    def onListenStart(self):
        pass

    def onSubscription(self):
        pass

com_lightstreamer_client_internal_update__Key2Level_Sub2LevelDelegate._hx_class = com_lightstreamer_client_internal_update__Key2Level_Sub2LevelDelegate

class com_lightstreamer_client_internal_update_CurrFieldVal(Enum):
    __slots__ = ()
    _hx_class_name = "com.lightstreamer.client.internal.update.CurrFieldVal"
    _hx_constructs = ["StringVal", "JsonVal"]

    @staticmethod
    def StringVal(string):
        return com_lightstreamer_client_internal_update_CurrFieldVal("StringVal", 0, (string,))

    @staticmethod
    def JsonVal(json):
        return com_lightstreamer_client_internal_update_CurrFieldVal("JsonVal", 1, (json,))
com_lightstreamer_client_internal_update_CurrFieldVal._hx_class = com_lightstreamer_client_internal_update_CurrFieldVal


class com_lightstreamer_client_internal_update_CurrFieldValTools:
    _hx_class_name = "com.lightstreamer.client.internal.update.CurrFieldValTools"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["toString"]

    @staticmethod
    def toString(val):
        if (val is None):
            return None
        else:
            tmp = val.index
            if (tmp == 0):
                return val.params[0]
            elif (tmp == 1):
                return com_lightstreamer_internal_patch__Json_Json_Impl_.toString(val.params[0])
            else:
                pass
com_lightstreamer_client_internal_update_CurrFieldValTools._hx_class = com_lightstreamer_client_internal_update_CurrFieldValTools


class com_lightstreamer_client_internal_update__UpdateUtils_UpdateUtils_Fields_:
    _hx_class_name = "com.lightstreamer.client.internal.update._UpdateUtils.UpdateUtils_Fields_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["applyUpatesToCurrentFields", "findChangedFields", "computeJsonPatches", "toMap", "findFirstIndex", "getFieldsByPosition", "getChangedFieldsByPosition"]

    @staticmethod
    def applyUpatesToCurrentFields(currentValues,incomingValues):
        if (currentValues is not None):
            newValues = haxe_ds_IntMap()
            _hx_map = incomingValues
            _g_keys = _hx_map.keys()
            while _g_keys.hasNext():
                key = _g_keys.next()
                _g_value = _hx_map.get(key)
                tmp = _g_value.index
                if (tmp == 0):
                    v = currentValues.h.get(key,None)
                    newValues.set(key,v)
                elif (tmp == 1):
                    _g = _g_value.params[0]
                    if (_g is None):
                        newValues.set(key,None)
                    else:
                        newValues.set(key,com_lightstreamer_client_internal_update_CurrFieldVal.StringVal(_g))
                elif (tmp == 2):
                    _g1 = _g_value.params[0]
                    _g2 = currentValues.h.get(key,None)
                    if (_g2 is None):
                        raise com_lightstreamer_internal_IllegalStateException((("Cannot apply the JSON patch to the field " + Std.string(key)) + " because the field is null"))
                    else:
                        tmp1 = _g2.index
                        if (tmp1 == 0):
                            _g3 = _g2.params[0]
                            json = None
                            try:
                                json = com_lightstreamer_internal_patch__Json_Json_Impl_._new(_g3)
                            except BaseException as _g4:
                                _g5 = haxe_Exception.caught(_g4)
                                if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.sessionLogger.isErrorEnabled():
                                    com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.sessionLogger.error(((("" + HxOverrides.stringOrNull(_g5.get_message())) + "\n") + HxOverrides.stringOrNull(_g5.details())))
                                raise com_lightstreamer_internal_IllegalStateException((("Cannot convert the field " + Std.string(key)) + " to JSON"))
                            try:
                                newValues.set(key,com_lightstreamer_client_internal_update_CurrFieldVal.JsonVal(com_lightstreamer_internal_patch__Json_Json_Impl_.apply(com_lightstreamer_internal_NullTools.sure(json),_g1)))
                            except BaseException as _g6:
                                _g7 = haxe_Exception.caught(_g6)
                                if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.sessionLogger.isErrorEnabled():
                                    com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.sessionLogger.error(((("" + HxOverrides.stringOrNull(_g7.get_message())) + "\n") + HxOverrides.stringOrNull(_g7.details())))
                                raise com_lightstreamer_internal_IllegalStateException(("Cannot apply the JSON Patch to the field " + Std.string(key)))
                        elif (tmp1 == 1):
                            _g8 = _g2.params[0]
                            try:
                                newValues.set(key,com_lightstreamer_client_internal_update_CurrFieldVal.JsonVal(com_lightstreamer_internal_patch__Json_Json_Impl_.apply(_g8,_g1)))
                            except BaseException as _g9:
                                _g10 = haxe_Exception.caught(_g9)
                                if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.sessionLogger.isErrorEnabled():
                                    com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.sessionLogger.error(((("" + HxOverrides.stringOrNull(_g10.get_message())) + "\n") + HxOverrides.stringOrNull(_g10.details())))
                                raise com_lightstreamer_internal_IllegalStateException(("Cannot apply the JSON Patch to the field " + Std.string(key)))
                        else:
                            pass
                elif (tmp == 3):
                    _g11 = _g_value.params[0]
                    _g12 = currentValues.h.get(key,None)
                    if (_g12 is None):
                        raise com_lightstreamer_internal_IllegalStateException((("Cannot apply the TLCP-diff to the field " + Std.string(key)) + " because the field is null"))
                    else:
                        tmp2 = _g12.index
                        if (tmp2 == 0):
                            newValues.set(key,com_lightstreamer_client_internal_update_CurrFieldVal.StringVal(com_lightstreamer_internal_patch_DiffDecoder(_g12.params[0],_g11).decode()))
                        elif (tmp2 == 1):
                            raise com_lightstreamer_internal_IllegalStateException((("Cannot apply the TLCP-diff to the field " + Std.string(key)) + " because the field is JSON"))
                        else:
                            pass
                else:
                    pass
            return newValues
        else:
            newValues = haxe_ds_IntMap()
            _hx_map = incomingValues
            _g_keys = _hx_map.keys()
            while _g_keys.hasNext():
                key = _g_keys.next()
                _g_value = _hx_map.get(key)
                tmp = _g_value.index
                if (tmp == 0):
                    raise com_lightstreamer_internal_IllegalStateException((("Cannot set the field " + Std.string(key)) + " because the first update is UNCHANGED"))
                elif (tmp == 1):
                    _g = _g_value.params[0]
                    if (_g is None):
                        newValues.set(key,None)
                    else:
                        newValues.set(key,com_lightstreamer_client_internal_update_CurrFieldVal.StringVal(_g))
                elif (tmp == 2):
                    raise com_lightstreamer_internal_IllegalStateException((("Cannot set the field " + Std.string(key)) + " because the first update is a JSONPatch"))
                elif (tmp == 3):
                    raise com_lightstreamer_internal_IllegalStateException((("Cannot set the field " + Std.string(key)) + " because the first update is a TLCP-diff"))
                else:
                    pass
            return newValues

    @staticmethod
    def findChangedFields(prev,curr):
        if (prev is not None):
            changedFields = com_lightstreamer_internal_Set()
            _hx_map = curr
            _g_keys = _hx_map.keys()
            while _g_keys.hasNext():
                key = _g_keys.next()
                _hx_map.get(key)
                if (com_lightstreamer_client_internal_update_CurrFieldValTools.toString(prev.h.get(key,None)) != com_lightstreamer_client_internal_update_CurrFieldValTools.toString(curr.h.get(key,None))):
                    changedFields.insert(key)
            return changedFields
        else:
            changedFields = com_lightstreamer_internal_Set()
            _hx_map = curr
            _g_keys = _hx_map.keys()
            while _g_keys.hasNext():
                key = _g_keys.next()
                _hx_map.get(key)
                changedFields.insert(key)
            return changedFields

    @staticmethod
    def computeJsonPatches(currentValues,incomingValues):
        if (currentValues is not None):
            res = haxe_ds_IntMap()
            _hx_map = incomingValues
            _g_keys = _hx_map.keys()
            while _g_keys.hasNext():
                key = _g_keys.next()
                _g_value = _hx_map.get(key)
                tmp = _g_value.index
                if (tmp == 0):
                    curr = currentValues.h.get(key,None)
                    if ((curr is not None) and ((False if ((curr is None)) else (curr.index == 1)))):
                        res.set(key,com_lightstreamer_internal_patch__Json_Json_Impl_._new("[]"))
                elif (tmp == 2):
                    res.set(key,_g_value.params[0])
                else:
                    pass
            return res
        else:
            return haxe_ds_IntMap()

    @staticmethod
    def toMap(array):
        if (array is not None):
            _hx_map = haxe_ds_IntMap()
            _g_current = 0
            while (_g_current < len(array)):
                def _hx_local_1():
                    nonlocal _g_current
                    _hx_local_0 = _g_current
                    _g_current = (_g_current + 1)
                    return _hx_local_0
                _g_value = python_internal_ArrayImpl._get(array, _hx_local_1())
                _hx_map.set(((_g_current - 1) + 1),_g_value)
            return _hx_map
        return None

    @staticmethod
    def findFirstIndex(_hx_map,value):
        _g = 1
        _g1 = (Lambda.count(_hx_map) + 1)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            if (_hx_map.h.get(i,None) == value):
                return i
        return None

    @staticmethod
    def getFieldsByPosition(update):
        return com_lightstreamer_internal__NativeTypes_NativeIntMap_Impl_.toHaxe(update.getFieldsByPosition())

    @staticmethod
    def getChangedFieldsByPosition(update):
        return com_lightstreamer_internal__NativeTypes_NativeIntMap_Impl_.toHaxe(update.getChangedFieldsByPosition())
com_lightstreamer_client_internal_update__UpdateUtils_UpdateUtils_Fields_._hx_class = com_lightstreamer_client_internal_update__UpdateUtils_UpdateUtils_Fields_


class com_lightstreamer_internal__ArrayTools_ArrayTools_Fields_:
    _hx_class_name = "com.lightstreamer.internal._ArrayTools.ArrayTools_Fields_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["removeAll"]

    @staticmethod
    def removeAll(array):
        _hx_len = len(array)
        array[0:_hx_len]
        del array[0:_hx_len]
com_lightstreamer_internal__ArrayTools_ArrayTools_Fields_._hx_class = com_lightstreamer_internal__ArrayTools_ArrayTools_Fields_


class com_lightstreamer_internal__ClientCommon_ClientCommon_Fields_:
    _hx_class_name = "com.lightstreamer.internal._ClientCommon.ClientCommon_Fields_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["buildProxy"]

    @staticmethod
    def buildProxy(proxy):
        proxyUrl = ((HxOverrides.stringOrNull(proxy.host) + ":") + Std.string(proxy.port))
        if (not ((proxyUrl.startswith("http://") or proxyUrl.startswith("https://")))):
            proxyUrl = ("http://" + ("null" if proxyUrl is None else proxyUrl))
        return _hx_AnonObject({'url': proxyUrl, 'user': proxy.user, 'password': proxy.password})
com_lightstreamer_internal__ClientCommon_ClientCommon_Fields_._hx_class = com_lightstreamer_internal__ClientCommon_ClientCommon_Fields_


class com_lightstreamer_internal_Executor:
    _hx_class_name = "com.lightstreamer.internal.Executor"
    _hx_is_interface = "False"
    __slots__ = ("thread", "loop")
    _hx_fields = ["thread", "loop"]
    _hx_methods = ["submit", "schedule", "stop"]

    def __init__(self):
        self.loop = None
        self.thread = None
        _gthis = self
        self.loop = com_lightstreamer_internal_Asyncio.new_event_loop()
        def _hx_local_0():
            com_lightstreamer_internal_Asyncio.set_event_loop(_gthis.loop)
            _gthis.loop.run_forever()
            _gthis.loop.close()
        self.thread = python_lib_threading_Thread(**python__KwArgs_KwArgs_Impl_.fromT(_hx_AnonObject({'target': _hx_local_0, 'daemon': True})))
        self.thread.start()

    def submit(self,callback):
        self.loop.call_soon_threadsafe(callback)

    def schedule(self,callback,delay):
        _this = self.loop
        return _this.call_soon_threadsafe(_this.call_later,(delay / 1000.0),callback)

    def stop(self):
        self.loop.call_soon_threadsafe(self.loop.stop)
        self.thread.join()

com_lightstreamer_internal_Executor._hx_class = com_lightstreamer_internal_Executor


class com_lightstreamer_internal__Executor_TaskHandle_Impl_:
    _hx_class_name = "com.lightstreamer.internal._Executor.TaskHandle_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["cancel", "isCanceled"]

    @staticmethod
    def cancel(this1):
        this1.cancel()

    @staticmethod
    def isCanceled(this1):
        return this1.cancelled()
com_lightstreamer_internal__Executor_TaskHandle_Impl_._hx_class = com_lightstreamer_internal__Executor_TaskHandle_Impl_


class com_lightstreamer_internal_Globals:
    _hx_class_name = "com.lightstreamer.internal.Globals"
    _hx_is_interface = "False"
    __slots__ = ("sslContext", "lock")
    _hx_fields = ["sslContext", "lock"]
    _hx_methods = ["setTrustManagerFactory", "getTrustManagerFactory", "clearTrustManager", "toString"]
    _hx_statics = ["instance"]

    def __init__(self):
        self.sslContext = None
        self.lock = com_lightstreamer_internal_RLock()

    def setTrustManagerFactory(self,factory):
        _gthis = self
        def _hx_local_2():
            if (factory is None):
                raise com_lightstreamer_internal_IllegalArgumentException("Expected a non-null SSLContext")
            if (_gthis.sslContext is not None):
                raise com_lightstreamer_internal_IllegalStateException("SSLContext already installed")
            def _hx_local_1():
                def _hx_local_0():
                    _gthis.sslContext = factory
                    return _gthis.sslContext
                return _hx_local_0()
            return _hx_local_1()
        self.lock.synchronized(_hx_local_2)

    def getTrustManagerFactory(self):
        _gthis = self
        def _hx_local_1():
            def _hx_local_0():
                return _gthis.sslContext
            return self.lock.synchronized(_hx_local_0)
        return _hx_local_1()

    def clearTrustManager(self):
        _gthis = self
        def _hx_local_2():
            def _hx_local_1():
                def _hx_local_0():
                    _gthis.sslContext = None
                    return _gthis.sslContext
                return _hx_local_0()
            return _hx_local_1()
        self.lock.synchronized(_hx_local_2)

    def toString(self):
        def _hx_local_0():
            return "{}"
        self.lock.synchronized(_hx_local_0)

com_lightstreamer_internal_Globals._hx_class = com_lightstreamer_internal_Globals


class com_lightstreamer_internal_IHttpClient:
    _hx_class_name = "com.lightstreamer.internal.IHttpClient"
    _hx_is_interface = "True"
    __slots__ = ()
    _hx_methods = ["dispose", "isDisposed"]
com_lightstreamer_internal_IHttpClient._hx_class = com_lightstreamer_internal_IHttpClient


class com_lightstreamer_internal_HttpClient(com_lightstreamer_internal_HttpClientPy):
    _hx_class_name = "com.lightstreamer.internal.HttpClient"
    _hx_is_interface = "False"
    __slots__ = ("onText", "onError", "onDone")
    _hx_fields = ["onText", "onError", "onDone"]
    _hx_methods = ["dispose", "on_text", "on_error", "on_done"]
    _hx_statics = []
    _hx_interfaces = [com_lightstreamer_internal_IHttpClient]
    _hx_super = com_lightstreamer_internal_HttpClientPy


    def __init__(self,url,body,headers,proxy,sslContext,onText,onError,onDone):
        self.onDone = None
        self.onError = None
        self.onText = None
        super().__init__()
        if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.streamLogger.isDebugEnabled():
            com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.streamLogger.debug((((((("HTTP sending: " + ("null" if url is None else url)) + " ") + ("null" if body is None else body)) + " headers(") + HxOverrides.stringOrNull((("null" if ((headers is None)) else headers.toString())))) + ")"))
        self.onText = onText
        self.onError = onError
        self.onDone = onDone
        self.sendAsync(url,body,(None if ((headers is None)) else com_lightstreamer_internal__NativeTypes_NativeStringMap_Impl_._new(headers)),(com_lightstreamer_internal__ClientCommon_ClientCommon_Fields_.buildProxy(proxy) if ((proxy is not None)) else None),sslContext)

    def dispose(self):
        if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.streamLogger.isDebugEnabled():
            com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.streamLogger.debug("HTTP disposing")
        super().dispose()

    def on_text(self,client,line):
        if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.streamLogger.isDebugEnabled():
            com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.streamLogger.debug((("HTTP event: text(" + ("null" if line is None else line)) + ")"))
        self.onText(self,line)

    def on_error(self,client,error):
        msg = str(error)
        if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.streamLogger.isDebugEnabled():
            com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.streamLogger.debug((("HTTP event: error(" + ("null" if msg is None else msg)) + ")"),error)
        self.onError(self,msg)

    def on_done(self,client):
        if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.streamLogger.isDebugEnabled():
            com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.streamLogger.debug("HTTP event: complete")
        self.onDone(self)

com_lightstreamer_internal_HttpClient._hx_class = com_lightstreamer_internal_HttpClient


class com_lightstreamer_internal__InfoMap_InfoMap_Impl_:
    _hx_class_name = "com.lightstreamer.internal._InfoMap.InfoMap_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["_new", "set"]

    @staticmethod
    def _new():
        return haxe_ds_StringMap()

    @staticmethod
    def set(this1,k,v):
        if (v is not None):
            value = ("null" if ((v is None)) else Std.string(v))
            this1.h[k] = value
com_lightstreamer_internal__InfoMap_InfoMap_Impl_._hx_class = com_lightstreamer_internal__InfoMap_InfoMap_Impl_


class com_lightstreamer_internal__MacroTools_MacroTools_Fields_:
    _hx_class_name = "com.lightstreamer.internal._MacroTools.MacroTools_Fields_"
    _hx_is_interface = "False"
    __slots__ = ()
com_lightstreamer_internal__MacroTools_MacroTools_Fields_._hx_class = com_lightstreamer_internal__MacroTools_MacroTools_Fields_


class com_lightstreamer_internal__Macros_Macros_Fields_:
    _hx_class_name = "com.lightstreamer.internal._Macros.Macros_Fields_"
    _hx_is_interface = "False"
    __slots__ = ()
com_lightstreamer_internal__Macros_Macros_Fields_._hx_class = com_lightstreamer_internal__Macros_Macros_Fields_


class com_lightstreamer_internal_MyArray:
    _hx_class_name = "com.lightstreamer.internal.MyArray"
    _hx_is_interface = "False"
    __slots__ = ("nRemoved", "values")
    _hx_fields = ["nRemoved", "values"]
    _hx_methods = ["get_length", "compact", "push", "remove", "filter", "map", "exists", "find", "contains", "iterator", "copy", "toString"]

    def __init__(self):
        self.values = list()
        self.nRemoved = 0

    def get_length(self):
        return (len(self.values) - self.nRemoved)

    def compact(self):
        if (self.nRemoved > ((len(self.values) / 2))):
            self.nRemoved = 0
            self.values = self.copy().values

    def push(self,e):
        x = com_lightstreamer_internal__MyArray_Pair(e)
        self.values.append(x)

    def remove(self,e):
        _g = 0
        _g1 = len(self.values)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            if (HxOverrides.eq((self.values[i] if i >= 0 and i < len(self.values) else None).item,e) and (self.values[i] if i >= 0 and i < len(self.values) else None).isValid):
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.nRemoved
                _hx_local_0.nRemoved = (_hx_local_1 + 1)
                _hx_local_1
                (self.values[i] if i >= 0 and i < len(self.values) else None).isValid = False
                break

    def filter(self,pred):
        res = com_lightstreamer_internal_MyArray()
        e = com_lightstreamer_internal__MyArray_MyArrayIterator(self)
        while e.hasNext():
            e1 = e.next()
            if pred(e1):
                x = com_lightstreamer_internal__MyArray_Pair(e1)
                res.values.append(x)
        return res

    def map(self,f):
        res = com_lightstreamer_internal_MyArray()
        e = com_lightstreamer_internal__MyArray_MyArrayIterator(self)
        while e.hasNext():
            x = com_lightstreamer_internal__MyArray_Pair(f(e.next()))
            res.values.append(x)
        return res

    def exists(self,f):
        return Lambda.exists(self,f)

    def find(self,f):
        return Lambda.find(self,f)

    def contains(self,x):
        return Lambda.has(self,x)

    def iterator(self):
        return com_lightstreamer_internal__MyArray_MyArrayIterator(self)

    def copy(self):
        arr = com_lightstreamer_internal_MyArray()
        e = com_lightstreamer_internal__MyArray_MyArrayIterator(self)
        while e.hasNext():
            x = com_lightstreamer_internal__MyArray_Pair(e.next())
            arr.values.append(x)
        return arr

    def toString(self):
        i = 0
        _hx_len = (len(self.values) - self.nRemoved)
        _hx_str = "["
        k = com_lightstreamer_internal__MyArray_MyArrayIterator(self)
        while k.hasNext():
            _hx_str = (("null" if _hx_str is None else _hx_str) + HxOverrides.stringOrNull(((Std.string(k.next()) + HxOverrides.stringOrNull(((", " if ((i != ((_hx_len - 1)))) else "")))))))
            i = (i + 1)
        return (("null" if _hx_str is None else _hx_str) + "]")

com_lightstreamer_internal_MyArray._hx_class = com_lightstreamer_internal_MyArray


class com_lightstreamer_internal__MyArray_Pair:
    _hx_class_name = "com.lightstreamer.internal._MyArray.Pair"
    _hx_is_interface = "False"
    __slots__ = ("item", "isValid")
    _hx_fields = ["item", "isValid"]

    def __init__(self,item):
        self.isValid = True
        self.item = item

com_lightstreamer_internal__MyArray_Pair._hx_class = com_lightstreamer_internal__MyArray_Pair


class com_lightstreamer_internal__MyArray_MyArrayIterator:
    _hx_class_name = "com.lightstreamer.internal._MyArray.MyArrayIterator"
    _hx_is_interface = "False"
    __slots__ = ("index", "a")
    _hx_fields = ["index", "a"]
    _hx_methods = ["hasNext", "next"]

    def __init__(self,a):
        self.a = a
        self.index = 0

    def hasNext(self):
        _g = self.index
        _g1 = len(self.a.values)
        while (_g < _g1):
            j = _g
            _g = (_g + 1)
            if python_internal_ArrayImpl._get(self.a.values, j).isValid:
                return True
        return False

    def next(self):
        _g = self.index
        _g1 = len(self.a.values)
        while (_g < _g1):
            j = _g
            _g = (_g + 1)
            if python_internal_ArrayImpl._get(self.a.values, j).isValid:
                self.index = (j + 1)
                return python_internal_ArrayImpl._get(self.a.values, j).item
        raise haxe_Exception("No such element")

com_lightstreamer_internal__MyArray_MyArrayIterator._hx_class = com_lightstreamer_internal__MyArray_MyArrayIterator


class com_lightstreamer_internal__NativeTypes_NativeException_Impl_:
    _hx_class_name = "com.lightstreamer.internal._NativeTypes.NativeException_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["details"]

    @staticmethod
    def details(this1):
        return haxe_Exception.caught(this1).details()
com_lightstreamer_internal__NativeTypes_NativeException_Impl_._hx_class = com_lightstreamer_internal__NativeTypes_NativeException_Impl_


class haxe_Exception(Exception):
    _hx_class_name = "haxe.Exception"
    _hx_is_interface = "False"
    __slots__ = ("_hx___exceptionStack", "_hx___nativeStack", "_hx___skipStack", "_hx___nativeException", "_hx___previousException")
    _hx_fields = ["__exceptionStack", "__nativeStack", "__skipStack", "__nativeException", "__previousException"]
    _hx_methods = ["unwrap", "toString", "details", "__shiftStack", "get_message", "get_previous", "get_native", "get_stack"]
    _hx_statics = ["caught", "thrown"]
    _hx_interfaces = []
    _hx_super = Exception


    def __init__(self,message,previous = None,native = None):
        self._hx___previousException = None
        self._hx___nativeException = None
        self._hx___nativeStack = None
        self._hx___exceptionStack = None
        self._hx___skipStack = 0
        super().__init__(message)
        self._hx___previousException = previous
        if ((native is not None) and Std.isOfType(native,BaseException)):
            self._hx___nativeException = native
            self._hx___nativeStack = haxe_NativeStackTrace.exceptionStack()
        else:
            self._hx___nativeException = self
            infos = python_lib_Traceback.extract_stack()
            if (len(infos) != 0):
                infos.pop()
            infos.reverse()
            self._hx___nativeStack = infos

    def unwrap(self):
        return self._hx___nativeException

    def toString(self):
        return self.get_message()

    def details(self):
        if (self.get_previous() is None):
            tmp = ("Exception: " + HxOverrides.stringOrNull(self.toString()))
            tmp1 = self.get_stack()
            return (("null" if tmp is None else tmp) + HxOverrides.stringOrNull((("null" if ((tmp1 is None)) else haxe__CallStack_CallStack_Impl_.toString(tmp1)))))
        else:
            result = ""
            e = self
            prev = None
            while (e is not None):
                if (prev is None):
                    result1 = ("Exception: " + HxOverrides.stringOrNull(e.get_message()))
                    tmp = e.get_stack()
                    result = ((("null" if result1 is None else result1) + HxOverrides.stringOrNull((("null" if ((tmp is None)) else haxe__CallStack_CallStack_Impl_.toString(tmp))))) + ("null" if result is None else result))
                else:
                    prevStack = haxe__CallStack_CallStack_Impl_.subtract(e.get_stack(),prev.get_stack())
                    result = (((("Exception: " + HxOverrides.stringOrNull(e.get_message())) + HxOverrides.stringOrNull((("null" if ((prevStack is None)) else haxe__CallStack_CallStack_Impl_.toString(prevStack))))) + "\n\nNext ") + ("null" if result is None else result))
                prev = e
                e = e.get_previous()
            return result

    def _hx___shiftStack(self):
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0._hx___skipStack
        _hx_local_0._hx___skipStack = (_hx_local_1 + 1)
        _hx_local_1

    def get_message(self):
        return str(self)

    def get_previous(self):
        return self._hx___previousException

    def get_native(self):
        return self._hx___nativeException

    def get_stack(self):
        _g = self._hx___exceptionStack
        if (_g is None):
            def _hx_local_1():
                def _hx_local_0():
                    self._hx___exceptionStack = haxe_NativeStackTrace.toHaxe(self._hx___nativeStack,self._hx___skipStack)
                    return self._hx___exceptionStack
                return _hx_local_0()
            return _hx_local_1()
        else:
            return _g

    @staticmethod
    def caught(value):
        if Std.isOfType(value,haxe_Exception):
            return value
        elif Std.isOfType(value,BaseException):
            return haxe_Exception(str(value),None,value)
        else:
            return haxe_ValueException(value,None,value)

    @staticmethod
    def thrown(value):
        if Std.isOfType(value,haxe_Exception):
            return value.get_native()
        elif Std.isOfType(value,BaseException):
            return value
        else:
            e = haxe_ValueException(value)
            e._hx___skipStack = (e._hx___skipStack + 1)
            return e

haxe_Exception._hx_class = haxe_Exception


class com_lightstreamer_internal_IllegalArgumentException(haxe_Exception):
    _hx_class_name = "com.lightstreamer.internal.IllegalArgumentException"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = haxe_Exception


    def __init__(self,message,previous = None,native = None):
        super().__init__(message,previous,native)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0._hx___skipStack
        _hx_local_0._hx___skipStack = (_hx_local_1 + 1)
        _hx_local_1
com_lightstreamer_internal_IllegalArgumentException._hx_class = com_lightstreamer_internal_IllegalArgumentException


class com_lightstreamer_internal_IllegalStateException(haxe_Exception):
    _hx_class_name = "com.lightstreamer.internal.IllegalStateException"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = haxe_Exception


    def __init__(self,message,previous = None,native = None):
        super().__init__(message,previous,native)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0._hx___skipStack
        _hx_local_0._hx___skipStack = (_hx_local_1 + 1)
        _hx_local_1
com_lightstreamer_internal_IllegalStateException._hx_class = com_lightstreamer_internal_IllegalStateException


class com_lightstreamer_internal__NativeTypes_NativeStringMap_Impl_:
    _hx_class_name = "com.lightstreamer.internal._NativeTypes.NativeStringMap_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["_new", "fromHaxe", "toHaxe"]

    @staticmethod
    def _new(_hx_map):
        return com_lightstreamer_internal__NativeTypes_NativeTypes_Fields_.toNativeMap(_hx_map,dict())

    @staticmethod
    def fromHaxe(_hx_map):
        return com_lightstreamer_internal__NativeTypes_NativeStringMap_Impl_._new(_hx_map)

    @staticmethod
    def toHaxe(this1):
        return com_lightstreamer_internal__NativeTypes_NativeTypes_Fields_.toMap(this1,haxe_ds_StringMap())
com_lightstreamer_internal__NativeTypes_NativeStringMap_Impl_._hx_class = com_lightstreamer_internal__NativeTypes_NativeStringMap_Impl_


class com_lightstreamer_internal__NativeTypes_NativeIntMap_Impl_:
    _hx_class_name = "com.lightstreamer.internal._NativeTypes.NativeIntMap_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["_new", "toHaxe"]

    @staticmethod
    def _new(_hx_map):
        return com_lightstreamer_internal__NativeTypes_NativeTypes_Fields_.toNativeMap(_hx_map,dict())

    @staticmethod
    def toHaxe(this1):
        return com_lightstreamer_internal__NativeTypes_NativeTypes_Fields_.toMap(this1,haxe_ds_IntMap())
com_lightstreamer_internal__NativeTypes_NativeIntMap_Impl_._hx_class = com_lightstreamer_internal__NativeTypes_NativeIntMap_Impl_


class com_lightstreamer_internal__NativeTypes_NativeList_Impl_:
    _hx_class_name = "com.lightstreamer.internal._NativeTypes.NativeList_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["_new", "toHaxe"]

    @staticmethod
    def _new(lst):
        return list(lst)

    @staticmethod
    def toHaxe(this1):
        return list(this1)
com_lightstreamer_internal__NativeTypes_NativeList_Impl_._hx_class = com_lightstreamer_internal__NativeTypes_NativeList_Impl_


class com_lightstreamer_internal__NativeTypes_NativeArray_Impl_:
    _hx_class_name = "com.lightstreamer.internal._NativeTypes.NativeArray_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["fromHaxeArray", "toHaxeArray", "_new", "toHaxe"]

    @staticmethod
    def fromHaxeArray(a):
        return list(a)

    @staticmethod
    def toHaxeArray(this1):
        return list(this1)

    @staticmethod
    def _new(a):
        return list(a)

    @staticmethod
    def toHaxe(this1):
        return list(this1)
com_lightstreamer_internal__NativeTypes_NativeArray_Impl_._hx_class = com_lightstreamer_internal__NativeTypes_NativeArray_Impl_


class com_lightstreamer_internal__NativeTypes_NativeTypes_Fields_:
    _hx_class_name = "com.lightstreamer.internal._NativeTypes.NativeTypes_Fields_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["toNativeMap", "toMap"]

    @staticmethod
    def toNativeMap(_hx_map,out):
        _g = _hx_map.keyValueIterator()
        while _g.hasNext():
            _g1 = _g.next()
            out[_g1.key] = _g1.value
        return out

    @staticmethod
    def toMap(_hx_map,out):
        entry = python_HaxeIterator(iter(_hx_map.items()))
        while entry.hasNext():
            entry1 = entry.next()
            out.set(entry1[0],entry1[1])
        return out
com_lightstreamer_internal__NativeTypes_NativeTypes_Fields_._hx_class = com_lightstreamer_internal__NativeTypes_NativeTypes_Fields_


class com_lightstreamer_internal_NullTools:
    _hx_class_name = "com.lightstreamer.internal.NullTools"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["sure", "or"]

    @staticmethod
    def sure(value):
        if (value is None):
            raise haxe_Exception.thrown("null pointer in .sure() call")
        return value

    @staticmethod
    def _hx_or(value,defaultValue):
        if (value is None):
            return defaultValue
        return value
com_lightstreamer_internal_NullTools._hx_class = com_lightstreamer_internal_NullTools


class com_lightstreamer_internal__OrderedIntMap_OrderedIntMap_Impl_:
    _hx_class_name = "com.lightstreamer.internal._OrderedIntMap.OrderedIntMap_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["_new", "_get", "_set", "containsValue"]

    @staticmethod
    def _new():
        return com_lightstreamer_internal_OrderedIntMapImpl()

    @staticmethod
    def _get(this1,key):
        return this1._innerMap.h.get(key,None)

    @staticmethod
    def _set(this1,key,value):
        this1.set(key,value)
        return value

    @staticmethod
    def containsValue(this1,val):
        return Lambda.has(this1,val)
com_lightstreamer_internal__OrderedIntMap_OrderedIntMap_Impl_._hx_class = com_lightstreamer_internal__OrderedIntMap_OrderedIntMap_Impl_


class haxe_IMap:
    _hx_class_name = "haxe.IMap"
    _hx_is_interface = "True"
    __slots__ = ()
    _hx_methods = ["get", "set", "keys", "keyValueIterator"]
haxe_IMap._hx_class = haxe_IMap


class com_lightstreamer_internal_OrderedIntMapImpl:
    _hx_class_name = "com.lightstreamer.internal.OrderedIntMapImpl"
    _hx_is_interface = "False"
    __slots__ = ("_orderedKeys", "_innerMap")
    _hx_fields = ["_orderedKeys", "_innerMap"]
    _hx_methods = ["compact", "set", "get", "exists", "remove", "keys", "iterator", "keyValueIterator", "copy", "get_length", "keysCopy", "clear", "toString"]
    _hx_interfaces = [haxe_IMap]

    def __init__(self):
        self._innerMap = haxe_ds_IntMap()
        self._orderedKeys = com_lightstreamer_internal_MyArray()

    def compact(self):
        self._orderedKeys.compact()

    def set(self,key,value):
        if (not (key in self._innerMap.h)):
            x = com_lightstreamer_internal__MyArray_Pair(key)
            self._orderedKeys.values.append(x)
        self._innerMap.set(key,value)

    def get(self,key):
        return self._innerMap.h.get(key,None)

    def exists(self,key):
        return (key in self._innerMap.h)

    def remove(self,key):
        removed = self._innerMap.remove(key)
        if removed:
            self._orderedKeys.remove(key)
        return removed

    def keys(self):
        return com_lightstreamer_internal__MyArray_MyArrayIterator(self._orderedKeys)

    def iterator(self):
        return com_lightstreamer_internal__OrderedIntMap_OrderedIntMapIterator(self)

    def keyValueIterator(self):
        return haxe_iterators_MapKeyValueIterator(self)

    def copy(self):
        clone = com_lightstreamer_internal_OrderedIntMapImpl()
        clone._orderedKeys = self._orderedKeys.copy()
        clone._innerMap = self._innerMap.copy()
        return clone

    def get_length(self):
        _this = self._orderedKeys
        return (len(_this.values) - _this.nRemoved)

    def keysCopy(self):
        return self._orderedKeys.copy()

    def clear(self):
        self._orderedKeys = com_lightstreamer_internal_MyArray()
        self._innerMap = haxe_ds_IntMap()

    def toString(self):
        i = 0
        _this = self._orderedKeys
        _hx_len = (len(_this.values) - _this.nRemoved)
        _hx_str = "["
        k = com_lightstreamer_internal__MyArray_MyArrayIterator(self._orderedKeys)
        while k.hasNext():
            k1 = k.next()
            _hx_str = (("null" if _hx_str is None else _hx_str) + HxOverrides.stringOrNull(((((Std.string(k1) + " => ") + Std.string(self._innerMap.h.get(k1,None))) + HxOverrides.stringOrNull(((", " if ((i != ((_hx_len - 1)))) else "")))))))
            i = (i + 1)
        return (("null" if _hx_str is None else _hx_str) + "]")

com_lightstreamer_internal_OrderedIntMapImpl._hx_class = com_lightstreamer_internal_OrderedIntMapImpl


class com_lightstreamer_internal__OrderedIntMap_OrderedIntMapIterator:
    _hx_class_name = "com.lightstreamer.internal._OrderedIntMap.OrderedIntMapIterator"
    _hx_is_interface = "False"
    __slots__ = ("map", "it")
    _hx_fields = ["map", "it"]
    _hx_methods = ["hasNext", "next"]

    def __init__(self,omap):
        self.map = omap
        self.it = com_lightstreamer_internal__MyArray_MyArrayIterator(omap._orderedKeys)

    def hasNext(self):
        return self.it.hasNext()

    def next(self):
        _this = self.map
        key = self.it.next()
        return _this._innerMap.h.get(key,None)

com_lightstreamer_internal__OrderedIntMap_OrderedIntMapIterator._hx_class = com_lightstreamer_internal__OrderedIntMap_OrderedIntMapIterator


class com_lightstreamer_internal_IWsClient:
    _hx_class_name = "com.lightstreamer.internal.IWsClient"
    _hx_is_interface = "True"
    __slots__ = ()
    _hx_methods = ["dispose", "isDisposed", "send"]
com_lightstreamer_internal_IWsClient._hx_class = com_lightstreamer_internal_IWsClient


class com_lightstreamer_internal_ITimer:
    _hx_class_name = "com.lightstreamer.internal.ITimer"
    _hx_is_interface = "True"
    __slots__ = ()
    _hx_methods = ["cancel", "isCanceled"]
com_lightstreamer_internal_ITimer._hx_class = com_lightstreamer_internal_ITimer

class com_lightstreamer_internal_ReachabilityStatus(Enum):
    __slots__ = ()
    _hx_class_name = "com.lightstreamer.internal.ReachabilityStatus"
    _hx_constructs = ["RSReachable", "RSNotReachable"]
com_lightstreamer_internal_ReachabilityStatus.RSReachable = com_lightstreamer_internal_ReachabilityStatus("RSReachable", 0, ())
com_lightstreamer_internal_ReachabilityStatus.RSNotReachable = com_lightstreamer_internal_ReachabilityStatus("RSNotReachable", 1, ())
com_lightstreamer_internal_ReachabilityStatus._hx_class = com_lightstreamer_internal_ReachabilityStatus


class com_lightstreamer_internal_IReachability:
    _hx_class_name = "com.lightstreamer.internal.IReachability"
    _hx_is_interface = "True"
    __slots__ = ()
    _hx_methods = ["startListening", "stopListening"]
com_lightstreamer_internal_IReachability._hx_class = com_lightstreamer_internal_IReachability

class com_lightstreamer_internal_PageState(Enum):
    __slots__ = ()
    _hx_class_name = "com.lightstreamer.internal.PageState"
    _hx_constructs = ["Frozen", "Resumed"]
com_lightstreamer_internal_PageState.Frozen = com_lightstreamer_internal_PageState("Frozen", 0, ())
com_lightstreamer_internal_PageState.Resumed = com_lightstreamer_internal_PageState("Resumed", 1, ())
com_lightstreamer_internal_PageState._hx_class = com_lightstreamer_internal_PageState


class com_lightstreamer_internal_IFactory:
    _hx_class_name = "com.lightstreamer.internal.IFactory"
    _hx_is_interface = "True"
    __slots__ = ()
    _hx_methods = ["createWsClient", "createHttpClient", "createCtrlClient", "createReachabilityManager", "createTimer", "randomMillis", "createPageLifecycleFactory"]
com_lightstreamer_internal_IFactory._hx_class = com_lightstreamer_internal_IFactory


class com_lightstreamer_internal_Factory:
    _hx_class_name = "com.lightstreamer.internal.Factory"
    _hx_is_interface = "False"
    __slots__ = ("connectionOptions",)
    _hx_fields = ["connectionOptions"]
    _hx_methods = ["createWsClient", "createHttpClient", "createCtrlClient", "createReachabilityManager", "createTimer", "randomMillis", "createPageLifecycleFactory"]
    _hx_interfaces = [com_lightstreamer_internal_IFactory]

    def __init__(self,client):
        self.connectionOptions = client.connectionOptions

    def createWsClient(self,url,headers,onOpen,onText,onError):
        return com_lightstreamer_internal_WsClient(url,headers,self.connectionOptions.getProxy(),com_lightstreamer_internal_Globals.instance.getTrustManagerFactory(),onOpen,onText,onError)

    def createHttpClient(self,url,body,headers,onText,onError,onDone):
        return com_lightstreamer_internal_HttpClient(url,body,headers,self.connectionOptions.getProxy(),com_lightstreamer_internal_Globals.instance.getTrustManagerFactory(),onText,onError,onDone)

    def createCtrlClient(self,url,body,headers,onText,onError,onDone):
        return self.createHttpClient(url,body,headers,onText,onError,onDone)

    def createReachabilityManager(self,host):
        return com_lightstreamer_internal_ReachabilityManager()

    def createTimer(self,id,delay,callback):
        return com_lightstreamer_internal_TimerImpl(id,delay,callback)

    def randomMillis(self,_hx_max):
        x = _hx_max
        return (0 if ((x <= 0)) else int((python_lib_Random.random() * x)))

    def createPageLifecycleFactory(self,onEvent):
        return com_lightstreamer_internal_PageLifecycle(onEvent)

com_lightstreamer_internal_Factory._hx_class = com_lightstreamer_internal_Factory


class com_lightstreamer_internal_RLock:
    _hx_class_name = "com.lightstreamer.internal.RLock"
    _hx_is_interface = "False"
    __slots__ = ("lock",)
    _hx_fields = ["lock"]
    _hx_methods = ["acquire", "release", "synchronized"]

    def __init__(self):
        self.lock = sys_thread_Mutex()

    def acquire(self):
        self.lock.lock.acquire(True)

    def release(self):
        self.lock.lock.release()

    def synchronized(self,func):
        ex = None
        result = None
        self.lock.lock.acquire(True)
        try:
            result = func()
        except BaseException as _g:
            ex = haxe_Exception.caught(_g)
        self.lock.lock.release()
        if (ex is not None):
            raise haxe_Exception.thrown(ex)
        return result

com_lightstreamer_internal_RLock._hx_class = com_lightstreamer_internal_RLock


class com_lightstreamer_internal_ReachabilityManager:
    _hx_class_name = "com.lightstreamer.internal.ReachabilityManager"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_methods = ["startListening", "stopListening"]
    _hx_interfaces = [com_lightstreamer_internal_IReachability]

    def __init__(self):
        pass

    def startListening(self,onUpdate):
        pass

    def stopListening(self):
        pass

com_lightstreamer_internal_ReachabilityManager._hx_class = com_lightstreamer_internal_ReachabilityManager


class com_lightstreamer_internal__RequestBuilder_KeyVal:
    _hx_class_name = "com.lightstreamer.internal._RequestBuilder.KeyVal"
    _hx_is_interface = "False"
    __slots__ = ("key", "val")
    _hx_fields = ["key", "val"]
    _hx_methods = ["toEncodedPair", "toString"]

    def __init__(self,key,val):
        self.key = key
        self.val = val

    def toEncodedPair(self):
        return ((HxOverrides.stringOrNull(python_lib_urllib_Parse.quote(self.key,"")) + "=") + HxOverrides.stringOrNull(python_lib_urllib_Parse.quote(self.val,"")))

    def toString(self):
        return ((HxOverrides.stringOrNull(self.key) + "=") + HxOverrides.stringOrNull(self.val))

com_lightstreamer_internal__RequestBuilder_KeyVal._hx_class = com_lightstreamer_internal__RequestBuilder_KeyVal


class com_lightstreamer_internal_RequestBuilder:
    _hx_class_name = "com.lightstreamer.internal.RequestBuilder"
    _hx_is_interface = "False"
    __slots__ = ("params",)
    _hx_fields = ["params"]
    _hx_methods = ["LS_reqId", "LS_message", "LS_sequence", "LS_msg_prog", "LS_max_wait", "LS_outcome", "LS_ack", "LS_op", "LS_subId", "LS_mode", "LS_group", "LS_schema", "LS_data_adapter", "LS_requested_max_frequency", "LS_requested_max_frequency_Float", "LS_requested_buffer_size", "LS_requested_buffer_size_Int", "LS_cause", "LS_keepalive_millis", "LS_inactivity_millis", "LS_requested_max_bandwidth", "LS_requested_max_bandwidth_Float", "LS_adapter_set", "LS_user", "LS_password", "LS_cid", "LS_old_session", "LS_session", "LS_send_sync", "LS_polling", "LS_polling_millis", "LS_idle_millis", "LS_content_length", "LS_ttl_millis", "LS_recovery_from", "LS_close_socket", "LS_selector", "LS_snapshot", "LS_snapshot_Int", "addParamString", "addParamAny", "addParamBool", "getEncodedString", "toString"]

    def __init__(self):
        self.params = []

    def LS_reqId(self,val):
        self.addParamAny("LS_reqId",val)

    def LS_message(self,val):
        self.addParamString("LS_message",val)

    def LS_sequence(self,val):
        self.addParamString("LS_sequence",val)

    def LS_msg_prog(self,val):
        self.addParamAny("LS_msg_prog",val)

    def LS_max_wait(self,val):
        self.addParamAny("LS_max_wait",val)

    def LS_outcome(self,val):
        self.addParamBool("LS_outcome",val)

    def LS_ack(self,val):
        self.addParamBool("LS_ack",val)

    def LS_op(self,val):
        self.addParamString("LS_op",val)

    def LS_subId(self,val):
        self.addParamAny("LS_subId",val)

    def LS_mode(self,val):
        self.addParamString("LS_mode",val)

    def LS_group(self,val):
        self.addParamString("LS_group",val)

    def LS_schema(self,val):
        self.addParamString("LS_schema",val)

    def LS_data_adapter(self,val):
        self.addParamString("LS_data_adapter",val)

    def LS_requested_max_frequency(self,val):
        self.addParamString("LS_requested_max_frequency",val)

    def LS_requested_max_frequency_Float(self,val):
        self.addParamAny("LS_requested_max_frequency",val)

    def LS_requested_buffer_size(self,val):
        self.addParamString("LS_requested_buffer_size",val)

    def LS_requested_buffer_size_Int(self,val):
        self.addParamAny("LS_requested_buffer_size",val)

    def LS_cause(self,val):
        self.addParamString("LS_cause",val)

    def LS_keepalive_millis(self,val):
        self.addParamAny("LS_keepalive_millis",val)

    def LS_inactivity_millis(self,val):
        self.addParamAny("LS_inactivity_millis",val)

    def LS_requested_max_bandwidth(self,val):
        self.addParamString("LS_requested_max_bandwidth",val)

    def LS_requested_max_bandwidth_Float(self,val):
        self.addParamAny("LS_requested_max_bandwidth",val)

    def LS_adapter_set(self,val):
        self.addParamString("LS_adapter_set",val)

    def LS_user(self,val):
        self.addParamString("LS_user",val)

    def LS_password(self,val):
        self.addParamString("LS_password",val)

    def LS_cid(self,val):
        self.addParamString("LS_cid",val)

    def LS_old_session(self,val):
        self.addParamString("LS_old_session",val)

    def LS_session(self,val):
        self.addParamString("LS_session",val)

    def LS_send_sync(self,val):
        self.addParamBool("LS_send_sync",val)

    def LS_polling(self,val):
        self.addParamBool("LS_polling",val)

    def LS_polling_millis(self,val):
        self.addParamAny("LS_polling_millis",val)

    def LS_idle_millis(self,val):
        self.addParamAny("LS_idle_millis",val)

    def LS_content_length(self,val):
        self.addParamAny("LS_content_length",val)

    def LS_ttl_millis(self,val):
        self.addParamString("LS_ttl_millis",val)

    def LS_recovery_from(self,val):
        self.addParamAny("LS_recovery_from",val)

    def LS_close_socket(self,val):
        self.addParamBool("LS_close_socket",val)

    def LS_selector(self,val):
        self.addParamString("LS_selector",val)

    def LS_snapshot(self,val):
        self.addParamBool("LS_snapshot",val)

    def LS_snapshot_Int(self,val):
        self.addParamAny("LS_snapshot",val)

    def addParamString(self,key,val):
        x = com_lightstreamer_internal__RequestBuilder_KeyVal(key,val)
        self.params.append(x)

    def addParamAny(self,key,val):
        self.addParamString(key,("" + HxOverrides.stringOrNull((("null" if ((val is None)) else Std.string(val))))))

    def addParamBool(self,key,val):
        self.addParamString(key,("true" if val else "false"))

    def getEncodedString(self):
        def _hx_local_0(p):
            return p.toEncodedPair()
        _this = list(map(_hx_local_0,self.params))
        return "&".join([python_Boot.toString1(x1,'') for x1 in _this])

    def toString(self):
        _this = self.params
        return " ".join([python_Boot.toString1(x1,'') for x1 in _this])

com_lightstreamer_internal_RequestBuilder._hx_class = com_lightstreamer_internal_RequestBuilder


class com_lightstreamer_internal_Set:
    _hx_class_name = "com.lightstreamer.internal.Set"
    _hx_is_interface = "False"
    __slots__ = ("values",)
    _hx_fields = ["values"]
    _hx_methods = ["count", "insert", "contains", "remove", "removeAll", "copy", "union", "subtracting", "iterator", "toArray"]

    def __init__(self,it = None):
        self.values = []
        if (it is not None):
            while it.hasNext():
                self.insert(it.next())

    def count(self):
        return len(self.values)

    def insert(self,x):
        if (not (x in self.values)):
            self.values.append(x)

    def contains(self,x):
        return (x in self.values)

    def remove(self,x):
        python_internal_ArrayImpl.remove(self.values,x)

    def removeAll(self):
        _this = self.values
        _hx_len = len(self.values)
        _this[0:_hx_len]
        del _this[0:_hx_len]

    def copy(self):
        return com_lightstreamer_internal_Set(self.iterator())

    def union(self,other):
        res = com_lightstreamer_internal_Set()
        _g = 0
        _g1 = self.values
        while (_g < len(_g1)):
            def _hx_local_1():
                nonlocal _g
                _hx_local_0 = _g
                _g = (_g + 1)
                return _hx_local_0
            v = python_internal_ArrayImpl._get(_g1, _hx_local_1())
            res.insert(v)
        _g = 0
        while (_g < len(other)):
            def _hx_local_3():
                nonlocal _g
                _hx_local_2 = _g
                _g = (_g + 1)
                return _hx_local_2
            v = python_internal_ArrayImpl._get(other, _hx_local_3())
            res.insert(v)
        return res

    def subtracting(self,other):
        res = com_lightstreamer_internal_Set()
        _g = 0
        _g1 = self.values
        while (_g < len(_g1)):
            v = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if (not (v in other)):
                res.insert(v)
        return res

    def iterator(self):
        return haxe_iterators_ArrayIterator(self.values)

    def toArray(self):
        return self.values

com_lightstreamer_internal_Set._hx_class = com_lightstreamer_internal_Set


class haxe_Log:
    _hx_class_name = "haxe.Log"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["formatOutput", "trace"]

    @staticmethod
    def formatOutput(v,infos):
        _hx_str = Std.string(v)
        if (infos is None):
            return _hx_str
        pstr = ((HxOverrides.stringOrNull(infos.fileName) + ":") + Std.string(infos.lineNumber))
        if (Reflect.field(infos,"customParams") is not None):
            _g = 0
            _g1 = Reflect.field(infos,"customParams")
            while (_g < len(_g1)):
                def _hx_local_1():
                    nonlocal _g
                    _hx_local_0 = _g
                    _g = (_g + 1)
                    return _hx_local_0
                v = python_internal_ArrayImpl._get(_g1, _hx_local_1())
                _hx_str = (("null" if _hx_str is None else _hx_str) + ((", " + Std.string(v))))
        return ((("null" if pstr is None else pstr) + ": ") + ("null" if _hx_str is None else _hx_str))

    @staticmethod
    def trace(v,infos = None):
        python_Lib.printString((("" + Std.string(haxe_Log.formatOutput(v,infos))) + HxOverrides.stringOrNull(python_Lib.lineEnd)))
haxe_Log._hx_class = haxe_Log


class python_Boot:
    _hx_class_name = "python.Boot"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["keywords", "toString1", "fields", "simpleField", "field", "getInstanceFields", "getSuperClass", "getClassFields", "prefixLength", "unhandleKeywords"]

    @staticmethod
    def toString1(o,s):
        if (o is None):
            return "null"
        if isinstance(o,str):
            return o
        if (s is None):
            s = ""
        if (len(s) >= 5):
            return "<...>"
        if isinstance(o,bool):
            if o:
                return "true"
            else:
                return "false"
        if (isinstance(o,int) and (not isinstance(o,bool))):
            return str(o)
        if isinstance(o,float):
            try:
                if (o == int(o)):
                    return str(Math.floor((o + 0.5)))
                else:
                    return str(o)
            except BaseException as _g:
                None
                return str(o)
        if isinstance(o,list):
            o1 = o
            l = len(o1)
            st = "["
            s = (("null" if s is None else s) + "\t")
            _g = 0
            _g1 = l
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                prefix = ""
                if (i > 0):
                    prefix = ","
                st = (("null" if st is None else st) + HxOverrides.stringOrNull(((("null" if prefix is None else prefix) + HxOverrides.stringOrNull(python_Boot.toString1((o1[i] if i >= 0 and i < len(o1) else None),s))))))
            st = (("null" if st is None else st) + "]")
            return st
        try:
            if hasattr(o,"toString"):
                return o.toString()
        except BaseException as _g:
            None
        if hasattr(o,"__class__"):
            if isinstance(o,_hx_AnonObject):
                toStr = None
                try:
                    fields = python_Boot.fields(o)
                    _g = []
                    _g1 = 0
                    while (_g1 < len(fields)):
                        f = (fields[_g1] if _g1 >= 0 and _g1 < len(fields) else None)
                        _g1 = (_g1 + 1)
                        x = ((("" + ("null" if f is None else f)) + " : ") + HxOverrides.stringOrNull(python_Boot.toString1(python_Boot.simpleField(o,f),(("null" if s is None else s) + "\t"))))
                        _g.append(x)
                    fieldsStr = _g
                    toStr = (("{ " + HxOverrides.stringOrNull(", ".join([x1 for x1 in fieldsStr]))) + " }")
                except BaseException as _g:
                    None
                    return "{ ... }"
                if (toStr is None):
                    return "{ ... }"
                else:
                    return toStr
            if isinstance(o,Enum):
                o1 = o
                l = len(o1.params)
                hasParams = (l > 0)
                if hasParams:
                    paramsStr = ""
                    _g = 0
                    _g1 = l
                    while (_g < _g1):
                        i = _g
                        _g = (_g + 1)
                        prefix = ""
                        if (i > 0):
                            prefix = ","
                        paramsStr = (("null" if paramsStr is None else paramsStr) + HxOverrides.stringOrNull(((("null" if prefix is None else prefix) + HxOverrides.stringOrNull(python_Boot.toString1(o1.params[i],s))))))
                    return (((HxOverrides.stringOrNull(o1.tag) + "(") + ("null" if paramsStr is None else paramsStr)) + ")")
                else:
                    return o1.tag
            if hasattr(o,"_hx_class_name"):
                if (o.__class__.__name__ != "type"):
                    fields = python_Boot.getInstanceFields(o)
                    _g = []
                    _g1 = 0
                    while (_g1 < len(fields)):
                        f = (fields[_g1] if _g1 >= 0 and _g1 < len(fields) else None)
                        _g1 = (_g1 + 1)
                        x = ((("" + ("null" if f is None else f)) + " : ") + HxOverrides.stringOrNull(python_Boot.toString1(python_Boot.simpleField(o,f),(("null" if s is None else s) + "\t"))))
                        _g.append(x)
                    fieldsStr = _g
                    toStr = (((HxOverrides.stringOrNull(o._hx_class_name) + "( ") + HxOverrides.stringOrNull(", ".join([x1 for x1 in fieldsStr]))) + " )")
                    return toStr
                else:
                    fields = python_Boot.getClassFields(o)
                    _g = []
                    _g1 = 0
                    while (_g1 < len(fields)):
                        f = (fields[_g1] if _g1 >= 0 and _g1 < len(fields) else None)
                        _g1 = (_g1 + 1)
                        x = ((("" + ("null" if f is None else f)) + " : ") + HxOverrides.stringOrNull(python_Boot.toString1(python_Boot.simpleField(o,f),(("null" if s is None else s) + "\t"))))
                        _g.append(x)
                    fieldsStr = _g
                    toStr = (((("#" + HxOverrides.stringOrNull(o._hx_class_name)) + "( ") + HxOverrides.stringOrNull(", ".join([x1 for x1 in fieldsStr]))) + " )")
                    return toStr
            if ((type(o) == type) and (o == str)):
                return "#String"
            if ((type(o) == type) and (o == list)):
                return "#Array"
            if callable(o):
                return "function"
            try:
                if hasattr(o,"__repr__"):
                    return o.__repr__()
            except BaseException as _g:
                None
            if hasattr(o,"__str__"):
                return o.__str__([])
            if hasattr(o,"__name__"):
                return o.__name__
            return "???"
        else:
            return str(o)

    @staticmethod
    def fields(o):
        a = []
        if (o is not None):
            if hasattr(o,"_hx_fields"):
                fields = o._hx_fields
                if (fields is not None):
                    return list(fields)
            if isinstance(o,_hx_AnonObject):
                d = o.__dict__
                keys = d.keys()
                handler = python_Boot.unhandleKeywords
                for k in keys:
                    if (k != '_hx_disable_getattr'):
                        a.append(handler(k))
            elif hasattr(o,"__dict__"):
                d = o.__dict__
                keys1 = d.keys()
                for k in keys1:
                    a.append(k)
        return a

    @staticmethod
    def simpleField(o,field):
        if (field is None):
            return None
        field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
        if hasattr(o,field1):
            return getattr(o,field1)
        else:
            return None

    @staticmethod
    def field(o,field):
        if (field is None):
            return None
        if isinstance(o,str):
            _hx_local_0 = len(field)
            if (_hx_local_0 == 10):
                if (field == "charCodeAt"):
                    return python_internal_MethodClosure(o,HxString.charCodeAt)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field1) if (hasattr(o,field1)) else None)
            elif (_hx_local_0 == 11):
                if (field == "lastIndexOf"):
                    return python_internal_MethodClosure(o,HxString.lastIndexOf)
                elif (field == "toLowerCase"):
                    return python_internal_MethodClosure(o,HxString.toLowerCase)
                elif (field == "toUpperCase"):
                    return python_internal_MethodClosure(o,HxString.toUpperCase)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field1) if (hasattr(o,field1)) else None)
            elif (_hx_local_0 == 9):
                if (field == "substring"):
                    return python_internal_MethodClosure(o,HxString.substring)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field1) if (hasattr(o,field1)) else None)
            elif (_hx_local_0 == 5):
                if (field == "split"):
                    return python_internal_MethodClosure(o,HxString.split)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field1) if (hasattr(o,field1)) else None)
            elif (_hx_local_0 == 7):
                if (field == "indexOf"):
                    return python_internal_MethodClosure(o,HxString.indexOf)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field1) if (hasattr(o,field1)) else None)
            elif (_hx_local_0 == 8):
                if (field == "toString"):
                    return python_internal_MethodClosure(o,HxString.toString)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field1) if (hasattr(o,field1)) else None)
            elif (_hx_local_0 == 6):
                if (field == "charAt"):
                    return python_internal_MethodClosure(o,HxString.charAt)
                elif (field == "length"):
                    return len(o)
                elif (field == "substr"):
                    return python_internal_MethodClosure(o,HxString.substr)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field1) if (hasattr(o,field1)) else None)
            else:
                field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                return (getattr(o,field1) if (hasattr(o,field1)) else None)
        elif isinstance(o,list):
            _hx_local_1 = len(field)
            if (_hx_local_1 == 11):
                if (field == "lastIndexOf"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.lastIndexOf)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field1) if (hasattr(o,field1)) else None)
            elif (_hx_local_1 == 4):
                if (field == "copy"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.copy)
                elif (field == "join"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.join)
                elif (field == "push"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.push)
                elif (field == "sort"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.sort)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field1) if (hasattr(o,field1)) else None)
            elif (_hx_local_1 == 5):
                if (field == "shift"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.shift)
                elif (field == "slice"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.slice)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field1) if (hasattr(o,field1)) else None)
            elif (_hx_local_1 == 7):
                if (field == "indexOf"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.indexOf)
                elif (field == "reverse"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.reverse)
                elif (field == "unshift"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.unshift)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field1) if (hasattr(o,field1)) else None)
            elif (_hx_local_1 == 3):
                if (field == "map"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.map)
                elif (field == "pop"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.pop)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field1) if (hasattr(o,field1)) else None)
            elif (_hx_local_1 == 8):
                if (field == "contains"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.contains)
                elif (field == "iterator"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.iterator)
                elif (field == "toString"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.toString)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field1) if (hasattr(o,field1)) else None)
            elif (_hx_local_1 == 16):
                if (field == "keyValueIterator"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.keyValueIterator)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field1) if (hasattr(o,field1)) else None)
            elif (_hx_local_1 == 6):
                if (field == "concat"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.concat)
                elif (field == "filter"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.filter)
                elif (field == "insert"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.insert)
                elif (field == "length"):
                    return len(o)
                elif (field == "remove"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.remove)
                elif (field == "splice"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.splice)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field1) if (hasattr(o,field1)) else None)
            else:
                field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                return (getattr(o,field1) if (hasattr(o,field1)) else None)
        else:
            field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
            return (getattr(o,field1) if (hasattr(o,field1)) else None)

    @staticmethod
    def getInstanceFields(c):
        f = (list(c._hx_fields) if (hasattr(c,"_hx_fields")) else [])
        if hasattr(c,"_hx_methods"):
            f = (f + c._hx_methods)
        sc = python_Boot.getSuperClass(c)
        if (sc is None):
            return f
        else:
            scArr = python_Boot.getInstanceFields(sc)
            scMap = set(scArr)
            _g = 0
            while (_g < len(f)):
                f1 = (f[_g] if _g >= 0 and _g < len(f) else None)
                _g = (_g + 1)
                if (not (f1 in scMap)):
                    scArr.append(f1)
            return scArr

    @staticmethod
    def getSuperClass(c):
        if (c is None):
            return None
        try:
            if hasattr(c,"_hx_super"):
                return c._hx_super
            return None
        except BaseException as _g:
            None
        return None

    @staticmethod
    def getClassFields(c):
        if hasattr(c,"_hx_statics"):
            x = c._hx_statics
            return list(x)
        else:
            return []

    @staticmethod
    def unhandleKeywords(name):
        if (HxString.substr(name,0,python_Boot.prefixLength) == "_hx_"):
            real = HxString.substr(name,python_Boot.prefixLength,None)
            if (real in python_Boot.keywords):
                return real
        return name
python_Boot._hx_class = python_Boot


class HxString:
    _hx_class_name = "HxString"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["split", "charCodeAt", "charAt", "lastIndexOf", "toUpperCase", "toLowerCase", "indexOf", "indexOfImpl", "toString", "substring", "substr"]

    @staticmethod
    def split(s,d):
        if (d == ""):
            return list(s)
        else:
            return s.split(d)

    @staticmethod
    def charCodeAt(s,index):
        if ((((s is None) or ((len(s) == 0))) or ((index < 0))) or ((index >= len(s)))):
            return None
        else:
            return ord(s[index])

    @staticmethod
    def charAt(s,index):
        if ((index < 0) or ((index >= len(s)))):
            return ""
        else:
            return s[index]

    @staticmethod
    def lastIndexOf(s,_hx_str,startIndex = None):
        if (startIndex is None):
            return s.rfind(_hx_str, 0, len(s))
        elif (_hx_str == ""):
            length = len(s)
            if (startIndex < 0):
                startIndex = (length + startIndex)
                if (startIndex < 0):
                    startIndex = 0
            if (startIndex > length):
                return length
            else:
                return startIndex
        else:
            i = s.rfind(_hx_str, 0, (startIndex + 1))
            startLeft = (max(0,((startIndex + 1) - len(_hx_str))) if ((i == -1)) else (i + 1))
            check = s.find(_hx_str, startLeft, len(s))
            if ((check > i) and ((check <= startIndex))):
                return check
            else:
                return i

    @staticmethod
    def toUpperCase(s):
        return s.upper()

    @staticmethod
    def toLowerCase(s):
        return s.lower()

    @staticmethod
    def indexOf(s,_hx_str,startIndex = None):
        if (startIndex is None):
            return s.find(_hx_str)
        else:
            return HxString.indexOfImpl(s,_hx_str,startIndex)

    @staticmethod
    def indexOfImpl(s,_hx_str,startIndex):
        if (_hx_str == ""):
            length = len(s)
            if (startIndex < 0):
                startIndex = (length + startIndex)
                if (startIndex < 0):
                    startIndex = 0
            if (startIndex > length):
                return length
            else:
                return startIndex
        return s.find(_hx_str, startIndex)

    @staticmethod
    def toString(s):
        return s

    @staticmethod
    def substring(s,startIndex,endIndex = None):
        if (startIndex < 0):
            startIndex = 0
        if (endIndex is None):
            return s[startIndex:]
        else:
            if (endIndex < 0):
                endIndex = 0
            if (endIndex < startIndex):
                return s[endIndex:startIndex]
            else:
                return s[startIndex:endIndex]

    @staticmethod
    def substr(s,startIndex,_hx_len = None):
        if (_hx_len is None):
            return s[startIndex:]
        else:
            if (_hx_len == 0):
                return ""
            if (startIndex < 0):
                startIndex = (len(s) + startIndex)
                if (startIndex < 0):
                    startIndex = 0
            return s[startIndex:(startIndex + _hx_len)]
HxString._hx_class = HxString


class python_Lib:
    _hx_class_name = "python.Lib"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["lineEnd", "printString", "anonToDict", "anonAsDict"]

    @staticmethod
    def printString(_hx_str):
        python_lib_Sys.stdout.buffer.write(_hx_str.encode("utf-8", "strict"))
        python_lib_Sys.stdout.flush()

    @staticmethod
    def anonToDict(o):
        if isinstance(o,_hx_AnonObject):
            return o.__dict__.copy()
        else:
            return None

    @staticmethod
    def anonAsDict(o):
        if isinstance(o,_hx_AnonObject):
            return o.__dict__
        else:
            return None
python_Lib._hx_class = python_Lib


class python__KwArgs_KwArgs_Impl_:
    _hx_class_name = "python._KwArgs.KwArgs_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["fromT"]

    @staticmethod
    def fromT(d):
        return python_Lib.anonAsDict(d)
python__KwArgs_KwArgs_Impl_._hx_class = python__KwArgs_KwArgs_Impl_


class com_lightstreamer_internal__Threads_Threads_Fields_:
    _hx_class_name = "com.lightstreamer.internal._Threads.Threads_Fields_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["createExecutor", "userThread", "sessionThread"]

    @staticmethod
    def createExecutor():
        def _hx_local_0(v,infos = None):
            python_Lib.printString((("" + Std.string(haxe_Log.formatOutput(v,infos))) + HxOverrides.stringOrNull(python_Lib.lineEnd)))
        haxe_Log.trace = _hx_local_0
        return com_lightstreamer_internal_Executor()
com_lightstreamer_internal__Threads_Threads_Fields_._hx_class = com_lightstreamer_internal__Threads_Threads_Fields_


class com_lightstreamer_internal__Timer_TimerMillis_Impl_:
    _hx_class_name = "com.lightstreamer.internal._Timer.TimerMillis_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["_new", "toMillis", "toLong"]

    @staticmethod
    def _new(millis):
        return millis

    @staticmethod
    def toMillis(this1):
        return this1

    @staticmethod
    def toLong(this1):
        return this1
com_lightstreamer_internal__Timer_TimerMillis_Impl_._hx_class = com_lightstreamer_internal__Timer_TimerMillis_Impl_


class com_lightstreamer_internal__Timer_TimerStamp_Impl_:
    _hx_class_name = "com.lightstreamer.internal._Timer.TimerStamp_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["_new", "now", "plus", "minus", "toFloat"]

    @staticmethod
    def _new(seconds):
        return seconds

    @staticmethod
    def now():
        return python_lib_Timeit.default_timer()

    @staticmethod
    def plus(this1,rhs):
        return ((this1 * 1000) + rhs)

    @staticmethod
    def minus(this1,rhs):
        return (((this1 - rhs)) * 1000)

    @staticmethod
    def toFloat(this1):
        return this1
com_lightstreamer_internal__Timer_TimerStamp_Impl_._hx_class = com_lightstreamer_internal__Timer_TimerStamp_Impl_


class com_lightstreamer_internal_TimerImpl:
    _hx_class_name = "com.lightstreamer.internal.TimerImpl"
    _hx_is_interface = "False"
    __slots__ = ("task",)
    _hx_fields = ["task"]
    _hx_methods = ["cancel", "isCanceled"]
    _hx_interfaces = [com_lightstreamer_internal_ITimer]

    def __init__(self,id,delay,callback):
        self.task = None
        _gthis = self
        _this = com_lightstreamer_internal__Threads_Threads_Fields_.sessionThread.loop
        def _hx_local_0():
            callback(_gthis)
        self.task = _this.call_soon_threadsafe(_this.call_later,(delay / 1000.0),_hx_local_0)

    def cancel(self):
        self.task.cancel()

    def isCanceled(self):
        return self.task.cancelled()

com_lightstreamer_internal_TimerImpl._hx_class = com_lightstreamer_internal_TimerImpl

class com_lightstreamer_internal_FieldValue(Enum):
    __slots__ = ()
    _hx_class_name = "com.lightstreamer.internal.FieldValue"
    _hx_constructs = ["unchanged", "changed", "jsonPatch", "diffPatch"]

    @staticmethod
    def changed(val):
        return com_lightstreamer_internal_FieldValue("changed", 1, (val,))

    @staticmethod
    def jsonPatch(patch):
        return com_lightstreamer_internal_FieldValue("jsonPatch", 2, (patch,))

    @staticmethod
    def diffPatch(patch):
        return com_lightstreamer_internal_FieldValue("diffPatch", 3, (patch,))
com_lightstreamer_internal_FieldValue.unchanged = com_lightstreamer_internal_FieldValue("unchanged", 0, ())
com_lightstreamer_internal_FieldValue._hx_class = com_lightstreamer_internal_FieldValue


class com_lightstreamer_internal__Types_Millis_Impl_:
    _hx_class_name = "com.lightstreamer.internal._Types.Millis_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["ZERO", "_new", "fromIntGt0", "fromIntGtEq0", "gti", "gt", "lt", "plus", "minus", "toInt"]

    @staticmethod
    def _new(millis):
        return millis

    @staticmethod
    def fromIntGt0(millis):
        if (millis <= 0):
            raise com_lightstreamer_internal_IllegalArgumentException("value must be greater than zero")
        return millis

    @staticmethod
    def fromIntGtEq0(millis):
        if (millis < 0):
            raise com_lightstreamer_internal_IllegalArgumentException("value must be greater than or equal to zero")
        return millis

    @staticmethod
    def gti(this1,rhs):
        return (this1 > rhs)

    @staticmethod
    def gt(this1,rhs):
        return (this1 > rhs)

    @staticmethod
    def lt(this1,rhs):
        return (this1 < rhs)

    @staticmethod
    def plus(this1,rhs):
        return (this1 + rhs)

    @staticmethod
    def minus(this1,rhs):
        return (this1 - rhs)

    @staticmethod
    def toInt(this1):
        return this1
com_lightstreamer_internal__Types_Millis_Impl_._hx_class = com_lightstreamer_internal__Types_Millis_Impl_


class com_lightstreamer_internal__Types_Timestamp_Impl_:
    _hx_class_name = "com.lightstreamer.internal._Types.Timestamp_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["_new"]

    @staticmethod
    def _new(ts):
        return ts
com_lightstreamer_internal__Types_Timestamp_Impl_._hx_class = com_lightstreamer_internal__Types_Timestamp_Impl_


class com_lightstreamer_internal__Types_ContentLength_Impl_:
    _hx_class_name = "com.lightstreamer.internal._Types.ContentLength_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["_new", "fromIntGt0"]

    @staticmethod
    def _new(length):
        return length

    @staticmethod
    def fromIntGt0(millis):
        if (millis <= 0):
            raise com_lightstreamer_internal_IllegalArgumentException("value must be greater than zero")
        return millis
com_lightstreamer_internal__Types_ContentLength_Impl_._hx_class = com_lightstreamer_internal__Types_ContentLength_Impl_


class com_lightstreamer_internal__Types_TransportSelection_Impl_:
    _hx_class_name = "com.lightstreamer.internal._Types.TransportSelection_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["WS", "WS_STREAMING", "WS_POLLING", "HTTP", "HTTP_STREAMING", "HTTP_POLLING", "fromString"]

    @staticmethod
    def fromString(transport):
        if (transport is None):
            return None
        else:
            _hx_local_0 = len(transport)
            if (_hx_local_0 == 10):
                if (transport == "WS-POLLING"):
                    return "WS-POLLING"
                else:
                    raise com_lightstreamer_internal_IllegalArgumentException("The given value is not valid. Use one of: HTTP-STREAMING, HTTP-POLLING, WS-STREAMING, WS-POLLING, WS, HTTP or null")
            elif (_hx_local_0 == 4):
                if (transport == "HTTP"):
                    return "HTTP"
                else:
                    raise com_lightstreamer_internal_IllegalArgumentException("The given value is not valid. Use one of: HTTP-STREAMING, HTTP-POLLING, WS-STREAMING, WS-POLLING, WS, HTTP or null")
            elif (_hx_local_0 == 12):
                if (transport == "HTTP-POLLING"):
                    return "HTTP-POLLING"
                elif (transport == "WS-STREAMING"):
                    return "WS-STREAMING"
                else:
                    raise com_lightstreamer_internal_IllegalArgumentException("The given value is not valid. Use one of: HTTP-STREAMING, HTTP-POLLING, WS-STREAMING, WS-POLLING, WS, HTTP or null")
            elif (_hx_local_0 == 14):
                if (transport == "HTTP-STREAMING"):
                    return "HTTP-STREAMING"
                else:
                    raise com_lightstreamer_internal_IllegalArgumentException("The given value is not valid. Use one of: HTTP-STREAMING, HTTP-POLLING, WS-STREAMING, WS-POLLING, WS, HTTP or null")
            elif (_hx_local_0 == 2):
                if (transport == "WS"):
                    return "WS"
                else:
                    raise com_lightstreamer_internal_IllegalArgumentException("The given value is not valid. Use one of: HTTP-STREAMING, HTTP-POLLING, WS-STREAMING, WS-POLLING, WS, HTTP or null")
            else:
                raise com_lightstreamer_internal_IllegalArgumentException("The given value is not valid. Use one of: HTTP-STREAMING, HTTP-POLLING, WS-STREAMING, WS-POLLING, WS, HTTP or null")
com_lightstreamer_internal__Types_TransportSelection_Impl_._hx_class = com_lightstreamer_internal__Types_TransportSelection_Impl_


class com_lightstreamer_internal__Types_ServerAddress_Impl_:
    _hx_class_name = "com.lightstreamer.internal._Types.ServerAddress_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["_new", "fromString"]

    @staticmethod
    def _new(address):
        return address

    @staticmethod
    def fromString(address):
        if (address is None):
            return None
        elif (address.startswith("http://") or address.startswith("https://")):
            return address
        else:
            raise com_lightstreamer_internal_IllegalArgumentException("address is malformed")
com_lightstreamer_internal__Types_ServerAddress_Impl_._hx_class = com_lightstreamer_internal__Types_ServerAddress_Impl_

class com_lightstreamer_internal_RequestedMaxBandwidth(Enum):
    __slots__ = ()
    _hx_class_name = "com.lightstreamer.internal.RequestedMaxBandwidth"
    _hx_constructs = ["BWLimited", "BWUnlimited"]

    @staticmethod
    def BWLimited(bw):
        return com_lightstreamer_internal_RequestedMaxBandwidth("BWLimited", 0, (bw,))
com_lightstreamer_internal_RequestedMaxBandwidth.BWUnlimited = com_lightstreamer_internal_RequestedMaxBandwidth("BWUnlimited", 1, ())
com_lightstreamer_internal_RequestedMaxBandwidth._hx_class = com_lightstreamer_internal_RequestedMaxBandwidth


class com_lightstreamer_internal_RequestedMaxBandwidthTools:
    _hx_class_name = "com.lightstreamer.internal.RequestedMaxBandwidthTools"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["fromString", "toString"]

    @staticmethod
    def fromString(bandwidth):
        _hx_tmp = None
        if (bandwidth.lower() == "unlimited"):
            return com_lightstreamer_internal_RequestedMaxBandwidth.BWUnlimited
        else:
            _hx_tmp = Std.parseFloat(bandwidth)
            if ((not python_lib_Math.isnan(_hx_tmp)) and ((_hx_tmp > 0))):
                return com_lightstreamer_internal_RequestedMaxBandwidth.BWLimited(_hx_tmp)
            else:
                raise com_lightstreamer_internal_IllegalArgumentException("The given value is a not valid value for RequestedMaxBandwidth. Use a positive number or the string \"unlimited\"")

    @staticmethod
    def toString(bandwidth):
        tmp = bandwidth.index
        if (tmp == 0):
            return Std.string(bandwidth.params[0])
        elif (tmp == 1):
            return "unlimited"
        else:
            pass
com_lightstreamer_internal_RequestedMaxBandwidthTools._hx_class = com_lightstreamer_internal_RequestedMaxBandwidthTools

class com_lightstreamer_internal_RequestedBufferSize(Enum):
    __slots__ = ()
    _hx_class_name = "com.lightstreamer.internal.RequestedBufferSize"
    _hx_constructs = ["BSLimited", "BSUnlimited"]

    @staticmethod
    def BSLimited(size):
        return com_lightstreamer_internal_RequestedBufferSize("BSLimited", 0, (size,))
com_lightstreamer_internal_RequestedBufferSize.BSUnlimited = com_lightstreamer_internal_RequestedBufferSize("BSUnlimited", 1, ())
com_lightstreamer_internal_RequestedBufferSize._hx_class = com_lightstreamer_internal_RequestedBufferSize


class com_lightstreamer_internal_RequestedBufferSizeTools:
    _hx_class_name = "com.lightstreamer.internal.RequestedBufferSizeTools"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["fromString", "toString", "extEquals"]

    @staticmethod
    def fromString(size):
        if (size is None):
            return None
        else:
            _hx_tmp = None
            if (size.lower() == "unlimited"):
                return com_lightstreamer_internal_RequestedBufferSize.BSUnlimited
            else:
                _hx_tmp = Std.parseInt(size)
                if ((_hx_tmp is not None) and ((_hx_tmp > 0))):
                    return com_lightstreamer_internal_RequestedBufferSize.BSLimited(_hx_tmp)
                else:
                    raise com_lightstreamer_internal_IllegalArgumentException("The given value is not valid for this setting; use null, 'unlimited' or a positive integer instead")

    @staticmethod
    def toString(size):
        if (size is None):
            return None
        else:
            tmp = size.index
            if (tmp == 0):
                return Std.string(size.params[0])
            elif (tmp == 1):
                return "unlimited"
            else:
                pass

    @staticmethod
    def extEquals(a,b):
        if (a is None):
            if (b is None):
                return True
            else:
                return False
        elif (b is None):
            return False
        else:
            return Type.enumEq(a,b)
com_lightstreamer_internal_RequestedBufferSizeTools._hx_class = com_lightstreamer_internal_RequestedBufferSizeTools

class com_lightstreamer_internal_RequestedSnapshot(Enum):
    __slots__ = ()
    _hx_class_name = "com.lightstreamer.internal.RequestedSnapshot"
    _hx_constructs = ["SnpYes", "SnpNo", "SnpLength"]

    @staticmethod
    def SnpLength(len):
        return com_lightstreamer_internal_RequestedSnapshot("SnpLength", 2, (len,))
com_lightstreamer_internal_RequestedSnapshot.SnpYes = com_lightstreamer_internal_RequestedSnapshot("SnpYes", 0, ())
com_lightstreamer_internal_RequestedSnapshot.SnpNo = com_lightstreamer_internal_RequestedSnapshot("SnpNo", 1, ())
com_lightstreamer_internal_RequestedSnapshot._hx_class = com_lightstreamer_internal_RequestedSnapshot


class com_lightstreamer_internal_RequestedSnapshotTools:
    _hx_class_name = "com.lightstreamer.internal.RequestedSnapshotTools"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["fromString", "toString"]

    @staticmethod
    def fromString(snapshot):
        if (snapshot is None):
            return None
        else:
            _hx_tmp = None
            _hx_tmp1 = snapshot.lower()
            _hx_local_0 = len(_hx_tmp1)
            if (_hx_local_0 == 3):
                if (_hx_tmp1 == "yes"):
                    return com_lightstreamer_internal_RequestedSnapshot.SnpYes
                else:
                    _hx_tmp = Std.parseInt(snapshot)
                    if ((_hx_tmp is not None) and ((_hx_tmp > 0))):
                        return com_lightstreamer_internal_RequestedSnapshot.SnpLength(_hx_tmp)
                    else:
                        raise com_lightstreamer_internal_IllegalArgumentException("The given value is not valid for this setting; use null, 'yes', 'no' or a positive number instead")
            elif (_hx_local_0 == 2):
                if (_hx_tmp1 == "no"):
                    return com_lightstreamer_internal_RequestedSnapshot.SnpNo
                else:
                    _hx_tmp = Std.parseInt(snapshot)
                    if ((_hx_tmp is not None) and ((_hx_tmp > 0))):
                        return com_lightstreamer_internal_RequestedSnapshot.SnpLength(_hx_tmp)
                    else:
                        raise com_lightstreamer_internal_IllegalArgumentException("The given value is not valid for this setting; use null, 'yes', 'no' or a positive number instead")
            else:
                _hx_tmp = Std.parseInt(snapshot)
                if ((_hx_tmp is not None) and ((_hx_tmp > 0))):
                    return com_lightstreamer_internal_RequestedSnapshot.SnpLength(_hx_tmp)
                else:
                    raise com_lightstreamer_internal_IllegalArgumentException("The given value is not valid for this setting; use null, 'yes', 'no' or a positive number instead")

    @staticmethod
    def toString(snapshot):
        if (snapshot is None):
            return None
        else:
            tmp = snapshot.index
            if (tmp == 0):
                return "yes"
            elif (tmp == 1):
                return "no"
            elif (tmp == 2):
                return Std.string(snapshot.params[0])
            else:
                pass
com_lightstreamer_internal_RequestedSnapshotTools._hx_class = com_lightstreamer_internal_RequestedSnapshotTools

class com_lightstreamer_internal_RequestedMaxFrequency(Enum):
    __slots__ = ()
    _hx_class_name = "com.lightstreamer.internal.RequestedMaxFrequency"
    _hx_constructs = ["FreqLimited", "FreqUnlimited", "FreqUnfiltered"]

    @staticmethod
    def FreqLimited(max):
        return com_lightstreamer_internal_RequestedMaxFrequency("FreqLimited", 0, (max,))
com_lightstreamer_internal_RequestedMaxFrequency.FreqUnlimited = com_lightstreamer_internal_RequestedMaxFrequency("FreqUnlimited", 1, ())
com_lightstreamer_internal_RequestedMaxFrequency.FreqUnfiltered = com_lightstreamer_internal_RequestedMaxFrequency("FreqUnfiltered", 2, ())
com_lightstreamer_internal_RequestedMaxFrequency._hx_class = com_lightstreamer_internal_RequestedMaxFrequency


class com_lightstreamer_internal_RequestedMaxFrequencyTools:
    _hx_class_name = "com.lightstreamer.internal.RequestedMaxFrequencyTools"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["fromString", "toString", "extEquals"]

    @staticmethod
    def fromString(freq):
        if (freq is None):
            return None
        else:
            _hx_tmp = None
            _hx_tmp1 = freq.lower()
            _hx_local_0 = len(_hx_tmp1)
            if (_hx_local_0 == 10):
                if (_hx_tmp1 == "unfiltered"):
                    return com_lightstreamer_internal_RequestedMaxFrequency.FreqUnfiltered
                else:
                    _hx_tmp = Std.parseFloat(freq)
                    if ((not python_lib_Math.isnan(_hx_tmp)) and ((_hx_tmp > 0))):
                        return com_lightstreamer_internal_RequestedMaxFrequency.FreqLimited(_hx_tmp)
                    else:
                        raise com_lightstreamer_internal_IllegalArgumentException("The given value is not valid for this setting; use null, 'unlimited', 'unfiltered' or a positive number instead")
            elif (_hx_local_0 == 9):
                if (_hx_tmp1 == "unlimited"):
                    return com_lightstreamer_internal_RequestedMaxFrequency.FreqUnlimited
                else:
                    _hx_tmp = Std.parseFloat(freq)
                    if ((not python_lib_Math.isnan(_hx_tmp)) and ((_hx_tmp > 0))):
                        return com_lightstreamer_internal_RequestedMaxFrequency.FreqLimited(_hx_tmp)
                    else:
                        raise com_lightstreamer_internal_IllegalArgumentException("The given value is not valid for this setting; use null, 'unlimited', 'unfiltered' or a positive number instead")
            else:
                _hx_tmp = Std.parseFloat(freq)
                if ((not python_lib_Math.isnan(_hx_tmp)) and ((_hx_tmp > 0))):
                    return com_lightstreamer_internal_RequestedMaxFrequency.FreqLimited(_hx_tmp)
                else:
                    raise com_lightstreamer_internal_IllegalArgumentException("The given value is not valid for this setting; use null, 'unlimited', 'unfiltered' or a positive number instead")

    @staticmethod
    def toString(freq):
        if (freq is None):
            return None
        else:
            tmp = freq.index
            if (tmp == 0):
                return Std.string(freq.params[0])
            elif (tmp == 1):
                return "unlimited"
            elif (tmp == 2):
                return "unfiltered"
            else:
                pass

    @staticmethod
    def extEquals(a,b):
        if (a is None):
            if (b is None):
                return True
            else:
                return False
        elif (b is None):
            return False
        else:
            return Type.enumEq(a,b)
com_lightstreamer_internal_RequestedMaxFrequencyTools._hx_class = com_lightstreamer_internal_RequestedMaxFrequencyTools

class com_lightstreamer_internal_RealMaxFrequency(Enum):
    __slots__ = ()
    _hx_class_name = "com.lightstreamer.internal.RealMaxFrequency"
    _hx_constructs = ["RFreqLimited", "RFreqUnlimited"]

    @staticmethod
    def RFreqLimited(freq):
        return com_lightstreamer_internal_RealMaxFrequency("RFreqLimited", 0, (freq,))
com_lightstreamer_internal_RealMaxFrequency.RFreqUnlimited = com_lightstreamer_internal_RealMaxFrequency("RFreqUnlimited", 1, ())
com_lightstreamer_internal_RealMaxFrequency._hx_class = com_lightstreamer_internal_RealMaxFrequency

class com_lightstreamer_internal_RealMaxBandwidth(Enum):
    __slots__ = ()
    _hx_class_name = "com.lightstreamer.internal.RealMaxBandwidth"
    _hx_constructs = ["BWLimited", "BWUnlimited", "BWUnmanaged"]

    @staticmethod
    def BWLimited(bw):
        return com_lightstreamer_internal_RealMaxBandwidth("BWLimited", 0, (bw,))
com_lightstreamer_internal_RealMaxBandwidth.BWUnlimited = com_lightstreamer_internal_RealMaxBandwidth("BWUnlimited", 1, ())
com_lightstreamer_internal_RealMaxBandwidth.BWUnmanaged = com_lightstreamer_internal_RealMaxBandwidth("BWUnmanaged", 2, ())
com_lightstreamer_internal_RealMaxBandwidth._hx_class = com_lightstreamer_internal_RealMaxBandwidth


class com_lightstreamer_internal_RealMaxBandwidthTools:
    _hx_class_name = "com.lightstreamer.internal.RealMaxBandwidthTools"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["toString", "eq"]

    @staticmethod
    def toString(bandwidth):
        if (bandwidth is None):
            return None
        else:
            tmp = bandwidth.index
            if (tmp == 0):
                return Std.string(bandwidth.params[0])
            elif (tmp == 1):
                return "unlimited"
            elif (tmp == 2):
                return "unmanaged"
            else:
                pass

    @staticmethod
    def eq(a,b):
        if (a is None):
            if (b is None):
                return True
            else:
                return False
        elif (b is None):
            return False
        else:
            return Type.enumEq(a,b)
com_lightstreamer_internal_RealMaxBandwidthTools._hx_class = com_lightstreamer_internal_RealMaxBandwidthTools


class com_lightstreamer_internal__Types_SubscriptionMode_Impl_:
    _hx_class_name = "com.lightstreamer.internal._Types.SubscriptionMode_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["Merge", "Distinct", "Command", "Raw", "fromString"]

    @staticmethod
    def fromString(mode):
        _hx_local_0 = len(mode)
        if (_hx_local_0 == 5):
            if (mode == "MERGE"):
                return "MERGE"
            else:
                raise com_lightstreamer_internal_IllegalArgumentException("The given value is not a valid subscription mode. Admitted values are MERGE, DISTINCT, RAW, COMMAND")
        elif (_hx_local_0 == 7):
            if (mode == "COMMAND"):
                return "COMMAND"
            else:
                raise com_lightstreamer_internal_IllegalArgumentException("The given value is not a valid subscription mode. Admitted values are MERGE, DISTINCT, RAW, COMMAND")
        elif (_hx_local_0 == 3):
            if (mode == "RAW"):
                return "RAW"
            else:
                raise com_lightstreamer_internal_IllegalArgumentException("The given value is not a valid subscription mode. Admitted values are MERGE, DISTINCT, RAW, COMMAND")
        elif (_hx_local_0 == 8):
            if (mode == "DISTINCT"):
                return "DISTINCT"
            else:
                raise com_lightstreamer_internal_IllegalArgumentException("The given value is not a valid subscription mode. Admitted values are MERGE, DISTINCT, RAW, COMMAND")
        else:
            raise com_lightstreamer_internal_IllegalArgumentException("The given value is not a valid subscription mode. Admitted values are MERGE, DISTINCT, RAW, COMMAND")
com_lightstreamer_internal__Types_SubscriptionMode_Impl_._hx_class = com_lightstreamer_internal__Types_SubscriptionMode_Impl_


class com_lightstreamer_internal__Types_Items_Impl_:
    _hx_class_name = "com.lightstreamer.internal._Types.Items_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["_new", "getPos", "allValidNames", "fromArray"]

    @staticmethod
    def _new(a):
        return a

    @staticmethod
    def getPos(this1,name):
        pos = python_internal_ArrayImpl.indexOf(this1,name,None)
        if (pos != -1):
            return (pos + 1)
        else:
            return -1

    @staticmethod
    def allValidNames(names):
        def _hx_local_1():
            def _hx_local_0(item):
                _this = EReg("^$| |^\\d+$","")
                _this.matchObj = python_lib_Re.search(_this.pattern,item)
                return (_this.matchObj is not None)
            return (not Lambda.exists(names,_hx_local_0))
        return _hx_local_1()

    @staticmethod
    def fromArray(array):
        if (array is None):
            return None
        elif (len(array) == 0):
            raise com_lightstreamer_internal_IllegalArgumentException("Item List is empty")
        elif (not com_lightstreamer_internal__Types_Items_Impl_.allValidNames(array)):
            raise com_lightstreamer_internal_IllegalArgumentException("Item List is invalid")
        else:
            return array
com_lightstreamer_internal__Types_Items_Impl_._hx_class = com_lightstreamer_internal__Types_Items_Impl_


class com_lightstreamer_internal__Types_Fields_Impl_:
    _hx_class_name = "com.lightstreamer.internal._Types.Fields_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["_new", "getPos", "hasKeyField", "hasCommandField", "fromArray"]

    @staticmethod
    def _new(a):
        return a

    @staticmethod
    def getPos(this1,name):
        pos = python_internal_ArrayImpl.indexOf(this1,name,None)
        if (pos != -1):
            return (pos + 1)
        else:
            return -1

    @staticmethod
    def hasKeyField(this1):
        return ("key" in this1)

    @staticmethod
    def hasCommandField(this1):
        return ("command" in this1)

    @staticmethod
    def fromArray(array):
        if (array is None):
            return None
        elif (len(array) == 0):
            raise com_lightstreamer_internal_IllegalArgumentException("Field List is empty")
        else:
            def _hx_local_0(field):
                _this = EReg("^$| ","")
                _this.matchObj = python_lib_Re.search(_this.pattern,field)
                return (_this.matchObj is not None)
            if Lambda.exists(array,_hx_local_0):
                raise com_lightstreamer_internal_IllegalArgumentException("Field List is invalid")
            else:
                return array
com_lightstreamer_internal__Types_Fields_Impl_._hx_class = com_lightstreamer_internal__Types_Fields_Impl_


class com_lightstreamer_internal__Types_Name_Impl_:
    _hx_class_name = "com.lightstreamer.internal._Types.Name_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["_new", "fromString"]

    @staticmethod
    def _new(name):
        return name

    @staticmethod
    def fromString(name):
        if (name is None):
            return None
        elif (name == ""):
            raise com_lightstreamer_internal_IllegalArgumentException("The value is empty")
        else:
            return name
com_lightstreamer_internal__Types_Name_Impl_._hx_class = com_lightstreamer_internal__Types_Name_Impl_


class com_lightstreamer_internal__Types_TriggerExpression_Impl_:
    _hx_class_name = "com.lightstreamer.internal._Types.TriggerExpression_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["_new", "fromString"]

    @staticmethod
    def _new(trigger):
        return trigger

    @staticmethod
    def fromString(trigger):
        if (trigger is None):
            return None
        else:
            return trigger
com_lightstreamer_internal__Types_TriggerExpression_Impl_._hx_class = com_lightstreamer_internal__Types_TriggerExpression_Impl_


class com_lightstreamer_internal__Types_NotificationFormat_Impl_:
    _hx_class_name = "com.lightstreamer.internal._Types.NotificationFormat_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["_new", "fromString"]

    @staticmethod
    def _new(format):
        return format

    @staticmethod
    def fromString(format):
        if (format is None):
            return None
        else:
            return format
com_lightstreamer_internal__Types_NotificationFormat_Impl_._hx_class = com_lightstreamer_internal__Types_NotificationFormat_Impl_


class com_lightstreamer_internal__Types_Types_Fields_:
    _hx_class_name = "com.lightstreamer.internal._Types.Types_Fields_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["realFrequencyAsString", "realFrequencyEquals"]

    @staticmethod
    def realFrequencyAsString(freq):
        if (freq is None):
            return "null"
        else:
            tmp = freq.index
            if (tmp == 0):
                return ("" + Std.string(freq.params[0]))
            elif (tmp == 1):
                return "unlimited"
            else:
                pass

    @staticmethod
    def realFrequencyEquals(a,b):
        if (a is None):
            if (b is None):
                return True
            else:
                return False
        elif (b is None):
            return False
        else:
            return Type.enumEq(a,b)
com_lightstreamer_internal__Types_Types_Fields_._hx_class = com_lightstreamer_internal__Types_Types_Fields_


class com_lightstreamer_internal_Url:
    _hx_class_name = "com.lightstreamer.internal.Url"
    _hx_is_interface = "False"
    __slots__ = ("_protocol", "_hostname", "_port", "_pathname")
    _hx_fields = ["_protocol", "_hostname", "_port", "_pathname"]
    _hx_methods = ["get_protocol", "set_protocol", "get_hostname", "set_hostname", "get_port", "set_port", "get_pathname", "set_pathname", "get_href", "toString", "extractPortStart"]
    _hx_statics = ["build", "completeControlLink"]

    def __init__(self,url,path = None):
        self._pathname = None
        self._port = None
        self._hostname = None
        self._protocol = None
        schemaEnd = url.find("://")
        if (schemaEnd != -1):
            self._protocol = (HxOverrides.stringOrNull(HxString.substring(url,0,schemaEnd)) + ":")
            url = HxString.substring(url,(schemaEnd + 3),None)
        else:
            self._protocol = ""
        pathStart = url.find("/")
        if (pathStart != -1):
            self._pathname = HxString.substring(url,pathStart,None)
            url = HxString.substring(url,0,pathStart)
        else:
            self._pathname = "/"
        portStart = self.extractPortStart(url)
        if (portStart != -1):
            self._port = HxString.substring(url,portStart,None)
            self._hostname = HxString.substring(url,0,(portStart - 1))
        else:
            self._port = ""
            self._hostname = url
        if (path is not None):
            self.set_pathname(path)

    def get_protocol(self):
        return self._protocol

    def set_protocol(self,newValue):
        if ((newValue != "") and (not newValue.endswith(":"))):
            newValue = (("null" if newValue is None else newValue) + ":")
        self._protocol = newValue
        return self._protocol

    def get_hostname(self):
        return self._hostname

    def set_hostname(self,newValue):
        self._hostname = newValue
        return self._hostname

    def get_port(self):
        return self._port

    def set_port(self,newValue):
        self._port = newValue
        return self._port

    def get_pathname(self):
        return self._pathname

    def set_pathname(self,newValue):
        if (not newValue.startswith("/")):
            newValue = ("/" + ("null" if newValue is None else newValue))
        self._pathname = newValue
        return self._pathname

    def get_href(self):
        url = self._hostname
        if (self._protocol != ""):
            url = ((HxOverrides.stringOrNull(self._protocol) + "//") + ("null" if url is None else url))
        if (self._port != ""):
            url = (("null" if url is None else url) + HxOverrides.stringOrNull(((":" + HxOverrides.stringOrNull(self._port)))))
        if (self.get_pathname() != ""):
            url = (("null" if url is None else url) + HxOverrides.stringOrNull(self._pathname))
        return url

    def toString(self):
        return self.get_href()

    def extractPortStart(self,address):
        portStarts = address.find(":")
        if (portStarts <= -1):
            return -1
        if (address.find("]") > -1):
            portStarts = address.find("]:")
            if (portStarts <= -1):
                return -1
            return (portStarts + 2)
        elif (portStarts != address.rfind(":", 0, len(address))):
            return -1
        else:
            return (portStarts + 1)

    @staticmethod
    def build(base,path):
        if (path is not None):
            baseEndsWithSlash = base.endswith("/")
            pathStartsWithSlash = path.startswith("/")
            if (not baseEndsWithSlash):
                if (not pathStartsWithSlash):
                    base = (("null" if base is None else base) + HxOverrides.stringOrNull((("/" + ("null" if path is None else path)))))
                else:
                    base = (("null" if base is None else base) + ("null" if path is None else path))
            elif (not pathStartsWithSlash):
                base = (("null" if base is None else base) + ("null" if path is None else path))
            else:
                base = (("null" if base is None else base) + HxOverrides.stringOrNull(HxString.substring(path,1,None)))
        return base

    @staticmethod
    def completeControlLink(clink,baseAddress):
        baseUrl = com_lightstreamer_internal_Url(baseAddress)
        clUrl = com_lightstreamer_internal_Url(clink)
        if (clUrl.get_protocol() == ""):
            clUrl.set_protocol(baseUrl.get_protocol())
        if (clUrl.get_port() == ""):
            clUrl.set_port(baseUrl.get_port())
        return clUrl.get_href()

com_lightstreamer_internal_Url._hx_class = com_lightstreamer_internal_Url


class com_lightstreamer_internal_WsClient(com_lightstreamer_internal_WsClientPy):
    _hx_class_name = "com.lightstreamer.internal.WsClient"
    _hx_is_interface = "False"
    __slots__ = ("onOpen", "onText", "onError")
    _hx_fields = ["onOpen", "onText", "onError"]
    _hx_methods = ["send", "dispose", "on_open", "on_text", "on_error"]
    _hx_statics = []
    _hx_interfaces = [com_lightstreamer_internal_IWsClient]
    _hx_super = com_lightstreamer_internal_WsClientPy


    def __init__(self,url,headers,proxy,sslContext,onOpen,onText,onError):
        self.onError = None
        self.onText = None
        self.onOpen = None
        super().__init__()
        if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.streamLogger.isDebugEnabled():
            com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.streamLogger.debug((((("WS connecting: " + ("null" if url is None else url)) + " headers(") + HxOverrides.stringOrNull((("null" if ((headers is None)) else headers.toString())))) + ")"))
        self.onOpen = onOpen
        self.onText = onText
        self.onError = onError
        self.connectAsync(url,com_lightstreamer_internal__Constants_Constants_Fields_.FULL_TLCP_VERSION,(None if ((headers is None)) else com_lightstreamer_internal__NativeTypes_NativeStringMap_Impl_._new(headers)),(com_lightstreamer_internal__ClientCommon_ClientCommon_Fields_.buildProxy(proxy) if ((proxy is not None)) else None),sslContext)

    def send(self,txt):
        if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.streamLogger.isDebugEnabled():
            com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.streamLogger.debug(("WS sending: " + ("null" if txt is None else txt)))
        self.sendAsync(txt)

    def dispose(self):
        if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.streamLogger.isDebugEnabled():
            com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.streamLogger.debug("WS disposing")
        super().dispose()

    def on_open(self,client):
        if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.streamLogger.isDebugEnabled():
            com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.streamLogger.debug("WS event: open")
        self.onOpen(self)

    def on_text(self,client,line):
        if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.streamLogger.isDebugEnabled():
            com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.streamLogger.debug((("WS event: text(" + ("null" if line is None else line)) + ")"))
        self.onText(self,line)

    def on_error(self,client,error):
        msg = str(error)
        if com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.streamLogger.isDebugEnabled():
            com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.streamLogger.debug((("WS event: error(" + ("null" if msg is None else msg)) + ")"),error)
        self.onError(self,msg)

com_lightstreamer_internal_WsClient._hx_class = com_lightstreamer_internal_WsClient


class com_lightstreamer_internal_patch__Diff_DiffPatch_Impl_:
    _hx_class_name = "com.lightstreamer.internal.patch._Diff.DiffPatch_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["_new", "apply"]

    @staticmethod
    def _new(patch):
        return patch

    @staticmethod
    def apply(this1,base):
        return com_lightstreamer_internal_patch_DiffDecoder(base,this1).decode()
com_lightstreamer_internal_patch__Diff_DiffPatch_Impl_._hx_class = com_lightstreamer_internal_patch__Diff_DiffPatch_Impl_


class com_lightstreamer_internal_patch_DiffDecoder:
    _hx_class_name = "com.lightstreamer.internal.patch.DiffDecoder"
    _hx_is_interface = "False"
    __slots__ = ("diff", "base", "diffPos", "basePos", "buf")
    _hx_fields = ["diff", "base", "diffPos", "basePos", "buf"]
    _hx_methods = ["decode", "applyCopy", "applyAdd", "applyDel", "decodeVarint", "appendToBuf", "charAt"]
    _hx_statics = ["VARINT_RADIX", "apply"]

    def __init__(self,base,diff):
        self.buf = StringBuf()
        self.basePos = 0
        self.diffPos = 0
        self.diff = diff
        self.base = base

    def decode(self):
        try:
            while (self.diffPos != len(self.diff)):
                self.applyCopy()
                if (self.diffPos == len(self.diff)):
                    break
                self.applyAdd()
                if (self.diffPos == len(self.diff)):
                    break
                self.applyDel()
            return self.buf.b.getvalue()
        except BaseException as _g:
            raise haxe_Exception("Bad TLCP-diff",haxe_Exception.caught(_g))

    def applyCopy(self):
        count = self.decodeVarint()
        if (count > 0):
            self.appendToBuf(self.base,self.basePos,count)
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.basePos
            _hx_local_0.basePos = (_hx_local_1 + count)
            _hx_local_0.basePos

    def applyAdd(self):
        count = self.decodeVarint()
        if (count > 0):
            self.appendToBuf(self.diff,self.diffPos,count)
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.diffPos
            _hx_local_0.diffPos = (_hx_local_1 + count)
            _hx_local_0.diffPos

    def applyDel(self):
        count = self.decodeVarint()
        if (count > 0):
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.basePos
            _hx_local_0.basePos = (_hx_local_1 + count)
            _hx_local_0.basePos

    def decodeVarint(self):
        n = 0
        while True:
            c = self.charAt(self.diff,self.diffPos)
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.diffPos
            _hx_local_0.diffPos = (_hx_local_1 + 1)
            _hx_local_0.diffPos
            if ((c >= 97) and ((c < 123))):
                return ((n * 26) + ((c - 97)))
            elif ((c >= 65) and ((c < 91))):
                n = ((n * 26) + ((c - 65)))
            else:
                raise haxe_Exception((("The code point " + Std.string(c)) + " is not in the range A-Z"))

    def appendToBuf(self,s,startIndex,count):
        if ((startIndex + count) <= len(s)):
            _this = self.buf
            s1 = (HxString.substr(s,startIndex,None) if ((count is None)) else HxString.substr(s,startIndex,count))
            _this.b.write(s1)
        else:
            raise haxe_Exception(((((("Index out of range: startIndex=" + Std.string(startIndex)) + " count=") + Std.string(count)) + " length=") + Std.string(len(s))))

    def charAt(self,s,pos):
        if (pos < len(s)):
            return HxString.charCodeAt(("" if (((pos < 0) or ((pos >= len(s))))) else s[pos]),0)
        else:
            raise haxe_Exception(((("Index out of range: pos=" + Std.string(pos)) + " length=") + Std.string(len(s))))

    @staticmethod
    def apply(base,diff):
        return com_lightstreamer_internal_patch_DiffDecoder(base,diff).decode()

com_lightstreamer_internal_patch_DiffDecoder._hx_class = com_lightstreamer_internal_patch_DiffDecoder


class com_lightstreamer_internal_patch__Json_Json_Impl_:
    _hx_class_name = "com.lightstreamer.internal.patch._Json.Json_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["_new", "apply", "toString"]

    @staticmethod
    def _new(_hx_str):
        return python_lib_Json.loads(_hx_str)

    @staticmethod
    def apply(this1,patch):
        return com_lightstreamer_internal_patch_JsonPatcher.apply_patch(this1,patch)

    @staticmethod
    def toString(this1):
        return python_lib_Json.dumps(this1, separators=(',', ':'))
com_lightstreamer_internal_patch__Json_Json_Impl_._hx_class = com_lightstreamer_internal_patch__Json_Json_Impl_


class com_lightstreamer_log_AbstractLogger:
    _hx_class_name = "com.lightstreamer.log.AbstractLogger"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_methods = ["warn", "trace", "isWarnEnabled", "isTraceEnabled", "isInfoEnabled", "isFatalEnabled", "isErrorEnabled", "isDebugEnabled", "info", "fatal", "error", "debug"]
    _hx_interfaces = [com_lightstreamer_log_Logger]

com_lightstreamer_log_AbstractLogger._hx_class = com_lightstreamer_log_AbstractLogger


class LSConsoleLogLevel:
    _hx_class_name = "LSConsoleLogLevel"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["TRACE", "DEBUG", "INFO", "WARN", "ERROR", "FATAL"]

    def __init__(self):
        pass
LSConsoleLogLevel._hx_class = LSConsoleLogLevel


class LSConsoleLoggerProvider:
    _hx_class_name = "LSConsoleLoggerProvider"
    _hx_is_interface = "False"
    __slots__ = ("level",)
    _hx_fields = ["level"]
    _hx_methods = ["getLogger"]
    _hx_interfaces = [com_lightstreamer_log_LoggerProvider]

    def __init__(self,level):
        self.level = level

    def getLogger(self,category):
        return com_lightstreamer_log__ConsoleLoggerProvider_ConsoleLogger(self.level,category)

LSConsoleLoggerProvider._hx_class = LSConsoleLoggerProvider


class com_lightstreamer_log__ConsoleLoggerProvider_ConsoleLogger(com_lightstreamer_log_AbstractLogger):
    _hx_class_name = "com.lightstreamer.log._ConsoleLoggerProvider.ConsoleLogger"
    _hx_is_interface = "False"
    __slots__ = ("level", "category", "traceEnabled", "debugEnabled", "infoEnabled", "warnEnabled", "errorEnabled", "fatalEnabled")
    _hx_fields = ["level", "category", "traceEnabled", "debugEnabled", "infoEnabled", "warnEnabled", "errorEnabled", "fatalEnabled"]
    _hx_methods = ["printLog", "format", "logFatal", "logError", "logWarn", "logInfo", "logDebug", "logTrace", "fatal", "error", "warn", "info", "debug", "trace", "isFatalEnabled", "isErrorEnabled", "isWarnEnabled", "isInfoEnabled", "isDebugEnabled", "isTraceEnabled"]
    _hx_statics = ["logger"]
    _hx_interfaces = []
    _hx_super = com_lightstreamer_log_AbstractLogger


    def __init__(self,level,category):
        self.level = level
        self.category = category
        self.traceEnabled = (level <= LSConsoleLogLevel.TRACE)
        self.debugEnabled = (level <= LSConsoleLogLevel.DEBUG)
        self.infoEnabled = (level <= LSConsoleLogLevel.INFO)
        self.warnEnabled = (level <= LSConsoleLogLevel.WARN)
        self.errorEnabled = (level <= LSConsoleLogLevel.ERROR)
        self.fatalEnabled = (level <= LSConsoleLogLevel.FATAL)

    def printLog(self,msg):
        python_Lib.printString((("" + Std.string(msg)) + HxOverrides.stringOrNull(python_Lib.lineEnd)))

    def format(self,level,line):
        pyTime = str(python_lib_datetime_Datetime.now())
        pyThread = python_lib_Threading.current_thread().name
        return ((((((((("" + ("null" if pyTime is None else pyTime)) + "|") + ("null" if level is None else level)) + "|") + HxOverrides.stringOrNull(self.category)) + "|") + ("null" if pyThread is None else pyThread)) + "|") + ("null" if line is None else line))

    def logFatal(self,msg):
        com_lightstreamer_log__ConsoleLoggerProvider_ConsoleLogger.logger.critical(msg)

    def logError(self,msg):
        com_lightstreamer_log__ConsoleLoggerProvider_ConsoleLogger.logger.error(msg)

    def logWarn(self,msg):
        com_lightstreamer_log__ConsoleLoggerProvider_ConsoleLogger.logger.warning(msg)

    def logInfo(self,msg):
        com_lightstreamer_log__ConsoleLoggerProvider_ConsoleLogger.logger.info(msg)

    def logDebug(self,msg):
        com_lightstreamer_log__ConsoleLoggerProvider_ConsoleLogger.logger.debug(msg)

    def logTrace(self,msg):
        com_lightstreamer_log__ConsoleLoggerProvider_ConsoleLogger.logger.debug(msg)

    def fatal(self,line,exception = None):
        if self.fatalEnabled:
            com_lightstreamer_log__ConsoleLoggerProvider_ConsoleLogger.logger.critical(self.format("FATAL",line))
            if (exception is not None):
                com_lightstreamer_log__ConsoleLoggerProvider_ConsoleLogger.logger.critical(haxe_Exception.caught(exception).details())

    def error(self,line,exception = None):
        if self.errorEnabled:
            com_lightstreamer_log__ConsoleLoggerProvider_ConsoleLogger.logger.error(self.format("ERROR",line))
            if (exception is not None):
                com_lightstreamer_log__ConsoleLoggerProvider_ConsoleLogger.logger.error(haxe_Exception.caught(exception).details())

    def warn(self,line,exception = None):
        if self.warnEnabled:
            com_lightstreamer_log__ConsoleLoggerProvider_ConsoleLogger.logger.warning(self.format("WARN ",line))
            if (exception is not None):
                com_lightstreamer_log__ConsoleLoggerProvider_ConsoleLogger.logger.warning(haxe_Exception.caught(exception).details())

    def info(self,line,exception = None):
        if self.infoEnabled:
            com_lightstreamer_log__ConsoleLoggerProvider_ConsoleLogger.logger.info(self.format("INFO ",line))
            if (exception is not None):
                com_lightstreamer_log__ConsoleLoggerProvider_ConsoleLogger.logger.info(haxe_Exception.caught(exception).details())

    def debug(self,line,exception = None):
        if self.debugEnabled:
            com_lightstreamer_log__ConsoleLoggerProvider_ConsoleLogger.logger.debug(self.format("DEBUG",line))
            if (exception is not None):
                com_lightstreamer_log__ConsoleLoggerProvider_ConsoleLogger.logger.debug(haxe_Exception.caught(exception).details())

    def trace(self,line,exception = None):
        if self.traceEnabled:
            com_lightstreamer_log__ConsoleLoggerProvider_ConsoleLogger.logger.debug(self.format("TRACE",line))
            if (exception is not None):
                com_lightstreamer_log__ConsoleLoggerProvider_ConsoleLogger.logger.debug(haxe_Exception.caught(exception).details())

    def isFatalEnabled(self):
        return self.fatalEnabled

    def isErrorEnabled(self):
        return self.errorEnabled

    def isWarnEnabled(self):
        return self.warnEnabled

    def isInfoEnabled(self):
        return self.infoEnabled

    def isDebugEnabled(self):
        return self.debugEnabled

    def isTraceEnabled(self):
        return self.traceEnabled

com_lightstreamer_log__ConsoleLoggerProvider_ConsoleLogger._hx_class = com_lightstreamer_log__ConsoleLoggerProvider_ConsoleLogger


class com_lightstreamer_log__LogManager_EmptyLogger(com_lightstreamer_log_AbstractLogger):
    _hx_class_name = "com.lightstreamer.log._LogManager.EmptyLogger"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["fatal", "error", "warn", "info", "debug", "trace", "isFatalEnabled", "isErrorEnabled", "isWarnEnabled", "isInfoEnabled", "isDebugEnabled", "isTraceEnabled"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = com_lightstreamer_log_AbstractLogger


    def __init__(self):
        pass

    def fatal(self,line,exception = None):
        pass

    def error(self,line,exception = None):
        pass

    def warn(self,line,exception = None):
        pass

    def info(self,line,exception = None):
        pass

    def debug(self,line,exception = None):
        pass

    def trace(self,line,exception = None):
        pass

    def isFatalEnabled(self):
        return False

    def isErrorEnabled(self):
        return False

    def isWarnEnabled(self):
        return False

    def isInfoEnabled(self):
        return False

    def isDebugEnabled(self):
        return False

    def isTraceEnabled(self):
        return False

com_lightstreamer_log__LogManager_EmptyLogger._hx_class = com_lightstreamer_log__LogManager_EmptyLogger


class com_lightstreamer_log_LogManager:
    _hx_class_name = "com.lightstreamer.log.LogManager"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["lock", "logInstances", "emptyLogger", "currentLoggerProvider", "getLogger", "setLoggerProvider", "newLogger"]
    currentLoggerProvider = None

    @staticmethod
    def getLogger(category):
        def _hx_local_1():
            def _hx_local_0():
                log = com_lightstreamer_log_LogManager.logInstances.h.get(category,None)
                if (log is None):
                    v = com_lightstreamer_log__LogManager_LoggerProxy((com_lightstreamer_log_LogManager.emptyLogger if ((com_lightstreamer_log_LogManager.currentLoggerProvider is None)) else com_lightstreamer_log_LogManager.currentLoggerProvider.getLogger(category)))
                    com_lightstreamer_log_LogManager.logInstances.h[category] = v
                    log = v
                return log
            return com_lightstreamer_log_LogManager.lock.synchronized(_hx_local_0)
        return _hx_local_1()

    @staticmethod
    def setLoggerProvider(provider):
        def _hx_local_0():
            com_lightstreamer_log_LogManager.currentLoggerProvider = provider
            _hx_map = com_lightstreamer_log_LogManager.logInstances
            _g_keys = _hx_map.keys()
            while _g_keys.hasNext():
                key = _g_keys.next()
                _hx_map.get(key).wrappedLogger = (com_lightstreamer_log_LogManager.emptyLogger if ((com_lightstreamer_log_LogManager.currentLoggerProvider is None)) else com_lightstreamer_log_LogManager.currentLoggerProvider.getLogger(key))
        com_lightstreamer_log_LogManager.lock.synchronized(_hx_local_0)

    @staticmethod
    def newLogger(category):
        if (com_lightstreamer_log_LogManager.currentLoggerProvider is None):
            return com_lightstreamer_log_LogManager.emptyLogger
        else:
            return com_lightstreamer_log_LogManager.currentLoggerProvider.getLogger(category)
com_lightstreamer_log_LogManager._hx_class = com_lightstreamer_log_LogManager


class com_lightstreamer_log__LogManager_LoggerProxy(com_lightstreamer_log_AbstractLogger):
    _hx_class_name = "com.lightstreamer.log._LogManager.LoggerProxy"
    _hx_is_interface = "False"
    __slots__ = ("wrappedLogger",)
    _hx_fields = ["wrappedLogger"]
    _hx_methods = ["fatal", "error", "warn", "info", "debug", "trace", "isFatalEnabled", "isErrorEnabled", "isWarnEnabled", "isInfoEnabled", "isDebugEnabled", "isTraceEnabled"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = com_lightstreamer_log_AbstractLogger


    def __init__(self,logger):
        self.wrappedLogger = logger

    def fatal(self,line,exception = None):
        self.wrappedLogger.fatal(line,exception)

    def error(self,line,exception = None):
        self.wrappedLogger.error(line,exception)

    def warn(self,line,exception = None):
        self.wrappedLogger.warn(line,exception)

    def info(self,line,exception = None):
        self.wrappedLogger.info(line,exception)

    def debug(self,line,exception = None):
        self.wrappedLogger.debug(line,exception)

    def trace(self,line,exception = None):
        self.wrappedLogger.trace(line,exception)

    def isFatalEnabled(self):
        return self.wrappedLogger.isFatalEnabled()

    def isErrorEnabled(self):
        return self.wrappedLogger.isErrorEnabled()

    def isWarnEnabled(self):
        return self.wrappedLogger.isWarnEnabled()

    def isInfoEnabled(self):
        return self.wrappedLogger.isInfoEnabled()

    def isDebugEnabled(self):
        return self.wrappedLogger.isDebugEnabled()

    def isTraceEnabled(self):
        return self.wrappedLogger.isTraceEnabled()

com_lightstreamer_log__LogManager_LoggerProxy._hx_class = com_lightstreamer_log__LogManager_LoggerProxy


class com_lightstreamer_log__LoggerMacros_LoggerMacros_Fields_:
    _hx_class_name = "com.lightstreamer.log._LoggerMacros.LoggerMacros_Fields_"
    _hx_is_interface = "False"
    __slots__ = ()
com_lightstreamer_log__LoggerMacros_LoggerMacros_Fields_._hx_class = com_lightstreamer_log__LoggerMacros_LoggerMacros_Fields_


class com_lightstreamer_log__LoggerTools_LoggerTools_Fields_:
    _hx_class_name = "com.lightstreamer.log._LoggerTools.LoggerTools_Fields_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["streamLogger", "protocolLogger", "internalLogger", "sessionLogger", "actionLogger", "reachabilityLogger", "subscriptionLogger", "messageLogger", "cookieLogger", "pageLogger"]
com_lightstreamer_log__LoggerTools_LoggerTools_Fields_._hx_class = com_lightstreamer_log__LoggerTools_LoggerTools_Fields_

class haxe_StackItem(Enum):
    __slots__ = ()
    _hx_class_name = "haxe.StackItem"
    _hx_constructs = ["CFunction", "Module", "FilePos", "Method", "LocalFunction"]

    @staticmethod
    def Module(m):
        return haxe_StackItem("Module", 1, (m,))

    @staticmethod
    def FilePos(s,file,line,column = None):
        return haxe_StackItem("FilePos", 2, (s,file,line,column))

    @staticmethod
    def Method(classname,method):
        return haxe_StackItem("Method", 3, (classname,method))

    @staticmethod
    def LocalFunction(v = None):
        return haxe_StackItem("LocalFunction", 4, (v,))
haxe_StackItem.CFunction = haxe_StackItem("CFunction", 0, ())
haxe_StackItem._hx_class = haxe_StackItem


class haxe__CallStack_CallStack_Impl_:
    _hx_class_name = "haxe._CallStack.CallStack_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["toString", "subtract", "equalItems", "itemToString"]

    @staticmethod
    def toString(stack):
        b = StringBuf()
        _g = 0
        _g1 = stack
        while (_g < len(_g1)):
            def _hx_local_1():
                nonlocal _g
                _hx_local_0 = _g
                _g = (_g + 1)
                return _hx_local_0
            s = python_internal_ArrayImpl._get(_g1, _hx_local_1())
            b.b.write("\nCalled from ")
            haxe__CallStack_CallStack_Impl_.itemToString(b,s)
        return b.b.getvalue()

    @staticmethod
    def subtract(this1,stack):
        startIndex = -1
        i = -1
        while True:
            i = (i + 1)
            tmp = i
            if (not ((tmp < len(this1)))):
                break
            _g = 0
            _g1 = len(stack)
            while (_g < _g1):
                j = _g
                _g = (_g + 1)
                if haxe__CallStack_CallStack_Impl_.equalItems((this1[i] if i >= 0 and i < len(this1) else None),python_internal_ArrayImpl._get(stack, j)):
                    if (startIndex < 0):
                        startIndex = i
                    i = (i + 1)
                    if (i >= len(this1)):
                        break
                else:
                    startIndex = -1
            if (not ((startIndex < 0))):
                break
        if (startIndex >= 0):
            return this1[0:startIndex]
        else:
            return this1

    @staticmethod
    def equalItems(item1,item2):
        if (item1 is None):
            if (item2 is None):
                return True
            else:
                return False
        else:
            tmp = item1.index
            if (tmp == 0):
                if (item2 is None):
                    return False
                elif (item2.index == 0):
                    return True
                else:
                    return False
            elif (tmp == 1):
                if (item2 is None):
                    return False
                elif (item2.index == 1):
                    return (item1.params[0] == item2.params[0])
                else:
                    return False
            elif (tmp == 2):
                if (item2 is None):
                    return False
                elif (item2.index == 2):
                    if (((item1.params[1] == item2.params[1]) and ((item1.params[2] == item2.params[2]))) and ((item1.params[3] == item2.params[3]))):
                        return haxe__CallStack_CallStack_Impl_.equalItems(item1.params[0],item2.params[0])
                    else:
                        return False
                else:
                    return False
            elif (tmp == 3):
                if (item2 is None):
                    return False
                elif (item2.index == 3):
                    if (item1.params[0] == item2.params[0]):
                        return (item1.params[1] == item2.params[1])
                    else:
                        return False
                else:
                    return False
            elif (tmp == 4):
                if (item2 is None):
                    return False
                elif (item2.index == 4):
                    return (item1.params[0] == item2.params[0])
                else:
                    return False
            else:
                pass

    @staticmethod
    def itemToString(b,s):
        tmp = s.index
        if (tmp == 0):
            b.b.write("a C function")
        elif (tmp == 1):
            b.b.write("module ")
            s1 = Std.string(s.params[0])
            b.b.write(s1)
        elif (tmp == 2):
            _g = s.params[0]
            _g1 = s.params[3]
            if (_g is not None):
                haxe__CallStack_CallStack_Impl_.itemToString(b,_g)
                b.b.write(" (")
            s1 = Std.string(s.params[1])
            b.b.write(s1)
            b.b.write(" line ")
            s1 = Std.string(s.params[2])
            b.b.write(s1)
            if (_g1 is not None):
                b.b.write(" column ")
                s1 = Std.string(_g1)
                b.b.write(s1)
            if (_g is not None):
                b.b.write(")")
        elif (tmp == 3):
            _g = s.params[0]
            s1 = Std.string(("<unknown>" if ((_g is None)) else _g))
            b.b.write(s1)
            b.b.write(".")
            s1 = Std.string(s.params[1])
            b.b.write(s1)
        elif (tmp == 4):
            b.b.write("local function #")
            s1 = Std.string(s.params[0])
            b.b.write(s1)
        else:
            pass
haxe__CallStack_CallStack_Impl_._hx_class = haxe__CallStack_CallStack_Impl_


class haxe_ds_ObjectMap:
    _hx_class_name = "haxe.ds.ObjectMap"
    _hx_is_interface = "False"
    __slots__ = ("h",)
    _hx_fields = ["h"]
    _hx_methods = ["set", "get", "keys", "keyValueIterator"]
    _hx_interfaces = [haxe_IMap]

    def __init__(self):
        self.h = dict()

    def set(self,key,value):
        self.h[key] = value

    def get(self,key):
        return self.h.get(key,None)

    def keys(self):
        return python_HaxeIterator(iter(self.h.keys()))

    def keyValueIterator(self):
        return haxe_iterators_MapKeyValueIterator(self)

haxe_ds_ObjectMap._hx_class = haxe_ds_ObjectMap


class sys_thread_Mutex:
    _hx_class_name = "sys.thread.Mutex"
    _hx_is_interface = "False"
    __slots__ = ("lock",)
    _hx_fields = ["lock"]

    def __init__(self):
        self.lock = python_lib_threading_RLock()

sys_thread_Mutex._hx_class = sys_thread_Mutex


class sys_thread_EventLoop:
    _hx_class_name = "sys.thread.EventLoop"
    _hx_is_interface = "False"
    __slots__ = ("mutex", "oneTimeEvents", "oneTimeEventsIdx", "waitLock", "promisedEventsCount", "regularEvents", "isMainThread")
    _hx_fields = ["mutex", "oneTimeEvents", "oneTimeEventsIdx", "waitLock", "promisedEventsCount", "regularEvents", "isMainThread"]
    _hx_methods = ["loop"]
    _hx_statics = ["CREATED"]

    def __init__(self):
        self.regularEvents = None
        self.promisedEventsCount = 0
        self.waitLock = sys_thread_Lock()
        self.oneTimeEventsIdx = 0
        self.oneTimeEvents = list()
        self.mutex = sys_thread_Mutex()
        self.isMainThread = (not sys_thread_EventLoop.CREATED)
        sys_thread_EventLoop.CREATED = True

    def loop(self):
        recycleRegular = []
        recycleOneTimers = []
        while True:
            now = python_lib_Time.time()
            eventsToRunIdx = 0
            nextEventAt = -1
            self.mutex.lock.acquire(True)
            while self.waitLock.semaphore.acquire(True,0.0):
                pass
            current = self.regularEvents
            while (current is not None):
                if (current.nextRunTime <= now):
                    tmp = eventsToRunIdx
                    eventsToRunIdx = (eventsToRunIdx + 1)
                    python_internal_ArrayImpl._set(recycleRegular, tmp, current)
                    current.nextRunTime = (current.nextRunTime + current.interval)
                    nextEventAt = -2
                elif ((nextEventAt == -1) or ((current.nextRunTime < nextEventAt))):
                    nextEventAt = current.nextRunTime
                current = current.next
            self.mutex.lock.release()
            _g = 0
            _g1 = eventsToRunIdx
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                if (not (recycleRegular[i] if i >= 0 and i < len(recycleRegular) else None).cancelled):
                    (recycleRegular[i] if i >= 0 and i < len(recycleRegular) else None).run()
                python_internal_ArrayImpl._set(recycleRegular, i, None)
            eventsToRunIdx = 0
            self.mutex.lock.acquire(True)
            _this = self.oneTimeEvents
            _g_current = 0
            while (_g_current < len(_this)):
                _g_value = (_this[_g_current] if _g_current >= 0 and _g_current < len(_this) else None)
                _g_key = _g_current
                _g_current = (_g_current + 1)
                if (_g_value is None):
                    break
                else:
                    tmp1 = eventsToRunIdx
                    eventsToRunIdx = (eventsToRunIdx + 1)
                    python_internal_ArrayImpl._set(recycleOneTimers, tmp1, _g_value)
                    python_internal_ArrayImpl._set(self.oneTimeEvents, _g_key, None)
            self.oneTimeEventsIdx = 0
            hasPromisedEvents = (self.promisedEventsCount > 0)
            self.mutex.lock.release()
            _g2 = 0
            _g3 = eventsToRunIdx
            while (_g2 < _g3):
                i1 = _g2
                _g2 = (_g2 + 1)
                (recycleOneTimers[i1] if i1 >= 0 and i1 < len(recycleOneTimers) else None)()
                python_internal_ArrayImpl._set(recycleOneTimers, i1, None)
            if self.isMainThread:
                next = haxe_MainLoop.tick()
                if haxe_MainLoop.hasEvents():
                    eventsToRunIdx = (eventsToRunIdx + 1)
                    if (nextEventAt > next):
                        nextEventAt = next
            if (eventsToRunIdx > 0):
                nextEventAt = -2
            r_nextEventAt = nextEventAt
            if (r_nextEventAt == -2):
                pass
            elif (r_nextEventAt == -1):
                if hasPromisedEvents:
                    self.waitLock.semaphore.acquire(True,None)
                else:
                    break
            else:
                timeout = (r_nextEventAt - python_lib_Time.time())
                _this1 = self.waitLock
                timeout1 = (0 if (python_lib_Math.isnan(0)) else (timeout if (python_lib_Math.isnan(timeout)) else max(0,timeout)))
                _this1.semaphore.acquire(True,timeout1)
    CREATED = None

sys_thread_EventLoop._hx_class = sys_thread_EventLoop


class sys_thread__Thread_HxThread:
    _hx_class_name = "sys.thread._Thread.HxThread"
    _hx_is_interface = "False"
    __slots__ = ("events", "nativeThread")
    _hx_fields = ["events", "nativeThread"]
    _hx_statics = ["threads", "threadsMutex", "mainThread", "current"]

    def __init__(self,t):
        self.events = None
        self.nativeThread = t
    threads = None
    threadsMutex = None
    mainThread = None

    @staticmethod
    def current():
        sys_thread__Thread_HxThread.threadsMutex.lock.acquire(True)
        ct = python_lib_Threading.current_thread()
        if (ct == python_lib_Threading.main_thread()):
            sys_thread__Thread_HxThread.threadsMutex.lock.release()
            return sys_thread__Thread_HxThread.mainThread
        if (not (ct in sys_thread__Thread_HxThread.threads.h)):
            sys_thread__Thread_HxThread.threads.set(ct,sys_thread__Thread_HxThread(ct))
        t = sys_thread__Thread_HxThread.threads.h.get(ct,None)
        sys_thread__Thread_HxThread.threadsMutex.lock.release()
        return t

sys_thread__Thread_HxThread._hx_class = sys_thread__Thread_HxThread


class haxe_EntryPoint:
    _hx_class_name = "haxe.EntryPoint"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["run"]

    @staticmethod
    def run():
        pass
haxe_EntryPoint._hx_class = haxe_EntryPoint


class haxe_MainEvent:
    _hx_class_name = "haxe.MainEvent"
    _hx_is_interface = "False"
    __slots__ = ("f", "prev", "next", "isBlocking", "nextRun", "priority")
    _hx_fields = ["f", "prev", "next", "isBlocking", "nextRun", "priority"]

    def __init__(self,f,p):
        self.next = None
        self.prev = None
        self.isBlocking = True
        self.f = f
        self.priority = p
        self.nextRun = Math.NEGATIVE_INFINITY

haxe_MainEvent._hx_class = haxe_MainEvent


class haxe_MainLoop:
    _hx_class_name = "haxe.MainLoop"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["pending", "hasEvents", "sortEvents", "tick"]
    pending = None

    @staticmethod
    def hasEvents():
        p = haxe_MainLoop.pending
        while (p is not None):
            if p.isBlocking:
                return True
            p = p.next
        return False

    @staticmethod
    def sortEvents():
        _hx_list = haxe_MainLoop.pending
        if (_hx_list is None):
            return
        insize = 1
        nmerges = None
        psize = 0
        qsize = 0
        p = None
        q = None
        e = None
        tail = None
        while True:
            p = _hx_list
            _hx_list = None
            tail = None
            nmerges = 0
            while (p is not None):
                nmerges = (nmerges + 1)
                q = p
                psize = 0
                _g = 0
                _g1 = insize
                while (_g < _g1):
                    _g = (_g + 1)
                    psize = (psize + 1)
                    q = q.next
                    if (q is None):
                        break
                qsize = insize
                while ((psize > 0) or (((qsize > 0) and ((q is not None))))):
                    if (psize == 0):
                        e = q
                        q = q.next
                        qsize = (qsize - 1)
                    elif (((qsize == 0) or ((q is None))) or (((p.priority > q.priority) or (((p.priority == q.priority) and ((p.nextRun <= q.nextRun))))))):
                        e = p
                        p = p.next
                        psize = (psize - 1)
                    else:
                        e = q
                        q = q.next
                        qsize = (qsize - 1)
                    if (tail is not None):
                        tail.next = e
                    else:
                        _hx_list = e
                    e.prev = tail
                    tail = e
                p = q
            tail.next = None
            if (nmerges <= 1):
                break
            insize = (insize * 2)
        _hx_list.prev = None
        haxe_MainLoop.pending = _hx_list

    @staticmethod
    def tick():
        haxe_MainLoop.sortEvents()
        e = haxe_MainLoop.pending
        now = python_lib_Timeit.default_timer()
        wait = 1e9
        while (e is not None):
            next = e.next
            wt = (e.nextRun - now)
            if (wt <= 0):
                wait = 0
                if (e.f is not None):
                    e.f()
            elif (wait > wt):
                wait = wt
            e = next
        return wait
haxe_MainLoop._hx_class = haxe_MainLoop


class haxe_NativeStackTrace:
    _hx_class_name = "haxe.NativeStackTrace"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["saveStack", "exceptionStack", "toHaxe"]

    @staticmethod
    def saveStack(exception):
        pass

    @staticmethod
    def exceptionStack():
        exc = python_lib_Sys.exc_info()
        if (exc[2] is not None):
            infos = python_lib_Traceback.extract_tb(exc[2])
            infos.reverse()
            return infos
        else:
            return []

    @staticmethod
    def toHaxe(native,skip = None):
        if (skip is None):
            skip = 0
        stack = []
        _g = 0
        _g1 = len(native)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            if (skip > i):
                continue
            elem = (native[i] if i >= 0 and i < len(native) else None)
            x = haxe_StackItem.FilePos(haxe_StackItem.Method(None,elem[2]),elem[0],elem[1])
            stack.append(x)
        return stack
haxe_NativeStackTrace._hx_class = haxe_NativeStackTrace


class haxe_ValueException(haxe_Exception):
    _hx_class_name = "haxe.ValueException"
    _hx_is_interface = "False"
    __slots__ = ("value",)
    _hx_fields = ["value"]
    _hx_methods = ["unwrap"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = haxe_Exception


    def __init__(self,value,previous = None,native = None):
        self.value = None
        super().__init__(("null" if ((value is None)) else Std.string(value)),previous,native)
        self.value = value
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0._hx___skipStack
        _hx_local_0._hx___skipStack = (_hx_local_1 + 1)
        _hx_local_1

    def unwrap(self):
        return self.value

haxe_ValueException._hx_class = haxe_ValueException


class haxe_ds_IntMap:
    _hx_class_name = "haxe.ds.IntMap"
    _hx_is_interface = "False"
    __slots__ = ("h",)
    _hx_fields = ["h"]
    _hx_methods = ["set", "get", "remove", "keys", "iterator", "keyValueIterator", "copy"]
    _hx_interfaces = [haxe_IMap]

    def __init__(self):
        self.h = dict()

    def set(self,key,value):
        self.h[key] = value

    def get(self,key):
        return self.h.get(key,None)

    def remove(self,key):
        if (not (key in self.h)):
            return False
        del self.h[key]
        return True

    def keys(self):
        return python_HaxeIterator(iter(self.h.keys()))

    def iterator(self):
        return python_HaxeIterator(iter(self.h.values()))

    def keyValueIterator(self):
        return haxe_iterators_MapKeyValueIterator(self)

    def copy(self):
        copied = haxe_ds_IntMap()
        key = self.keys()
        while key.hasNext():
            key1 = key.next()
            copied.set(key1,self.h.get(key1,None))
        return copied

haxe_ds_IntMap._hx_class = haxe_ds_IntMap


class haxe_ds_StringMap:
    _hx_class_name = "haxe.ds.StringMap"
    _hx_is_interface = "False"
    __slots__ = ("h",)
    _hx_fields = ["h"]
    _hx_methods = ["set", "get", "remove", "keys", "iterator", "keyValueIterator", "copy", "toString"]
    _hx_interfaces = [haxe_IMap]

    def __init__(self):
        self.h = dict()

    def set(self,key,value):
        self.h[key] = value

    def get(self,key):
        return self.h.get(key,None)

    def remove(self,key):
        has = (key in self.h)
        if has:
            del self.h[key]
        return has

    def keys(self):
        return python_HaxeIterator(iter(self.h.keys()))

    def iterator(self):
        return python_HaxeIterator(iter(self.h.values()))

    def keyValueIterator(self):
        return haxe_iterators_MapKeyValueIterator(self)

    def copy(self):
        copied = haxe_ds_StringMap()
        key = self.keys()
        while key.hasNext():
            key1 = key.next()
            value = self.h.get(key1,None)
            copied.h[key1] = value
        return copied

    def toString(self):
        s_b = python_lib_io_StringIO()
        s_b.write("[")
        it = self.keys()
        while it.hasNext():
            i = it.next()
            s_b.write(Std.string(i))
            s_b.write(" => ")
            s_b.write(Std.string(Std.string(self.h.get(i,None))))
            if it.hasNext():
                s_b.write(", ")
        s_b.write("]")
        return s_b.getvalue()

haxe_ds_StringMap._hx_class = haxe_ds_StringMap


class haxe_exceptions_PosException(haxe_Exception):
    _hx_class_name = "haxe.exceptions.PosException"
    _hx_is_interface = "False"
    __slots__ = ("posInfos",)
    _hx_fields = ["posInfos"]
    _hx_methods = ["toString"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = haxe_Exception


    def __init__(self,message,previous = None,pos = None):
        self.posInfos = None
        super().__init__(message,previous)
        if (pos is None):
            self.posInfos = _hx_AnonObject({'fileName': "(unknown)", 'lineNumber': 0, 'className': "(unknown)", 'methodName': "(unknown)"})
        else:
            self.posInfos = pos
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0._hx___skipStack
        _hx_local_0._hx___skipStack = (_hx_local_1 + 1)
        _hx_local_1

    def toString(self):
        return ((((((((("" + HxOverrides.stringOrNull(super().toString())) + " in ") + HxOverrides.stringOrNull(self.posInfos.className)) + ".") + HxOverrides.stringOrNull(self.posInfos.methodName)) + " at ") + HxOverrides.stringOrNull(self.posInfos.fileName)) + ":") + Std.string(self.posInfos.lineNumber))

haxe_exceptions_PosException._hx_class = haxe_exceptions_PosException


class haxe_exceptions_NotImplementedException(haxe_exceptions_PosException):
    _hx_class_name = "haxe.exceptions.NotImplementedException"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = haxe_exceptions_PosException


    def __init__(self,message = None,previous = None,pos = None):
        if (message is None):
            message = "Not implemented"
        super().__init__(message,previous,pos)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0._hx___skipStack
        _hx_local_0._hx___skipStack = (_hx_local_1 + 1)
        _hx_local_1
haxe_exceptions_NotImplementedException._hx_class = haxe_exceptions_NotImplementedException

class haxe_io_Error(Enum):
    __slots__ = ()
    _hx_class_name = "haxe.io.Error"
    _hx_constructs = ["Blocked", "Overflow", "OutsideBounds", "Custom"]

    @staticmethod
    def Custom(e):
        return haxe_io_Error("Custom", 3, (e,))
haxe_io_Error.Blocked = haxe_io_Error("Blocked", 0, ())
haxe_io_Error.Overflow = haxe_io_Error("Overflow", 1, ())
haxe_io_Error.OutsideBounds = haxe_io_Error("OutsideBounds", 2, ())
haxe_io_Error._hx_class = haxe_io_Error


class haxe_iterators_ArrayIterator:
    _hx_class_name = "haxe.iterators.ArrayIterator"
    _hx_is_interface = "False"
    __slots__ = ("array", "current")
    _hx_fields = ["array", "current"]
    _hx_methods = ["hasNext", "next"]

    def __init__(self,array):
        self.current = 0
        self.array = array

    def hasNext(self):
        return (self.current < len(self.array))

    def next(self):
        def _hx_local_3():
            def _hx_local_2():
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.current
                _hx_local_0.current = (_hx_local_1 + 1)
                return _hx_local_1
            return python_internal_ArrayImpl._get(self.array, _hx_local_2())
        return _hx_local_3()

haxe_iterators_ArrayIterator._hx_class = haxe_iterators_ArrayIterator


class haxe_iterators_ArrayKeyValueIterator:
    _hx_class_name = "haxe.iterators.ArrayKeyValueIterator"
    _hx_is_interface = "False"
    __slots__ = ("current", "array")
    _hx_fields = ["current", "array"]
    _hx_methods = ["hasNext", "next"]

    def __init__(self,array):
        self.current = 0
        self.array = array

    def hasNext(self):
        return (self.current < len(self.array))

    def next(self):
        def _hx_local_3():
            def _hx_local_2():
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.current
                _hx_local_0.current = (_hx_local_1 + 1)
                return _hx_local_1
            return _hx_AnonObject({'value': python_internal_ArrayImpl._get(self.array, self.current), 'key': _hx_local_2()})
        return _hx_local_3()

haxe_iterators_ArrayKeyValueIterator._hx_class = haxe_iterators_ArrayKeyValueIterator


class haxe_iterators_MapKeyValueIterator:
    _hx_class_name = "haxe.iterators.MapKeyValueIterator"
    _hx_is_interface = "False"
    __slots__ = ("map", "keys")
    _hx_fields = ["map", "keys"]
    _hx_methods = ["hasNext", "next"]

    def __init__(self,_hx_map):
        self.map = _hx_map
        self.keys = _hx_map.keys()

    def hasNext(self):
        return self.keys.hasNext()

    def next(self):
        key = self.keys.next()
        return _hx_AnonObject({'value': self.map.get(key), 'key': key})

haxe_iterators_MapKeyValueIterator._hx_class = haxe_iterators_MapKeyValueIterator


class haxe_macro_Error(haxe_Exception):
    _hx_class_name = "haxe.macro.Error"
    _hx_is_interface = "False"
    __slots__ = ("pos",)
    _hx_fields = ["pos"]
    _hx_methods = []
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = haxe_Exception


    def __init__(self,message,pos,previous = None):
        self.pos = None
        super().__init__(message,previous)
        self.pos = pos
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0._hx___skipStack
        _hx_local_0._hx___skipStack = (_hx_local_1 + 1)
        _hx_local_1

haxe_macro_Error._hx_class = haxe_macro_Error


class python_HaxeIterator:
    _hx_class_name = "python.HaxeIterator"
    _hx_is_interface = "False"
    __slots__ = ("it", "x", "has", "checked")
    _hx_fields = ["it", "x", "has", "checked"]
    _hx_methods = ["next", "hasNext"]

    def __init__(self,it):
        self.checked = False
        self.has = False
        self.x = None
        self.it = it

    def next(self):
        if (not self.checked):
            self.hasNext()
        self.checked = False
        return self.x

    def hasNext(self):
        if (not self.checked):
            try:
                self.x = self.it.__next__()
                self.has = True
            except BaseException as _g:
                None
                if Std.isOfType(haxe_Exception.caught(_g).unwrap(),StopIteration):
                    self.has = False
                    self.x = None
                else:
                    raise _g
            self.checked = True
        return self.has

python_HaxeIterator._hx_class = python_HaxeIterator


class python_internal_ArrayImpl:
    _hx_class_name = "python.internal.ArrayImpl"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["concat", "copy", "iterator", "keyValueIterator", "indexOf", "lastIndexOf", "join", "toString", "pop", "push", "unshift", "remove", "contains", "shift", "slice", "sort", "splice", "map", "filter", "insert", "reverse", "_get", "_set"]

    @staticmethod
    def concat(a1,a2):
        return (a1 + a2)

    @staticmethod
    def copy(x):
        return list(x)

    @staticmethod
    def iterator(x):
        return python_HaxeIterator(x.__iter__())

    @staticmethod
    def keyValueIterator(x):
        return haxe_iterators_ArrayKeyValueIterator(x)

    @staticmethod
    def indexOf(a,x,fromIndex = None):
        _hx_len = len(a)
        l = (0 if ((fromIndex is None)) else ((_hx_len + fromIndex) if ((fromIndex < 0)) else fromIndex))
        if (l < 0):
            l = 0
        _g = l
        while (_g < _hx_len):
            i = _g
            _g = (_g + 1)
            if HxOverrides.eq(a[i],x):
                return i
        return -1

    @staticmethod
    def lastIndexOf(a,x,fromIndex = None):
        _hx_len = len(a)
        l = (_hx_len if ((fromIndex is None)) else (((_hx_len + fromIndex) + 1) if ((fromIndex < 0)) else (fromIndex + 1)))
        if (l > _hx_len):
            l = _hx_len
        while True:
            l = (l - 1)
            tmp = l
            if (not ((tmp > -1))):
                break
            if HxOverrides.eq(a[l],x):
                return l
        return -1

    @staticmethod
    def join(x,sep):
        return sep.join([python_Boot.toString1(x1,'') for x1 in x])

    @staticmethod
    def toString(x):
        return (("[" + HxOverrides.stringOrNull(",".join([python_Boot.toString1(x1,'') for x1 in x]))) + "]")

    @staticmethod
    def pop(x):
        if (len(x) == 0):
            return None
        else:
            return x.pop()

    @staticmethod
    def push(x,e):
        x.append(e)
        return len(x)

    @staticmethod
    def unshift(x,e):
        x.insert(0, e)

    @staticmethod
    def remove(x,e):
        try:
            x.remove(e)
            return True
        except BaseException as _g:
            None
            return False

    @staticmethod
    def contains(x,e):
        return (e in x)

    @staticmethod
    def shift(x):
        if (len(x) == 0):
            return None
        return x.pop(0)

    @staticmethod
    def slice(x,pos,end = None):
        return x[pos:end]

    @staticmethod
    def sort(x,f):
        x.sort(key= python_lib_Functools.cmp_to_key(f))

    @staticmethod
    def splice(x,pos,_hx_len):
        if (pos < 0):
            pos = (len(x) + pos)
        if (pos < 0):
            pos = 0
        res = x[pos:(pos + _hx_len)]
        del x[pos:(pos + _hx_len)]
        return res

    @staticmethod
    def map(x,f):
        return list(map(f,x))

    @staticmethod
    def filter(x,f):
        return list(filter(f,x))

    @staticmethod
    def insert(a,pos,x):
        a.insert(pos, x)

    @staticmethod
    def reverse(a):
        a.reverse()

    @staticmethod
    def _get(x,idx):
        if ((idx > -1) and ((idx < len(x)))):
            return x[idx]
        else:
            return None

    @staticmethod
    def _set(x,idx,v):
        l = len(x)
        while (l < idx):
            x.append(None)
            l = (l + 1)
        if (l == idx):
            x.append(v)
        else:
            x[idx] = v
        return v
python_internal_ArrayImpl._hx_class = python_internal_ArrayImpl


class HxOverrides:
    _hx_class_name = "HxOverrides"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["iterator", "eq", "stringOrNull", "mapKwArgs"]

    @staticmethod
    def iterator(x):
        if isinstance(x,list):
            return haxe_iterators_ArrayIterator(x)
        return x.iterator()

    @staticmethod
    def eq(a,b):
        if (isinstance(a,list) or isinstance(b,list)):
            return a is b
        return (a == b)

    @staticmethod
    def stringOrNull(s):
        if (s is None):
            return "null"
        else:
            return s

    @staticmethod
    def mapKwArgs(a,v):
        a1 = _hx_AnonObject(python_Lib.anonToDict(a))
        k = python_HaxeIterator(iter(v.keys()))
        while k.hasNext():
            k1 = k.next()
            val = v.get(k1)
            if a1._hx_hasattr(k1):
                x = getattr(a1,k1)
                setattr(a1,val,x)
                delattr(a1,k1)
        return a1
HxOverrides._hx_class = HxOverrides


class python_internal_MethodClosure:
    _hx_class_name = "python.internal.MethodClosure"
    _hx_is_interface = "False"
    __slots__ = ("obj", "func")
    _hx_fields = ["obj", "func"]
    _hx_methods = ["__call__"]

    def __init__(self,obj,func):
        self.obj = obj
        self.func = func

    def __call__(self,*args):
        return self.func(self.obj,*args)

python_internal_MethodClosure._hx_class = python_internal_MethodClosure


class sys_thread__EventLoop_RegularEvent:
    _hx_class_name = "sys.thread._EventLoop.RegularEvent"
    _hx_is_interface = "False"
    __slots__ = ("nextRunTime", "interval", "run", "next", "cancelled")
    _hx_fields = ["nextRunTime", "interval", "run", "next", "cancelled"]

    def __init__(self,run,nextRunTime,interval):
        self.next = None
        self.cancelled = False
        self.run = run
        self.nextRunTime = nextRunTime
        self.interval = interval

sys_thread__EventLoop_RegularEvent._hx_class = sys_thread__EventLoop_RegularEvent


class sys_thread_Lock:
    _hx_class_name = "sys.thread.Lock"
    _hx_is_interface = "False"
    __slots__ = ("semaphore",)
    _hx_fields = ["semaphore"]

    def __init__(self):
        self.semaphore = python_lib_threading_Semaphore(0)

sys_thread_Lock._hx_class = sys_thread_Lock


class sys_thread_NoEventLoopException(haxe_Exception):
    _hx_class_name = "sys.thread.NoEventLoopException"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = haxe_Exception


    def __init__(self,msg = None,previous = None):
        if (msg is None):
            msg = "Event loop is not available. Refer to sys.thread.Thread.runWithEventLoop."
        super().__init__(msg,previous)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0._hx___skipStack
        _hx_local_0._hx___skipStack = (_hx_local_1 + 1)
        _hx_local_1
sys_thread_NoEventLoopException._hx_class = sys_thread_NoEventLoopException


class sys_thread__Thread_Thread_Impl_:
    _hx_class_name = "sys.thread._Thread.Thread_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["processEvents"]

    @staticmethod
    def processEvents():
        sys_thread__Thread_HxThread.current().events.loop()
sys_thread__Thread_Thread_Impl_._hx_class = sys_thread__Thread_Thread_Impl_

Math.NEGATIVE_INFINITY = float("-inf")
Math.POSITIVE_INFINITY = float("inf")
Math.NaN = float("nan")
Math.PI = python_lib_Math.pi
sys_thread__Thread_HxThread.threads = haxe_ds_ObjectMap()
sys_thread__Thread_HxThread.threadsMutex = sys_thread_Mutex()
sys_thread__Thread_HxThread.mainThread = sys_thread__Thread_HxThread(python_lib_Threading.current_thread())
sys_thread__Thread_HxThread.mainThread.events = sys_thread_EventLoop()

com_lightstreamer_client__ConnectionDetails_ConnectionDetails_Fields_.DEFAULT_SERVER = None
com_lightstreamer_internal__Constants_Constants_Fields_.TLCP_VERSION = "TLCP-2.5.0"
com_lightstreamer_internal__Constants_Constants_Fields_.FULL_TLCP_VERSION = (HxOverrides.stringOrNull(com_lightstreamer_internal__Constants_Constants_Fields_.TLCP_VERSION) + ".lightstreamer.com")
com_lightstreamer_internal__Constants_Constants_Fields_.LS_LIB_VERSION = (("2.2.0" + " build ") + "20241029")
com_lightstreamer_internal__Constants_Constants_Fields_.LS_CID = "v Wntytg4pkpW37AM3M4hwLri8M4OB72hFb"
com_lightstreamer_internal__Constants_Constants_Fields_.LS_LIB_NAME = "python_client"
com_lightstreamer_internal__Constants_Constants_Fields_.LS_CREATE_REALM = ""
LSLightstreamerClient.LIB_NAME = com_lightstreamer_internal__Constants_Constants_Fields_.LS_LIB_NAME
LSLightstreamerClient.LIB_VERSION = com_lightstreamer_internal__Constants_Constants_Fields_.LS_LIB_VERSION
com_lightstreamer_client__Proxy_ProxyType_Impl_.HTTP = "HTTP"
com_lightstreamer_client__Proxy_ProxyType_Impl_.SOCKS4 = "SOCKS4"
com_lightstreamer_client__Proxy_ProxyType_Impl_.SOCKS5 = "SOCKS5"
com_lightstreamer_client_internal_ClientMachine.frz_globalPageLifecycle = com_lightstreamer_internal_PageLifecycle.newLoggingInstance()
com_lightstreamer_client_internal_Request.EOL_LEN = com_lightstreamer_client_internal_Request.lengthOfBytes("\r\n")
com_lightstreamer_client_internal_update__ItemUpdateBase_ItemUpdateBase_Fields_.NO_FIELDS = "The Subscription was initiated using a Field Schema: the field names are not available"
com_lightstreamer_client_internal_update__ItemUpdateBase_ItemUpdateBase_Fields_.POS_OUT_BOUNDS = "The field position is out of bounds"
com_lightstreamer_client_internal_update__ItemUpdateBase_ItemUpdateBase_Fields_.UNKNOWN_FIELD_NAME = "The field name is unknown"
com_lightstreamer_internal_Globals.instance = com_lightstreamer_internal_Globals()
python_Boot.keywords = set(["and", "del", "from", "not", "with", "as", "elif", "global", "or", "yield", "assert", "else", "if", "pass", "None", "break", "except", "import", "raise", "True", "class", "exec", "in", "return", "False", "continue", "finally", "is", "try", "def", "for", "lambda", "while"])
python_Boot.prefixLength = len("_hx_")
python_Lib.lineEnd = ("\r\n" if ((Sys.systemName() == "Windows")) else "\n")
com_lightstreamer_internal__Threads_Threads_Fields_.userThread = com_lightstreamer_internal__Threads_Threads_Fields_.createExecutor()
com_lightstreamer_internal__Threads_Threads_Fields_.sessionThread = com_lightstreamer_internal__Threads_Threads_Fields_.createExecutor()
com_lightstreamer_internal__Types_Millis_Impl_.ZERO = 0
com_lightstreamer_internal__Types_TransportSelection_Impl_.WS = "WS"
com_lightstreamer_internal__Types_TransportSelection_Impl_.WS_STREAMING = "WS-STREAMING"
com_lightstreamer_internal__Types_TransportSelection_Impl_.WS_POLLING = "WS-POLLING"
com_lightstreamer_internal__Types_TransportSelection_Impl_.HTTP = "HTTP"
com_lightstreamer_internal__Types_TransportSelection_Impl_.HTTP_STREAMING = "HTTP-STREAMING"
com_lightstreamer_internal__Types_TransportSelection_Impl_.HTTP_POLLING = "HTTP-POLLING"
com_lightstreamer_internal__Types_SubscriptionMode_Impl_.Merge = "MERGE"
com_lightstreamer_internal__Types_SubscriptionMode_Impl_.Distinct = "DISTINCT"
com_lightstreamer_internal__Types_SubscriptionMode_Impl_.Command = "COMMAND"
com_lightstreamer_internal__Types_SubscriptionMode_Impl_.Raw = "RAW"
com_lightstreamer_internal_patch_DiffDecoder.VARINT_RADIX = 26
LSConsoleLogLevel.TRACE = 0
LSConsoleLogLevel.DEBUG = 10
LSConsoleLogLevel.INFO = 20
LSConsoleLogLevel.WARN = 30
LSConsoleLogLevel.ERROR = 40
LSConsoleLogLevel.FATAL = 50
com_lightstreamer_log__ConsoleLoggerProvider_ConsoleLogger.logger = com_lightstreamer_internal_Logging.getLogger("lightstreamer")
com_lightstreamer_log_LogManager.lock = com_lightstreamer_internal_RLock()
com_lightstreamer_log_LogManager.logInstances = haxe_ds_StringMap()
com_lightstreamer_log_LogManager.emptyLogger = com_lightstreamer_log__LogManager_EmptyLogger()
com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.streamLogger = com_lightstreamer_log_LogManager.getLogger("lightstreamer.stream")
com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.protocolLogger = com_lightstreamer_log_LogManager.getLogger("lightstreamer.protocol")
com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.internalLogger = com_lightstreamer_log_LogManager.getLogger("lightstreamer.internal")
com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.sessionLogger = com_lightstreamer_log_LogManager.getLogger("lightstreamer.session")
com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.actionLogger = com_lightstreamer_log_LogManager.getLogger("lightstreamer.actions")
com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.reachabilityLogger = com_lightstreamer_log_LogManager.getLogger("lightstreamer.reachability")
com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.subscriptionLogger = com_lightstreamer_log_LogManager.getLogger("lightstreamer.subscriptions")
com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.messageLogger = com_lightstreamer_log_LogManager.getLogger("lightstreamer.messages")
com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.cookieLogger = com_lightstreamer_log_LogManager.getLogger("lightstreamer.cookies")
com_lightstreamer_log__LoggerTools_LoggerTools_Fields_.pageLogger = com_lightstreamer_log_LogManager.getLogger("lightstreamer.page")