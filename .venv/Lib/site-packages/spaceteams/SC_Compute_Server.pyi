from __future__ import annotations
import datetime
import numpy
import typing
__all__ = ['BaseFrame_Impl', 'CanTransmit', 'CaptureImage', 'CaptureImageProperties', 'CapturedImage', 'CartesianState', 'Entity', 'EntityConfig', 'EntityRef_Unresolved', 'Frame', 'FramedAngAcc', 'FramedAngVel', 'FramedLoc', 'FramedLocVel', 'FramedLocVelAcc', 'FramedRot', 'FramedVector', 'GetSimEntity', 'GetSimState', 'GetState', 'GetStopReason', 'GetThisSystem', 'GetWallTime_SimStarted', 'KeplerianState', 'LagrangePropagation', 'LambertBattin', 'LambertBattinResults', 'MandateSimStateChange', 'MandateSimStop', 'OnImageReceived', 'OnScreenAlert', 'OnScreenLogMessage', 'ParamMap', 'PlanetUtils', 'PropagationType', 'RequestSimStateChange', 'SetState', 'Severity', 'SimConfig', 'SimConfig_LoadFromFile', 'SimConfig_SaveToFile', 'SimGlobals_AddEntity', 'SimGlobals_AddEntityFromTemplate', 'SimGlobals_AddEventListener', 'SimGlobals_DeleteEntity', 'SimGlobals_DispatchEvent', 'SimGlobals_GetBaseFrame', 'SimGlobals_GetGlobalFrame', 'SimGlobals_SimClock_Freeze', 'SimGlobals_SimClock_GetTimeNow', 'SimGlobals_SimClock_GetTimescale', 'SimGlobals_SimClock_ResetTo', 'SimGlobals_SimClock_SetTimescale', 'SimGlobals_SimClock_UnFreeze', 'SimState', 'State', 'SurfaceMove', 'SystemConfig', 'TaskflowConfig', 'VarType', 'calcTime', 'connect_to_sim', 'constant', 'get_entities', 'get_nametag', 'leave_sim', 'logger_error', 'logger_fatal', 'logger_info', 'logger_warn', 'standalone_sim', 'stop_sim', 'timestamp']
class BaseFrame_Impl(Frame):
    pass
class CaptureImageProperties:
    CaptureID: int
    EV: float
    FOV: float
    ResolutionX: int
    ResolutionY: int
    def __init__(self) -> None:
        ...
class CapturedImage:
    PixelsB: list[int]
    PixelsG: list[int]
    PixelsR: list[int]
    properties: CaptureImageProperties
    timestamp: datetime.timedelta
    def __init__(self) -> None:
        ...
class CartesianState:
    def R(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def V(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def __init__(self, R_km: numpy.ndarray[numpy.float64[3, 1]], V_km_s: numpy.ndarray[numpy.float64[3, 1]], mu_km3_s2: float) -> None:
        ...
    def __repr__(self) -> str:
        ...
    def mu(self) -> ...:
        ...
class Entity(ParamMap):
    def AddDynamicsParamsIfMissing(self) -> None:
        """
        pbdoc(Adds the remainder of the dynamics params to this Entity if they don't exist.
        """
    def AddStateParamsIfMissing(self) -> None:
        """
        Adds the Location, Velocity, Rotation, AngVelocity, etc params to this Entity if they don't exist.
        """
    def GetBodyCenteredFrame(self) -> Frame:
        """
        Get the frame centered on this entity, with axes aligned to the resident (parent) frame of the entity.
        """
    def GetBodyFixedFrame(self) -> Frame:
        """
        Get the body-fixed frame of this entity.
        """
    def GetPropagationType(self) -> PropagationType:
        ...
    def __init__(self) -> None:
        ...
    def addAngVelocityOffset(self, offset: numpy.ndarray[numpy.float64[3, 1]], fromFrame: Frame = ...) -> None:
        """
        Add Entity Angular Velocity Offset (rad/sec, right handed coordinates).
        			Interim solution for modular propagators before we have PhysicalEffects.
        """
    def addImpulse(self, key: str, impulse: numpy.ndarray[numpy.float64[3, 1]], fromFrame: Frame = ...) -> None:
        """
        Add named Entity Impulse (Newton-seconds, right handed coordinates). 
        			Interim solution for modular propagators before we have PhysicalEffects.
        """
    def addLocationOffset(self, offset: numpy.ndarray[numpy.float64[3, 1]], fromFrame: Frame = ...) -> None:
        """
        Add Entity Location Offset (meters, right handed coordinates).
        			Interim solution for modular propagators before we have PhysicalEffects.
        """
    def addVelocityOffset(self, offset: numpy.ndarray[numpy.float64[3, 1]], fromFrame: Frame = ...) -> None:
        """
        Add Entity Velocity Offset (meters/sec, right handed coordinates).
        			Interim solution for modular propagators before we have PhysicalEffects.
        """
    def getAcceleration(self) -> FramedLocVelAcc:
        """
        Get time-extrapolated acceleration of this entity (meters/sec ^ 2, right handed coordinates)
        """
    def getAngAcceleration(self) -> FramedAngAcc:
        """
        Get time-extrapolated angular acceleration of this entity (rad/sec^2, right handed coordinates)
        """
    def getAngVelocity(self) -> FramedAngVel:
        """
        Get time-extrapolated angular velocity of this entity (rad/sec, right handed coordinates) 
        			The vector direction is the axis of rotation, and the magnitude of the vector is the speed of the
        			 right-handed rotation around that axis
        """
    def getForce(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        """
        Get the force applied to this entity (N)
        """
    def getId(self) -> ...:
        """
        Returns the id of the Entity
        """
    def getId_str(self) -> str:
        """
        Returns the id of the Entity as string type
        """
    @typing.overload
    def getImpulses(self) -> list[numpy.ndarray[numpy.float64[3, 1]]]:
        """
        Get the impulses applied to this entity (N*s)
        """
    @typing.overload
    def getImpulses(self, inFrame: Frame = ...) -> list[numpy.ndarray[numpy.float64[3, 1]]]:
        """
        Get Entity Impulses (Newton-seconds, right handed coordinates). 
        			Interim solution for modular propagators before we have PhysicalEffects. 
        			Consumes the impulses!
        """
    def getInertia(self, inFrame: Frame = ...) -> numpy.ndarray[numpy.float64[3, 3]]:
        """
        Get the inertia tensor of this entity (kg*m^2)
        """
    def getLocation(self) -> FramedLoc:
        """
        Get time-extrapolated location of this entity (meters, right handed coordinates)
        """
    def getMass(self) -> float:
        """
        Get the mass of this entity (kg)
        """
    def getName(self) -> str:
        """
        Returns the name of the Entity
        """
    def getRV(self) -> FramedLocVel:
        """
        Get time-extrapolated location and velocity of this entity (meters, meters/second, right handed coordinates).
        """
    def getRVA(self) -> FramedLocVelAcc:
        """
        Get time-extrapolated location, velocity, and acceleration of this entity (meters, meters/second, meters/second^2, right handed coordinates).
        """
    def getResidentFrame(self) -> Frame:
        """
        Get the frame in which this entity’s state parameter are defined.
        """
    def getResidentFrameBody(self) -> Entity_Base:
        """
        Get the entity whose body-fixed frame is used as the frame in which this Entity's state parameters are defined.
        """
    def getRotation(self) -> FramedRot:
        """
        Get the orientation of this entity's body frame (right handed coordinates).
        """
    def getTorque(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        """
        Get the torque applied to this entity (N*m)
        """
    def getVelocity(self) -> FramedLocVel:
        """
        Get the orientation of this entity’s body frame in Quat (right handed coordinates, wxyz)
        """
    def setAcceleration(self, acc: numpy.ndarray[numpy.float64[3, 1]], fromFrame: Frame = ...) -> None:
        """
        Get time-extrapolated acceleration of this entity (meters/sec ^ 2, right handed coordinates)
        """
    def setAngVelocity(self, angvel: numpy.ndarray[numpy.float64[3, 1]], fromFrame: Frame = ...) -> None:
        """
        Set time-extrapolated angular velocity of this entity (rad/sec, right handed coordinates) 
        			The vector direction is the axis of rotation, and the magnitude of the vector is the speed of the right-handed 
        			rotation around that axis
        """
    def setForce(self, force: numpy.ndarray[numpy.float64[3, 1]], fromFrame: Frame = ...) -> None:
        """
        Set Entity Force (Newtons, right handed coordinates).
        			Interim solution for modular propagators before we have PhysicalEffects.
        """
    def setLocation(self, loc: numpy.ndarray[numpy.float64[3, 1]], fromFrame: Frame = ...) -> None:
        """
        Set entity location (meters, right handed coordinates)
        """
    def setResidentFrame(self, frame: Frame) -> None:
        """
        Set the frame in which this Entity's state parameters are defined, and transform state. parameters to line up with the existing state.
        """
    def setRotation_DCM(self, rot: numpy.ndarray[numpy.float64[3, 3]], fromFrame: Frame = ...) -> None:
        """
        Set entity rotation (passiveDCM, right hand coordinate)
        """
    @typing.overload
    def setRotation_Quat(self, rot_quat_xyzw: numpy.ndarray[numpy.float64[4, 1]], fromFrame: Frame = ...) -> None:
        """
        Set entity rotation (passive quaternion, right hand coordinate). 
        			Takes numpy array of (x,y,z,w).
        """
    @typing.overload
    def setRotation_Quat(self, rot_quat_xyzw: tuple, fromFrame: Frame = ...) -> None:
        """
        Set entity rotation (passive quaternion, right hand coordinate).
        			Takes list of floats (x,y,z,w).
        """
    def setTorque(self, torque: numpy.ndarray[numpy.float64[3, 1]], fromFrame: Frame = ...) -> None:
        """
        Set Entity Torque (Newton-meters, right handed coordinates).
        			Interim solution for modular propagators before we have PhysicalEffects.
        """
    def setVelocity(self, vel: numpy.ndarray[numpy.float64[3, 1]], fromFrame: Frame = ...) -> None:
        """
        Set the velocity of this entity (meters/sec, right handed coordinates)
        """
class EntityConfig(ParamMap):
    @staticmethod
    def LoadFromFile(filepath: str) -> EntityConfig:
        """
        Read a EntityConfig from a properly formatted JSON file. Has good logging code for feedback about invalid syntax.
        """
    def SaveToFile(self, filepath: str) -> None:
        """
        Write this EntityConfig to a JSON file.
        """
    def __init__(self) -> None:
        ...
    def getName(self) -> str:
        """
        Get the name of this EntityConfig
        """
class EntityRef_Unresolved:
    __hash__: typing.ClassVar[None] = None
    def __eq__(self, other: EntityRef_Unresolved) -> bool:
        ...
    def __init__(self, entity_name: str) -> None:
        ...
    def __ne__(self, other: EntityRef_Unresolved) -> bool:
        ...
    def __repr__(self) -> str:
        ...
class Frame:
    pass
class FramedAngAcc:
    def WRT(self, inFrame: Frame) -> FramedVector:
        """
        Redefine the angular acceleration state with respect to a specified frame. 
        			Redefining the angular acceleration as such applies more 
        			than just rotation of the vector quantity to the new coordinate basis.
        """
    def WRT_ExprIn(self, inFrame: Frame) -> numpy.ndarray[numpy.float64[3, 1]]:
        """
        Redefine the angular acceleration state with respect to a specified frame. 
        			Redefining the angular acceleration as such applies more 
        			than just rotation of the vector quantity to the new coordinate basis.
        			Also expresses the vector in the same frame (coordinate basis).
        """
class FramedAngVel:
    def WRT(self, inFrame: Frame) -> FramedVector:
        """
        Redefine the angular velocity state with respect to a specified frame. 
        			Redefining the angular velocity as such applies more 
        			than just rotation of the vector quantity to the new coordinate basis.
        """
    def WRT_ExprIn(self, inFrame: Frame) -> numpy.ndarray[numpy.float64[3, 1]]:
        """
        Redefine the angular velocity state with respect to a specified frame. 
        			Redefining the angular velocity as such applies more 
        			than just rotation of the vector quantity to the new coordinate basis.
        			Also expresses the vector in the same frame (coordinate basis).
        """
class FramedLoc:
    def WRT(self, inFrame: Frame) -> FramedVector:
        """
        Resolve the location with respect to a specified frame, performing transport theorem.
        			Returns a FramedVector so you can do ExprIn to specify coordinate basis the location
        			vector should be expressed in.
        """
    def WRT_ExprIn(self, inFrame: Frame) -> numpy.ndarray[numpy.float64[3, 1]]:
        """
        Resolve the location with respect to a specified frame, performing transport theorem.
        			Also uses the same frame (coordinate basis) to express the vector.
        """
class FramedLocVel:
    def WRT(self, inFrame: Frame) -> FramedVector:
        """
        Resolve the velocity with respect to a specified frame, performing transport theorem.
        			Returns a FramedVector so you can do ExprIn to specify coordinate basis the acceleration should be expressed in.
        """
    def WRT_ExprIn(self, inFrame: Frame) -> numpy.ndarray[numpy.float64[3, 1]]:
        """
        Resolve the velocity with respect to a specified frame, performing transport theorem.
        			Also uses the same frame (coordinate basis) to express the vector.
        """
    def loc_WRT(self, inFrame: Frame) -> FramedVector:
        """
        Resolve the location with respect to a specified frame, performing transport theorem.
        			Returns a FramedVector so you can do ExprIn to specify coordinate basis the location should be expressed in.
        """
    def vel_WRT(self, inFrame: Frame) -> FramedVector:
        """
        Resolve the velocity with respect to a specified frame, performing transport theorem.
        			Returns a FramedVector so you can do ExprIn to specify coordinate basis the velocity should be expressed in.
        """
class FramedLocVelAcc:
    def WRT(self, inFrame: Frame) -> FramedVector:
        """
        Resolve the acceleration with respect to a specified frame, performing transport theorem.
        			Returns a FramedVector so you can do ExprIn to specify coordinate basis the acceleration should be expressed in.
        """
    def WRT_ExprIn(self, inFrame: Frame) -> numpy.ndarray[numpy.float64[3, 1]]:
        """
        Resolve the acceleration with respect to a specified frame, performing transport theorem.
        			Also uses the same frame (coordinate basis) to express the vector.
        """
    def acc_WRT(self, inFrame: Frame) -> FramedVector:
        """
        Resolve the acceleration with respect to a specified frame, performing transport theorem.
        			Returns a FramedVector so you can do ExprIn to specify coordinate basis the acceleration should be expressed in.
        """
    def loc_WRT(self, inFrame: Frame) -> FramedVector:
        """
        Resolve the location with respect to a specified frame, performing transport theorem.
        			Returns a FramedVector so you can do ExprIn to specify coordinate basis the location should be expressed in.
        """
    def vel_WRT(self, inFrame: Frame) -> FramedVector:
        """
        Resolve the velocity with respect to a specified frame, performing transport theorem.
        			Returns a FramedVector so you can do ExprIn to specify coordinate basis the velocity should be expressed in.
        """
class FramedRot:
    def DCM_WRT(self, inFrame: Frame) -> numpy.ndarray[numpy.float64[3, 3]]:
        """
        Express the time-extrapolated passive rotation transformation matrix from specified frame to the orientation defined by this FramedRot
        			(DCM, right handed coordinates).
        """
    def Quat_WRT(self, inFrame: Frame) -> numpy.ndarray[numpy.float64[4, 1]]:
        """
        Express the quaternion corresponding to the time-extrapolated passive rotation transformation matrix
        			from specified frame to the orientation defined by this FramedRot
        		 	(xyzw quaternion, right handed coordinates).
        """
class FramedVector:
    def ExprIn(self, expr_frame: Frame) -> numpy.ndarray[numpy.float64[3, 1]]:
        """
        Express the vector in a specified frame (coordinate basis).
        """
class KeplerianState:
    def __init__(self, a_km: float, e: float, raan_rad: float, i_rad: float, omega_rad: float, ta_rad: float, mu_km3_s2: float) -> None:
        ...
    def __repr__(self) -> str:
        ...
    def a(self) -> float:
        ...
    def e(self) -> float:
        ...
    def i(self) -> float:
        ...
    def mu(self) -> ...:
        ...
    def omega(self) -> float:
        ...
    def raan(self) -> float:
        ...
    def ta(self) -> float:
        ...
class LambertBattinResults:
    def __init__(self, v0_km_s: numpy.ndarray[numpy.float64[3, 1]], v_km_s: numpy.ndarray[numpy.float64[3, 1]]) -> None:
        ...
    def __repr__(self) -> str:
        ...
    def v(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def v0(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
class ParamMap:
    def AddCopiesOfAllParamsFrom(self, other: ParamMap) -> None:
        """
         Adds a DeepCopy of all the params on another GenParamMap to this one
        			NOTE: If there are name collisions, this will perform a Set on same-
        			type colliding params, or throw for differing type.
        """
    def AddOrSetParam(self, type: VarType, key: typing.Any, value: typing.Any) -> bool:
        """
        Returns whether the parameter previously existed
        """
    def AddParam(self, type: VarType, key: typing.Any, value: typing.Any) -> None:
        """
        adds a new parameter at the given key on this entity. The input is in the form of std::vector. 
        			There is a static check for if this parameter is actually of a support type.
        """
    def AddParamArray(self, type: VarType, key: typing.Any, value: list) -> None:
        ...
    def DeleteParam(self, key: typing.Any) -> None:
        """
        Remove from map and free memory for a param
        """
    def ForEachParam(self, operations: typing.Callable[[str, VarType], None]) -> None:
        """
        For each of the parameters in this PramMap, supply the key and type and do <operations> Doesn’t allow access to pointer because it’s non-const
        			The operation passed in their are std::function, which is usually made as a lambda function
        """
    def GetParam(self, type: VarType, key: typing.Any) -> typing.Any:
        ...
    def GetParamArray(self, type: VarType, key: typing.Any) -> typing.Any:
        """
        Get a copy of the values from the Parameter Array at the given key on this GenParamMap. 
        			This copy is in the form of a std::vector. 
        """
    def GetParamArrayType(self, key: typing.Any) -> VarType:
        """
        Returns the VarType of the parameter array at the given key.
        """
    def GetParamMap(self, keys: typing.Any) -> ParamMap:
        """
        Get pointer to the GenParamMap at this key.
        """
    def GetParamTime(self, key: typing.Any) -> timestamp:
        """
        Returns the timestamp of the edited-time of the parameter at the given key.
        """
    def GetParamType(self, key: typing.Any) -> VarType:
        """
        Returns the VarType of the parameter at the given key.
        """
    @typing.overload
    def HasParam(self, key: str) -> bool:
        """
        Checks if this Entity has a parameter at the given key.
        """
    @typing.overload
    def HasParam(self, key: typing.Any) -> bool:
        """
        Checks if this Entity has a parameter at the given key.
        """
    @typing.overload
    def HasParam(self, type: VarType, key: typing.Any) -> bool:
        """
        Checks if this Entity has a parameter at the given key with the given type.
        """
    @typing.overload
    def HasParamArray(self, key: typing.Any) -> bool:
        """
        Checks if this Entity has a param array at the given key with any member type.
        """
    @typing.overload
    def HasParamArray(self, type: VarType, key: typing.Any) -> bool:
        """
        Checks if this Entity has a param array at the given key with the given member type.
        """
    def SetParam(self, type: VarType, key: typing.Any, value: typing.Any) -> None:
        """
        Set the value of the parameter at the given key on this GenParamMap with the given value. 
        			There is a runtime check for if this parameter is actually the type you specified to it be.
        """
    def SetParamArray(self, type: VarType, key: typing.Any, value: list) -> None:
        """
        Set the value of the parameter at the given key on this GenParamMap with the given value.
        			The input is in the form of std::vector. There is a runtime check for if this parameter is actually
        			the type you specified to it be. The array will resized itself as needed
        """
    def __init__(self) -> None:
        ...
    def unique_id(self) -> int:
        ...
class PlanetUtils:
    class Coord:
        @typing.overload
        def __init__(self, loc: numpy.ndarray[numpy.float64[3, 1]], rot: numpy.ndarray[numpy.float64[3, 3]], radius: float) -> None:
            ...
        @typing.overload
        def __init__(self, lla: PlanetUtils.LatLonAlt, azimuth: float, radius: float) -> None:
            ...
        def __repr__(self) -> str:
            ...
        def getAzimuth(self) -> float:
            ...
        def getFLU(self) -> PlanetUtils.ForwardLeftUp:
            ...
        def getLatLonAlt(self) -> PlanetUtils.LatLonAlt:
            ...
        def getLoc(self) -> numpy.ndarray[numpy.float64[3, 1]]:
            ...
        def getNWU(self) -> PlanetUtils.NorthWestUp:
            ...
        def getRadius(self) -> float:
            ...
        def getRot(self) -> numpy.ndarray[numpy.float64[3, 3]]:
            ...
    class ForwardLeftUp:
        def __init__(self, forward: numpy.ndarray[numpy.float64[3, 1]], left: numpy.ndarray[numpy.float64[3, 1]], up: numpy.ndarray[numpy.float64[3, 1]]) -> None:
            ...
        def __repr__(self) -> str:
            ...
        def forward(self) -> numpy.ndarray[numpy.float64[3, 1]]:
            ...
        def left(self) -> numpy.ndarray[numpy.float64[3, 1]]:
            ...
        def up(self) -> numpy.ndarray[numpy.float64[3, 1]]:
            ...
    class LatLonAlt:
        def __init__(self, lat: float, lon: float, alt: float) -> None:
            ...
        def __repr__(self) -> str:
            ...
        def alt(self) -> float:
            ...
        def lat(self) -> float:
            ...
        def lon(self) -> float:
            ...
    class NorthWestUp:
        def __init__(self, north: numpy.ndarray[numpy.float64[3, 1]], west: numpy.ndarray[numpy.float64[3, 1]], up: numpy.ndarray[numpy.float64[3, 1]]) -> None:
            ...
        def __repr__(self) -> str:
            ...
        def north(self) -> numpy.ndarray[numpy.float64[3, 1]]:
            ...
        def up(self) -> numpy.ndarray[numpy.float64[3, 1]]:
            ...
        def west(self) -> numpy.ndarray[numpy.float64[3, 1]]:
            ...
    @staticmethod
    def AzimuthFromLocRot(loc: numpy.ndarray[numpy.float64[3, 1]], rot: numpy.ndarray[numpy.float64[3, 3]], radius: float) -> float:
        ...
    @staticmethod
    def ForwardLeftUpFromAzimuth(loc: numpy.ndarray[numpy.float64[3, 1]], azimuth: float, radius: float) -> PlanetUtils.ForwardLeftUp:
        ...
    @staticmethod
    def LLA_to_PCPF(latlonalt: PlanetUtils.LatLonAlt, radius: float) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    @staticmethod
    def NorthWestUpFromLocation(loc: numpy.ndarray[numpy.float64[3, 1]], radius: float) -> PlanetUtils.NorthWestUp:
        ...
    @staticmethod
    def PCPF_to_LLA(loc: numpy.ndarray[numpy.float64[3, 1]], radius: float) -> PlanetUtils.LatLonAlt:
        ...
    @staticmethod
    def RotFromAzimuth(loc: numpy.ndarray[numpy.float64[3, 1]], azimuth: float, radius: float) -> numpy.ndarray[numpy.float64[3, 3]]:
        ...
    @staticmethod
    def RotFromForwardLeftUp(flu: PlanetUtils.ForwardLeftUp) -> numpy.ndarray[numpy.float64[3, 3]]:
        ...
class PropagationType:
    """
    Members:
    
      NoPropagation
    
      ComputePosition
    
      ComputeVelocity
    
      ComputeAcceleration
    
      ComputeJerk
    
      Clientside_FreeBody
    
      Clientside_PawnControl
    
      PhysXInteractible
    
      CoordinateFrame_Static
    """
    Clientside_FreeBody: typing.ClassVar[PropagationType]  # value = <PropagationType.Clientside_FreeBody: 5>
    Clientside_PawnControl: typing.ClassVar[PropagationType]  # value = <PropagationType.Clientside_PawnControl: 6>
    ComputeAcceleration: typing.ClassVar[PropagationType]  # value = <PropagationType.ComputeAcceleration: 3>
    ComputeJerk: typing.ClassVar[PropagationType]  # value = <PropagationType.ComputeJerk: 4>
    ComputePosition: typing.ClassVar[PropagationType]  # value = <PropagationType.ComputePosition: 1>
    ComputeVelocity: typing.ClassVar[PropagationType]  # value = <PropagationType.ComputeVelocity: 2>
    CoordinateFrame_Static: typing.ClassVar[PropagationType]  # value = <PropagationType.CoordinateFrame_Static: 8>
    NoPropagation: typing.ClassVar[PropagationType]  # value = <PropagationType.NoPropagation: 0>
    PhysXInteractible: typing.ClassVar[PropagationType]  # value = <PropagationType.PhysXInteractible: 7>
    __members__: typing.ClassVar[dict[str, PropagationType]]  # value = {'NoPropagation': <PropagationType.NoPropagation: 0>, 'ComputePosition': <PropagationType.ComputePosition: 1>, 'ComputeVelocity': <PropagationType.ComputeVelocity: 2>, 'ComputeAcceleration': <PropagationType.ComputeAcceleration: 3>, 'ComputeJerk': <PropagationType.ComputeJerk: 4>, 'Clientside_FreeBody': <PropagationType.Clientside_FreeBody: 5>, 'Clientside_PawnControl': <PropagationType.Clientside_PawnControl: 6>, 'PhysXInteractible': <PropagationType.PhysXInteractible: 7>, 'CoordinateFrame_Static': <PropagationType.CoordinateFrame_Static: 8>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class Severity:
    """
    Members:
    
      Info
    
      Warning
    
      Error
    """
    Error: typing.ClassVar[Severity]  # value = <Severity.Error: 2>
    Info: typing.ClassVar[Severity]  # value = <Severity.Info: 0>
    Warning: typing.ClassVar[Severity]  # value = <Severity.Warning: 1>
    __members__: typing.ClassVar[dict[str, Severity]]  # value = {'Info': <Severity.Info: 0>, 'Warning': <Severity.Warning: 1>, 'Error': <Severity.Error: 2>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class SimConfig:
    @staticmethod
    def LoadFromFile(filepath: str) -> SimConfig:
        """
        Read a SimConfig from a properly formatted JSON file. Has good logging code for feedback about invalid syntax.
        """
    def AddEntity(self, config: EntityConfig) -> None:
        """
        Adds a (assumed-properly-initialized) EntityConfig to the sim config
        """
    def AddSystem(self, config: SystemConfig) -> None:
        """
        Adds a (assumed-properly-initialized) SystemConfig to the sim config
        """
    def AddTaskflow(self, config: TaskflowConfig) -> None:
        """
        Adds a (assumed-properly-initialized) TaskflowConfig to the sim config.
        """
    def GetEntities(self) -> list[EntityConfig]:
        ...
    def GetEntityTemplates(self) -> list[EntityConfig]:
        ...
    def GetSimEndTime(self) -> timestamp:
        ...
    def GetSimEntity(self) -> EntityConfig:
        """
        Identify the name of the EntityConfig
        """
    def GetSimStartTime(self) -> timestamp:
        """
        Get the time of the sim clock will read at the beginning of the sim. 
        			This value will not be applicable if UsCurrentTime = true
        """
    def GetSystems(self) -> list[SystemConfig]:
        ...
    def HasSimEndTime(self) -> bool:
        """
        Return the boolean of if this sim has an end time
        """
    def RemoveEntity(self, config: EntityConfig) -> None:
        """
        Removes this referenced Entity from the sim config
        """
    def RemoveSimEndTime(self) -> None:
        """
        Removes the timestamped-based sim end condition
        """
    def RemoveSystem(self, config: SystemConfig) -> None:
        ...
    def RemoveTaskflow(self, config: TaskflowConfig) -> None:
        """
        Removes this referenced Taskflow instance from the sim config.
        """
    def SaveToFile(self, filepath: str) -> None:
        """
        Write this SimConfig to a JSON file.
        """
    def SetSimEndTime(self, simtime: timestamp) -> None:
        ...
    def SetSimStartTime(self, simtime: timestamp) -> None:
        ...
    def __init__(self) -> None:
        ...
class SimState:
    """
    Members:
    
      Loading : Starting state of all network notes
    
      Lobby : After we finish the loading process and have opened
    		the proper network connections (probably sockets) to receive PlatformOrders. We wait around in 
    		this state for someone to send the SimStated PlatformOrder.
    
      Runtime : After SimStarted is received, this is the state we stay in for “normal” operations
    
      Paused : In this day, we stop all network notes if possible so something big like a hose migration can happen
    
      Playback : In this state, the state of the platform is being driven by recorded transactional stage changes that are being steam as platform order by one of the network nodes
    
      Stopping : In this state, the platform is treated as undefined because network nodes are expected to disconnect at any moment. Any time a network node is in this state, the network 
    		node should work to and/close the local representation of the simulation
    """
    Loading: typing.ClassVar[SimState]  # value = <SimState.Loading: 0>
    Lobby: typing.ClassVar[SimState]  # value = <SimState.Lobby: 1>
    Paused: typing.ClassVar[SimState]  # value = <SimState.Paused: 3>
    Playback: typing.ClassVar[SimState]  # value = <SimState.Playback: 4>
    Runtime: typing.ClassVar[SimState]  # value = <SimState.Runtime: 2>
    Stopping: typing.ClassVar[SimState]  # value = <SimState.Stopping: 5>
    __members__: typing.ClassVar[dict[str, SimState]]  # value = {'Loading': <SimState.Loading: 0>, 'Lobby': <SimState.Lobby: 1>, 'Runtime': <SimState.Runtime: 2>, 'Paused': <SimState.Paused: 3>, 'Playback': <SimState.Playback: 4>, 'Stopping': <SimState.Stopping: 5>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class State:
    @staticmethod
    def fromCartesian(R_km: numpy.ndarray[numpy.float64[3, 1]], V_km_s: numpy.ndarray[numpy.float64[3, 1]], mu_km3_s2: float) -> State:
        ...
    @staticmethod
    def fromKeplerian(a_km: float, e: float, raan_rad: float, i_rad: float, omega_rad: float, ta_rad: float, mu_km3_s2: float) -> State:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: CartesianState) -> None:
        ...
    def asCartesian(self) -> CartesianState:
        ...
    def asKeplerian(self) -> KeplerianState:
        ...
    def timeSincePeriapsis(self) -> float:
        ...
class SurfaceMove:
    @staticmethod
    def GetAzimuth(en: Entity, pcpf: ..., radius: float) -> float:
        ...
    @staticmethod
    def GetCurrentCoord(en: Entity, pcpf: ..., radius: float) -> PlanetUtils.Coord:
        ...
    @staticmethod
    def GetMoveToCoord(en: Entity, pcpf: ..., radius: float) -> PlanetUtils.Coord:
        ...
    @staticmethod
    def GetMovementState(en: Entity) -> str:
        ...
    @staticmethod
    def IsMoving(en: Entity) -> bool:
        ...
    @staticmethod
    def OnMoveComplete(en: Entity, reaction: typing.Callable[[GenParamMap], None]) -> None:
        ...
    @staticmethod
    def TurnAndMoveToCoord(en: Entity, coord: PlanetUtils.Coord, pcpf: ..., radius: float) -> None:
        ...
    @staticmethod
    def TurnAndReverseToCoord(en: Entity, coord: PlanetUtils.Coord, pcpf: ..., radius: float) -> None:
        ...
    @staticmethod
    def TurnToAzimuth(en: Entity, azimuth: float, pcpf: ..., radius: float) -> None:
        ...
class SystemConfig(ParamMap):
    def __init__(self) -> None:
        ...
    def getFrequency(self) -> float:
        """
        Get the frequency of this SystemConfig
        """
    def getNameTag(self) -> str:
        """
        Get the name tag of this SystemConfig
        """
    def getSource(self) -> str:
        """
        Get the source of this SystemConfig
        """
    def setFrequency(self, frequency: float) -> None:
        """
        Set the frequency of this SystemConfig
        """
class TaskflowConfig:
    def __init__(self) -> None:
        ...
    def getFrequency(self) -> float:
        """
        Get the frequency of this TaskflowConfig
        """
    def getNameTag(self) -> str:
        """
        Get the name tag of this TaskflowConfig
        """
    def getSystems(self) -> list[str]:
        """
        Get the system  of this TaskflowConfig
        """
    def setFrequency(self, frequency: float) -> None:
        """
        Set the frequency of this TaskflowConfig
        """
class VarType:
    """
    Members:
    
      Uninitialized
    
      Unrecognized
    
      bytes
    
      bitset64
    
      bool
    
      uint8
    
      uint16
    
      uint32
    
      uint64
    
      int8
    
      int16
    
      int32
    
      int64
    
      duration
    
      timestamp
    
      uuid
    
      entityID
    
      entityRef
    
      entityRefUnresolved
    
      float : NOTE: python float is actually VarType double
    
      double : python type is "float"
    
      char
    
      doubleV2 : python type is numpy array
    
      doubleV3 : python type is numpy array
    
      doubleV4 : python type is numpy array
    
      doubleM2x2 : python type is numpy matrix
    
      doubleM3x3 : python type is numpy matrix
    
      doubleM4x4 : python type is numpy matrix
    
      doubleM5x5 : python type is numpy matrix
    
      doubleM6x6 : python type is numpy matrix
    
      string
    
      paramArray : python type is a list of the member type
    
      paramMap
    """
    Uninitialized: typing.ClassVar[VarType]  # value = <VarType.Uninitialized: 0>
    Unrecognized: typing.ClassVar[VarType]  # value = <VarType.Unrecognized: 1>
    __members__: typing.ClassVar[dict[str, VarType]]  # value = {'Uninitialized': <VarType.Uninitialized: 0>, 'Unrecognized': <VarType.Unrecognized: 1>, 'bytes': <VarType.bytes: 2>, 'bitset64': <VarType.bitset64: 3>, 'bool': <VarType.bool: 4>, 'uint8': <VarType.uint8: 5>, 'uint16': <VarType.uint16: 6>, 'uint32': <VarType.uint32: 7>, 'uint64': <VarType.uint64: 8>, 'int8': <VarType.int8: 9>, 'int16': <VarType.int16: 10>, 'int32': <VarType.int32: 11>, 'int64': <VarType.int64: 12>, 'duration': <VarType.duration: 13>, 'timestamp': <VarType.timestamp: 14>, 'uuid': <VarType.uuid: 15>, 'entityID': <VarType.entityID: 16>, 'entityRef': <VarType.entityRef: 17>, 'entityRefUnresolved': <VarType.entityRefUnresolved: 18>, 'float': <VarType.float: 19>, 'double': <VarType.double: 20>, 'char': <VarType.char: 21>, 'doubleV2': <VarType.doubleV2: 22>, 'doubleV3': <VarType.doubleV3: 23>, 'doubleV4': <VarType.doubleV4: 24>, 'doubleM2x2': <VarType.doubleM2x2: 25>, 'doubleM3x3': <VarType.doubleM3x3: 26>, 'doubleM4x4': <VarType.doubleM4x4: 27>, 'doubleM5x5': <VarType.doubleM5x5: 28>, 'doubleM6x6': <VarType.doubleM6x6: 29>, 'string': <VarType.string: 30>, 'paramArray': <VarType.paramArray: 31>, 'paramMap': <VarType.paramMap: 32>}
    bitset64: typing.ClassVar[VarType]  # value = <VarType.bitset64: 3>
    bool: typing.ClassVar[VarType]  # value = <VarType.bool: 4>
    bytes: typing.ClassVar[VarType]  # value = <VarType.bytes: 2>
    char: typing.ClassVar[VarType]  # value = <VarType.char: 21>
    double: typing.ClassVar[VarType]  # value = <VarType.double: 20>
    doubleM2x2: typing.ClassVar[VarType]  # value = <VarType.doubleM2x2: 25>
    doubleM3x3: typing.ClassVar[VarType]  # value = <VarType.doubleM3x3: 26>
    doubleM4x4: typing.ClassVar[VarType]  # value = <VarType.doubleM4x4: 27>
    doubleM5x5: typing.ClassVar[VarType]  # value = <VarType.doubleM5x5: 28>
    doubleM6x6: typing.ClassVar[VarType]  # value = <VarType.doubleM6x6: 29>
    doubleV2: typing.ClassVar[VarType]  # value = <VarType.doubleV2: 22>
    doubleV3: typing.ClassVar[VarType]  # value = <VarType.doubleV3: 23>
    doubleV4: typing.ClassVar[VarType]  # value = <VarType.doubleV4: 24>
    duration: typing.ClassVar[VarType]  # value = <VarType.duration: 13>
    entityID: typing.ClassVar[VarType]  # value = <VarType.entityID: 16>
    entityRef: typing.ClassVar[VarType]  # value = <VarType.entityRef: 17>
    entityRefUnresolved: typing.ClassVar[VarType]  # value = <VarType.entityRefUnresolved: 18>
    float: typing.ClassVar[VarType]  # value = <VarType.float: 19>
    int16: typing.ClassVar[VarType]  # value = <VarType.int16: 10>
    int32: typing.ClassVar[VarType]  # value = <VarType.int32: 11>
    int64: typing.ClassVar[VarType]  # value = <VarType.int64: 12>
    int8: typing.ClassVar[VarType]  # value = <VarType.int8: 9>
    paramArray: typing.ClassVar[VarType]  # value = <VarType.paramArray: 31>
    paramMap: typing.ClassVar[VarType]  # value = <VarType.paramMap: 32>
    string: typing.ClassVar[VarType]  # value = <VarType.string: 30>
    timestamp: typing.ClassVar[VarType]  # value = <VarType.timestamp: 14>
    uint16: typing.ClassVar[VarType]  # value = <VarType.uint16: 6>
    uint32: typing.ClassVar[VarType]  # value = <VarType.uint32: 7>
    uint64: typing.ClassVar[VarType]  # value = <VarType.uint64: 8>
    uint8: typing.ClassVar[VarType]  # value = <VarType.uint8: 5>
    uuid: typing.ClassVar[VarType]  # value = <VarType.uuid: 15>
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class timestamp:
    __hash__: typing.ClassVar[None] = None
    def __add__(self, duration: float) -> timestamp:
        ...
    def __eq__(self, other: timestamp) -> bool:
        ...
    def __ge__(self, other: timestamp) -> bool:
        ...
    def __gt__(self, other: timestamp) -> bool:
        ...
    def __init__(self) -> None:
        ...
    def __le__(self, other: timestamp) -> bool:
        ...
    def __lt__(self, other: timestamp) -> bool:
        ...
    def __ne__(self, other: timestamp) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def as_datetime(self) -> typing.Any:
        """
        Gets the timestamp as a Python datetime. This converts the time from the TAI clock to system_clock (~UTC).
        			See this for more clock choice details: https://stackoverflow.com/a/64084510/11502722
        """
    def as_tai_string(self) -> str:
        """
        Return a string of the timestamp, keeping it as TAI clock.
        			See this for more clock choice details: https://stackoverflow.com/a/64084510/11502722
        """
    def as_utc_string(self) -> str:
        """
        Return a string of the timestamp after converting it to UTC.
        			See this for more clock choice details: https://stackoverflow.com/a/64084510/11502722
        """
    def from_datetime(self) -> timestamp:
        """
        Construct a timestamp object from a Python datetime. This converts the time from the system_clock (~UTC) to the sim TAI clock.
        			See this for more clock choice details: https://stackoverflow.com/a/64084510/11502722
        """
def CanTransmit() -> bool:
    """
    Widely-accessible static functions that access the singleton state of the simulation
    """
def CaptureImage(camera_en: Entity, properties: CaptureImageProperties) -> int:
    """
    Capture an image from the given camera entity with the given properties.
    		Use OnImageReceived() with the returned capture_id to react to the image.
    """
def GetSimEntity() -> Entity:
    ...
def GetSimState() -> SimState:
    """
    get the simulation state
    """
def GetState(en: Entity, frame: ..., mu: float) -> State:
    ...
def GetStopReason() -> str:
    ...
def GetThisSystem() -> SystemConfig:
    ...
def GetWallTime_SimStarted() -> datetime.timedelta:
    ...
def LagrangePropagation(state: State, delta_t: float, tolerance: float, max_iterations: int) -> State:
    ...
def LambertBattin(r0: numpy.ndarray[numpy.float64[3, 1]], r: numpy.ndarray[numpy.float64[3, 1]], deltaTime: float, tm: float, mu: float, n: int, tol: float, max_iter: int) -> LambertBattinResults:
    ...
def MandateSimStateChange(newState: SimState, retransmit: bool = ...) -> None:
    ...
def MandateSimStop(reason: str, retransmit: bool = ...) -> None:
    ...
def OnImageReceived(capture_id: int, reaction: typing.Callable[[CapturedImage], None]) -> None:
    """
    React to an image received with the given capture_id. Reaction must be a function that takes a CapturedImage.
    """
def OnScreenAlert(message: str, topic: str, severity: Severity) -> None:
    """
    Send alert that is shown on all app screens, is deduplicated by topic name, and is erased after a few seconds.
    """
def OnScreenLogMessage(message: str, category: str, severity: Severity) -> None:
    """
    Send message that is shown on all app screens, and stays in a log.
    """
def RequestSimStateChange(newState: SimState, retransmit: bool = ...) -> bool:
    """
    Widely-accessible static functions that access the singleton state of the simulation
    """
def SetState(state: State, en: Entity, frame: ...) -> None:
    ...
def SimConfig_LoadFromFile(filepath: str) -> SimConfig:
    """
    Deprecated; use SimConfig.LoadFromFile() instead.
    		Read a SimConfig from a properly formatted JSON file. Has good logging code for feedback about invalid syntax.
    """
def SimConfig_SaveToFile(simconf: SimConfig, filepath: str) -> None:
    """
    Deprecated; use SimConfig.SaveToFile() instead.
    		Write a SimConfig to a JSON file.
    """
def SimGlobals_AddEntity(e_config: EntityConfig) -> Entity:
    ...
def SimGlobals_AddEntityFromTemplate(template_name: str, entity_name: str, system_nametags: list[str], add_param_operations: typing.Callable[[ParamMap], None]) -> SC_EntityRef:
    """
    Adds a new entity using the entity config file at template_path as a starting point.
    	   All parameters added to the GenParamMap in the add_param_operations lambda will be used to either overwrite the
    	   original parameter value (from the entity template) or add a new parameter. Core/ template_path is relative to the
    	   Platform root directory (one above the Compute_Server or SharedData directories).
    	   NOTE: Only use AddParam or AddNestedParam functions in the lambda; the template's parameters are not already
    	   in the given GenParamMap.
    """
def SimGlobals_AddEventListener(eventName: str, delegateFn: typing.Callable[[ParamMap, timestamp], None]) -> None:
    """
    Widely-accessible static functions that access the singleton state of the simulation
    """
def SimGlobals_DeleteEntity(en: Entity, retransmit: bool = ...) -> None:
    ...
def SimGlobals_DispatchEvent(eventName: str, payload: ParamMap) -> None:
    ...
def SimGlobals_GetBaseFrame() -> BaseFrame_Impl:
    ...
def SimGlobals_GetGlobalFrame() -> BaseFrame_Impl:
    """
    Deprecated; use GetBaseFrame instead.
    """
def SimGlobals_SimClock_Freeze() -> None:
    """
    Freezes the simulation clock. This function sets the sim timescale to 0, which halts the 
    	courting of wall time towards sim time, effectively pausing the simulation
    	
    	Parameters:
    	__wallTimeToApply The wall time this clock modification should be submitted for, in "sc_tai::time" object. 
    	The default value is the current wall time (sc_tai::now()) re-transimit A boolean flag indicating whether 
    	or not to retransmit the new time setting. The default value is true.
    """
def SimGlobals_SimClock_GetTimeNow() -> sc_timestamp_wrapper:
    """
    Retrieves the current simulation time dysfunction, returns the current time of the 
    		simulation clock as an object of type 'sc_tai_time'
    
    		Returns: The current time in 'sc_tai_time' format
    """
def SimGlobals_SimClock_GetTimescale() -> float:
    """
    Retrieves the current time scaling factor of the simulation dysfunction, 
    		returns the current time scaling factor which determines how simulation time relates to real 
    		(wall clock) time. A value of 1.0 would mean they are the same, A value greater than 1 would 
    		mean the simulation time is faster than real time. A value of zero would mean time freezes 
    		(but the simulation Functionality still runs). Negative values are allowed as well. 
    
    		Return: The current time scaling factor as a 'double'
    """
def SimGlobals_SimClock_ResetTo(setClockTo: sc_timestamp_wrapper) -> None:
    """
    Resets clock to a specific time, and freeze simclock. This function resets the 
    		simulation call to the given ‘setClockTo’ time.
    """
def SimGlobals_SimClock_SetTimescale(timescale: float) -> None:
    """
    Set simulation timescale. This is the ratio of time passage per wall time passage
    """
def SimGlobals_SimClock_UnFreeze() -> None:
    """
    Unfreezes the simulation clock, using the last non-zero timescale.
    	
    	Parameters:
    	_wallTimeToApply The wall time this clock modification should be submitted for, 
    	in `sc_tai_time` object. The default value is the current wall time (`sc_tai::now()`). 
    	retransmit A boolean flag indicating whether or not to retransmit the new time setting. 
    	The default value is true.
    """
def calcTime(arg0: float, arg1: float, arg2: float, arg3: float, arg4: numpy.ndarray[numpy.float64[3, 1]]) -> ...:
    ...
def connect_to_sim(sys_argv: list[str]) -> None:
    """
    Connect to a running simulation as a ServerAsLocalClient.
    sys_argv - insert python sys.argv here.
    """
def constant(name: str) -> float:
    """
    Returns the value of constants based off of the string name of the constant. Uses SI base units, with the exception of kilograms.
    """
def get_entities() -> list[Entity]:
    ...
def get_nametag() -> str:
    ...
def leave_sim() -> None:
    """
    Leave the sim without ending it for other users/programs.
    """
def logger_error(msg: str) -> None:
    """
    Output logger error
    """
def logger_fatal(msg: str) -> None:
    """
    Output logger fatal error
    """
def logger_info(msg: str) -> None:
    """
    Output logger information
    """
def logger_warn(msg: str) -> None:
    """
    Output logger warnings
    """
def standalone_sim(path: str) -> None:
    """
    Run a simulation that is self-contained within this Python process.
    path - Filepath of sim config.
    """
def stop_sim() -> None:
    """
    Stop the sim, which ends it for all users/programs.
    """
